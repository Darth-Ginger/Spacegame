<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteDocumentBaseClass(CodeGenerationContext context)
	{
#>

#pragma warning disable 0660, 0661
	public abstract partial class <#= context.TargetLanguage.DocumentClassName #>
	{
		public <#= context.TargetLanguage.DocumentClassName #> Parent { get; private set; }

		public static bool operator ==(<#= context.TargetLanguage.DocumentClassName #> value1, <#= context.TargetLanguage.DocumentClassName #> value2)
		{
			if (ReferenceEquals(value1, value2)) return true;
			if (ReferenceEquals(value1, null) || ReferenceEquals(value2, null)) return false;

			return Equals(value1, value2);
		}
		public static bool operator !=(<#= context.TargetLanguage.DocumentClassName #> value1, <#= context.TargetLanguage.DocumentClassName #> value2)
		{
			if (ReferenceEquals(value1, value2)) return false;
			if (ReferenceEquals(value1, null) || ReferenceEquals(value2, null)) return true;

			return Equals(value1, value2) == false;
		}

		protected static void SetParent(<#= context.TargetLanguage.DocumentClassName #> document, <#= context.TargetLanguage.DocumentClassName #> parent)
		{
			if (ReferenceEquals(document, null)) return;

			document.Parent = parent;
		}

		protected static bool AreEquals<T>(T value1, T value2)
		{
			return EqualityComparer<T>.Default.Equals(value1, value2);
		}
		protected static int GetHashCodeFor<T>(T value)
		{
			return EqualityComparer<T>.Default.GetHashCode(value);
		}
	}
#pragma warning restore 0660, 0661

<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteDocumentCollection(CodeGenerationContext context)
	{
#>

	[Serializable, DebuggerDisplay("DocumentCollection, Count: {" + nameof(Count) + "}")]
	public partial class DocumentCollection<KeyT, DocumentT> : IReadOnlyDictionary<KeyT, DocumentT>, IEquatable<DocumentCollection<KeyT, DocumentT>> where DocumentT : <#= context.TargetLanguage.DocumentClassName #>
	{
		public static readonly DocumentCollection<KeyT, DocumentT> Empty = new DocumentCollection<KeyT, DocumentT>(Array.Empty<DocumentT>(), new Dictionary<KeyT, DocumentT>(), new Dictionary<Delegate, object>());

		private readonly IReadOnlyList<DocumentT> documents;
		private readonly IReadOnlyDictionary<KeyT, DocumentT> documentsByKey;
		private readonly Dictionary<Delegate, object> byPropertyDictionary;

		public IReadOnlyList<DocumentT> AsList => this.documents;
		/// <inheritdoc />
		public DocumentT this[KeyT key] => this.documentsByKey[key];
		/// <inheritdoc />
		public IEnumerable<KeyT> Keys => this.documentsByKey.Keys;
		/// <inheritdoc />
		public IEnumerable<DocumentT> Values => this.documentsByKey.Values;
		/// <inheritdoc />
		public int Count => this.documentsByKey.Count;

		private DocumentCollection(IReadOnlyList<DocumentT> documents, IReadOnlyDictionary<KeyT, DocumentT> documentsByKey, Dictionary<Delegate, object> byPropertyDictionary)
		{
			if (documents == null) throw new ArgumentNullException(nameof(documents));
			if (documentsByKey == null) throw new ArgumentNullException(nameof(documentsByKey));
			if (byPropertyDictionary == null) throw new ArgumentNullException(nameof(byPropertyDictionary));

			this.documents = documents;
			this.documentsByKey = documentsByKey;
			this.byPropertyDictionary = byPropertyDictionary;
		}
		public DocumentCollection(IEnumerable<DocumentT> documents, Func<DocumentT, KeyT> selectKeyFunc, IEqualityComparer<KeyT> idComparer = default)
		{
			if (documents == null) throw new ArgumentNullException(nameof(documents));
			if (selectKeyFunc == null) throw new ArgumentNullException(nameof(selectKeyFunc));

			this.documents = documents as IReadOnlyList<DocumentT> ?? documents.ToList();
			var documentByKey = new Dictionary<KeyT, DocumentT>(this.documents.Count, idComparer ?? EqualityComparer<KeyT>.Default);
			foreach (var document in this.documents)
			{
				if (document == null)
				{
					continue;
				}

				var key = selectKeyFunc(document);
				if (ReferenceEquals(key, null))
				{
					continue;
				}

				documentByKey[key] = document;
			}

			this.documentsByKey = documentByKey;
			this.byPropertyDictionary = new Dictionary<Delegate, object> {
				{ selectKeyFunc, this }
			};
		}

		/// <inheritdoc />
		IEnumerator<KeyValuePair<KeyT, DocumentT>> IEnumerable<KeyValuePair<KeyT, DocumentT>>.GetEnumerator()
		{
			return this.documentsByKey.GetEnumerator();
		}
		/// <inheritdoc />
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable)this.documentsByKey).GetEnumerator();
		}

		/// <inheritdoc />
		public bool ContainsKey(KeyT key)
		{
			return this.documentsByKey.ContainsKey(key);
		}
		/// <inheritdoc />
		public bool TryGetValue(KeyT key, out DocumentT value)
		{
			return this.documentsByKey.TryGetValue(key, out value);
		}

		public DocumentT Get(KeyT key)
		{
			if (!this.TryGetValue(key, out var document))
			{
				throw new ArgumentException($"Unable find {typeof(DocumentT).Name} with one of unique attributes equals to '{key}'.",nameof(key));
			}
			return document;
		}
		public DocumentT Find(KeyT key)
		{
			this.TryGetValue(key, out var document);
			return document;
		}

		[Obsolete("Use ByKey() method due better semantic. This method will be removed after 01.01.2024")]
		public DocumentCollection<NewKeyT, DocumentT> WithOtherKey<NewKeyT>(Func<DocumentT, NewKeyT> selectKeyFunc, IEqualityComparer<NewKeyT> keyComparer = default)
		{
			return this.ByKey(selectKeyFunc, keyComparer);
		}
		public DocumentCollection<NewKeyT, DocumentT> ByKey<NewKeyT>(Func<DocumentT, NewKeyT> selectKeyFunc, IEqualityComparer<NewKeyT> keyComparer = default)
		{
			if (selectKeyFunc == null) throw new ArgumentNullException(nameof(selectKeyFunc));

			if (this.Count == 0)
			{
				return DocumentCollection<NewKeyT, DocumentT>.Empty;
			}

			lock (this.byPropertyDictionary)
			{
				if (this.byPropertyDictionary.TryGetValue(selectKeyFunc, out var documentCollectionObj) &&
					documentCollectionObj is DocumentCollection<NewKeyT, DocumentT> existingDocumentCollection)
				{
					return existingDocumentCollection;
				}
			}

			var newDocumentByKey = new Dictionary<NewKeyT, DocumentT>(keyComparer ?? EqualityComparer<NewKeyT>.Default);
			foreach (var document in this.documents)
			{
				if (document == null)
				{
					continue;
				}

				var key = selectKeyFunc(document);
				if (ReferenceEquals(key, null))
				{
					continue;
				}

				newDocumentByKey[key] = document;
			}

			lock (this.byPropertyDictionary)
			{
				var newDocumentCollection = new DocumentCollection<NewKeyT, DocumentT>(this.documents, newDocumentByKey, this.byPropertyDictionary);
				this.byPropertyDictionary[selectKeyFunc] = newDocumentCollection;
				return newDocumentCollection;
			}
		}

		public IEnumerator<DocumentT> GetEnumerator()
		{
			return this.documents.GetEnumerator();
		}

		/// <inheritdoc />
		public bool Equals(DocumentCollection<KeyT, DocumentT> other)
		{
			if (ReferenceEquals(null, other)) return false;
			if (ReferenceEquals(this, other)) return true;

			return this.documents.SequenceEqual(other.documents);
		}
		/// <inheritdoc />
		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			if (ReferenceEquals(this, obj)) return true;
			if (obj.GetType() != this.GetType()) return false;

			return this.Equals((DocumentCollection<KeyT, DocumentT>)obj);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.documents.Aggregate(0, (acc, next) => unchecked(next.GetHashCode() * 17 + acc));
		}

		/// <inheritdoc />
		public override string ToString()
		{
			return this.documentsByKey.ToString();
		}
	}

<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteDocumentReferenceBaseClass(CodeGenerationContext context)
	{
#>

	public sealed partial class <#= context.TargetLanguage.DocumentReferenceClassName #><DocumentT> where DocumentT : <#= context.TargetLanguage.DocumentClassName #>
	{
		private readonly string schemaIdOrName;
		[NonSerialized]
		private DocumentT document;
		[NonSerialized]
		private readonly Func<string, object, <#= context.TargetLanguage.DocumentClassName #>> findFunc;

		public object Id { get; }

		public <#= context.TargetLanguage.DocumentReferenceClassName #>(object id, string schemaIdOrName, Func<string, object, <#= context.TargetLanguage.DocumentClassName #>> findFunc)
		{
			if (id == null) throw new ArgumentNullException(nameof(id));
			if (findFunc == null) throw new ArgumentNullException(nameof(findFunc));

			this.schemaIdOrName = schemaIdOrName;
			this.findFunc = findFunc;
			this.Id = id;
		}

		public DocumentT Dereference()
		{
			if (this.document != null)
			{
				return this.document;
			}

			return this.document = (DocumentT)this.findFunc(this.schemaIdOrName, this.Id);
		}

		public static implicit operator DocumentT(<#= context.TargetLanguage.DocumentReferenceClassName #><DocumentT> reference)
		{
			return reference.Dereference();
		}

		public override bool Equals(object value)
		{
			if (!(value is <#= context.TargetLanguage.DocumentReferenceClassName #><DocumentT> other))
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}

			return Equals(this.Id, other.Id);
		}

		public override int GetHashCode()
		{
			var hashCode = this.Id != null ? this.Id.GetHashCode() : 0;
			return hashCode;
		}

		public override string ToString()
		{
			return $"Id: {this.Id}, Schema: {this.schemaIdOrName}, Resolved: {this.document != null}";
		}
	}

<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteDocumentReferenceCollection(CodeGenerationContext context)
	{
#>

	[Serializable, DebuggerDisplay("DocumentReferenceCollection, Count: {" + nameof(Count) + "}")]
	public partial class DocumentReferenceCollection<DocumentT>: IReadOnlyList<<#= context.TargetLanguage.DocumentReferenceClassName #><DocumentT>>, IEquatable<DocumentReferenceCollection<DocumentT>> where DocumentT : <#= context.TargetLanguage.DocumentClassName #>
	{
		public static readonly DocumentReferenceCollection<DocumentT> Empty = new DocumentReferenceCollection<DocumentT>(Array.Empty<<#= context.TargetLanguage.DocumentReferenceClassName #><DocumentT>>());

		private readonly IReadOnlyList<<#= context.TargetLanguage.DocumentReferenceClassName #><DocumentT>> referenceList;
		[NonSerialized]
		private object documentCollectionById;
		[NonSerialized]
		private IReadOnlyList<DocumentT> documentList;

		public DocumentReferenceCollection(IReadOnlyList<<#= context.TargetLanguage.DocumentReferenceClassName #><DocumentT>> referenceList)
		{
			if (referenceList == null) throw new ArgumentNullException(nameof(referenceList));

			this.referenceList = referenceList;
		}

		/// <inheritdoc />
		public int Count => this.referenceList.Count;
		/// <inheritdoc />
		public <#= context.TargetLanguage.DocumentReferenceClassName #><DocumentT> this[int index] => this.referenceList[index];

		public IReadOnlyList<DocumentT> Dereference()
		{
			if (this.documentList != null)
			{
				return this.documentList;
			}
			var documents = new DocumentT[this.Count];
			for (var i = 0; i < this.referenceList.Count; i++)
			{
				documents[i] = this.referenceList[i].Dereference();
			}
			return this.documentList = documents;
		}
		public DocumentCollection<IdT, DocumentT> Dereference<IdT>(Func<DocumentT, IdT> idSelectFunc)
		{
			if (idSelectFunc == null) throw new ArgumentNullException(nameof(idSelectFunc));

			if (this.documentCollectionById == null && this.Count == 0)
			{
				this.documentCollectionById = DocumentCollection<IdT, DocumentT>.Empty;
			}
			else if((this.documentCollectionById as DocumentCollection<IdT, DocumentT>) == null)
			{
				var documents = this.Dereference();
				this.documentCollectionById = new DocumentCollection<IdT, DocumentT>(documents, idSelectFunc);
			}
			return (DocumentCollection<IdT, DocumentT>)this.documentCollectionById;
		}

		/// <inheritdoc />
		IEnumerator<<#= context.TargetLanguage.DocumentReferenceClassName #><DocumentT>> IEnumerable<<#= context.TargetLanguage.DocumentReferenceClassName #><DocumentT>>.GetEnumerator()
		{
			return this.referenceList.GetEnumerator();
		}
		/// <inheritdoc />
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable)this.referenceList).GetEnumerator();
		}
		/// <inheritdoc />
		public bool Equals(DocumentReferenceCollection<DocumentT> other)
		{
			if (ReferenceEquals(null, other)) return false;
			if (ReferenceEquals(this, other)) return true;

			return this.referenceList.SequenceEqual(other.referenceList);
		}
		/// <inheritdoc />
		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			if (ReferenceEquals(this, obj)) return true;
			if (obj.GetType() != this.GetType()) return false;

			return this.Equals((DocumentReferenceCollection<DocumentT>)obj);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.referenceList.Aggregate(0, (acc, next) => unchecked(next.GetHashCode() * 17 + acc));
		}

		/// <inheritdoc />
		public override string ToString()
		{
			return this.referenceList.ToString();
		}
	}

<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteLocalizedString(CodeGenerationContext context)
	{
#>

	[Serializable, DebuggerDisplay("LocalizedString, Count: {" + nameof(Count) + "}")]
	public sealed partial class LocalizedString : IReadOnlyDictionary<string, string>
	{
		public static readonly LocalizedString Empty = new LocalizedString(Array.Empty<KeyValuePair<string, string>>(), new LanguageSwitcher());

		private static readonly StringComparer LanguageIdComparer = StringComparer.OrdinalIgnoreCase;

		public sealed class LanguageSwitcher
		{
			public string CurrentLanguageId = "en-US";
			public string FallbackLanguageId = "en-US";
			public string PrimaryLanguageId = "en-US";
			public FallbackOption FallbackOption = FallbackOption.OnNull;
		}

		public enum FallbackOption
		{
			/// <summary>
			///  Fallback when the localized text is null (default)
			/// </summary>
			OnNull,
			/// <summary>
			/// Fallback when the localized text is an empty string
			/// </summary>
			OnEmpty,
			/// <summary>
			/// Fallback when the localized text is not defined in the LocalizedString
			/// </summary>
			OnNotDefined,
		}

		private readonly LanguageSwitcher languageSwitcher;
		private readonly string[] keys;
		private readonly string[] values;
		private string currentValue;
		private string currentValueLanguageId;

		/// <inheritdoc />
		public int Count => this.keys.Length;
		public string Value => this.GetOrUpdateCurrentValue();

		/// <inheritdoc cref="IReadOnlyDictionary{TKey,TValue}.this" />
		public string this[string key]
		{
			get
			{
				var languageIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, key, LanguageIdComparer);
				return languageIndex < 0 ? null : this.values[languageIndex];
			}
		}

		public LocalizedString(IReadOnlyList<KeyValuePair<string, string>> textByLanguageId, LanguageSwitcher languageSwitcher)
		{
			if (textByLanguageId == null) throw new ArgumentNullException(nameof(textByLanguageId));
			if (languageSwitcher == null) throw new ArgumentNullException(nameof(languageSwitcher));

			this.languageSwitcher = languageSwitcher;

			this.keys = new string[textByLanguageId.Count];
			this.values = new string[textByLanguageId.Count];
			for (var i = 0; i < textByLanguageId.Count; i++)
			{
				this.keys[i] = textByLanguageId[i].Key;
				this.values[i] = textByLanguageId[i].Value;
			}
		}

		private string GetOrUpdateCurrentValue()
		{
			var currentLanguageId = this.languageSwitcher.CurrentLanguageId;
			var fallbackLanguageId = this.languageSwitcher.FallbackLanguageId;
			var primaryLanguageId = this.languageSwitcher.PrimaryLanguageId;

			if (currentLanguageId != this.currentValueLanguageId)
			{
				this.currentValueLanguageId = currentLanguageId;
				switch (this.languageSwitcher.FallbackOption)
				{
					case FallbackOption.OnNotDefined:
						if (!this.TryGetValue(currentLanguageId, out this.currentValue) &&
							!this.TryGetValue(fallbackLanguageId, out this.currentValue))
						{
							this.TryGetValue(primaryLanguageId, out this.currentValue);
						}
						this.currentValue = this.currentValue ?? string.Empty;
						break;
					case FallbackOption.OnNull:
						this.currentValue = this[currentLanguageId] ?? this[fallbackLanguageId] ?? this[primaryLanguageId] ?? string.Empty;
						break;
					case FallbackOption.OnEmpty:
						this.currentValue = this[currentLanguageId];
						if (string.IsNullOrEmpty(this.currentValue))
						{
							this.currentValue = this[fallbackLanguageId];
						}
						if (string.IsNullOrEmpty(this.currentValue))
						{
							this.currentValue = this[primaryLanguageId];
						}
						if (string.IsNullOrEmpty(this.currentValue))
						{
							this.currentValue = string.Empty;
						}
						break;
					default: goto case FallbackOption.OnNull;
				}
			}
			return this.currentValue;
		}

		public static implicit operator string(LocalizedString str)
		{
			return str?.Value;
		}

		/// <inheritdoc />
		public override bool Equals(object value)
		{
			var other = value as LocalizedString;
			if (other == null)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (this.keys.Length != other.keys.Length)
			{
				return false;
			}

			for (var i = 0; i < this.keys.Length; i++)
			{
				if (LanguageIdComparer.Equals(this.keys[i], other.keys[i]) == false)
				{
					return false;
				}

				if (string.Equals(this.values[i], other.values[i], StringComparison.OrdinalIgnoreCase) == false)
				{
					return false;
				}
			}

			return true;
		}

		/// <inheritdoc />
		public override int GetHashCode()
		{
			var hashCode = 0;
			foreach (var value in this.values)
			{
				hashCode += unchecked((value ?? "").GetHashCode());
			}
			return hashCode;
		}

		/// <inheritdoc />
		IEnumerable<string> IReadOnlyDictionary<string, string>.Keys => this.keys;
		/// <inheritdoc />
		IEnumerable<string> IReadOnlyDictionary<string, string>.Values => this.values;

		/// <inheritdoc />
		bool IReadOnlyDictionary<string, string>.TryGetValue(string key, out string value)
		{
			return ((IReadOnlyDictionary<string, string>)this).TryGetValue(key, out value);
		}
		/// <inheritdoc />
		bool IReadOnlyDictionary<string, string>.ContainsKey(string key)
		{
			return ((IReadOnlyDictionary<string, string>)this).ContainsKey(key);
		}

		public bool TryGetValue(string key, out string value)
		{
			var languageIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, key, LanguageIdComparer);
			if (languageIndex >= 0)
			{
				value = this.values[languageIndex];
				return value != null;
			}
			else
			{
				value = null;
				return false;
			}
		}

		/// <inheritdoc />
		IEnumerator<KeyValuePair<string, string>> IEnumerable<KeyValuePair<string, string>>.GetEnumerator()
		{
			for (var i = 0; i < this.keys.Length; i++)
			{
				yield return new KeyValuePair<string, string>(this.keys[i], this.values[i]);
			}
		}
		/// <inheritdoc />
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
		{
			for (var i = 0; i < this.keys.Length; i++)
			{
				yield return new KeyValuePair<string, string>(this.keys[i], this.values[i]);
			}
		}

		public static bool operator ==(LocalizedString value1, LocalizedString value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(LocalizedString value1, LocalizedString value2)
		{
			return Equals(value1, value2) == false;
		}

		public override string ToString()
		{
			return this.Value;
		}
	}

<#+ 
	}
#>
