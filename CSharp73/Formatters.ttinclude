<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteFormatters()
	{
#> 

	#region EndianBitConverter by Jon Skeet and Marc Gravell
	/* "Miscellaneous Utility Library" Software Licence

	Version 1.0

	Copyright (c) 2004-2008 Jon Skeet and Marc Gravell.
	All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions
	are met:

	1. Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.

	2. Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in the
	documentation and/or other materials provided with the distribution.

	3. The end-user documentation included with the redistribution, if
	any, must include the following acknowledgment:

	"This product includes software developed by Jon Skeet
	and Marc Gravell. Contact skeet@pobox.com, or see
	http://www.pobox.com/~skeet/)."

	Alternately, this acknowledgment may appear in the software itself,
	if and wherever such third-party acknowledgments normally appear.

	4. The name "Miscellaneous Utility Library" must not be used to endorse
	or promote products derived from this software without prior written
	permission. For written permission, please contact skeet@pobox.com.

	5. Products derived from this software may not be called
	"Miscellaneous Utility Library", nor may "Miscellaneous Utility Library"
	appear in their name, without prior written permission of Jon Skeet.

	THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED
	WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
	IN NO EVENT SHALL JON SKEET BE LIABLE FOR ANY DIRECT, INDIRECT,
	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	POSSIBILITY OF SUCH DAMAGE.
	*/
	public enum Endianness
	{
		LittleEndian,
		BigEndian
	}

	public abstract class EndianBitConverter
	{
		#region Endianness of this converter

		public abstract bool IsLittleEndian();

		public abstract Endianness Endianness { get; }

		#endregion

		#region Factory properties

		public static readonly LittleEndianBitConverter Little = new LittleEndianBitConverter();
		public static readonly BigEndianBitConverter Big = new BigEndianBitConverter();

		#endregion

		#region Double/primitive conversions

		public long DoubleToInt64Bits(double value)
		{
			return BitConverter.DoubleToInt64Bits(value);
		}

		public double Int64BitsToDouble(long value)
		{
			return BitConverter.Int64BitsToDouble(value);
		}

		public int SingleToInt32Bits(float value)
		{
			return new Int32SingleUnion(value).AsInt32;
		}

		public float Int32BitsToSingle(int value)
		{
			return new Int32SingleUnion(value).AsSingle;
		}

		#endregion

		#region To(PrimitiveType) conversions

		public bool ToBoolean(byte[] value, int startIndex)
		{
			CheckByteArgument(value, startIndex, 1);
			return BitConverter.ToBoolean(value, startIndex);
		}

		public char ToChar(byte[] value, int startIndex)
		{
			return unchecked((char)(CheckedFromBytes(value, startIndex, 2)));
		}

		public double ToDouble(byte[] value, int startIndex)
		{
			return Int64BitsToDouble(ToInt64(value, startIndex));
		}

		public float ToSingle(byte[] value, int startIndex)
		{
			return Int32BitsToSingle(ToInt32(value, startIndex));
		}

		public short ToInt16(byte[] value, int startIndex)
		{
			return unchecked((short)(CheckedFromBytes(value, startIndex, 2)));
		}

		public int ToInt32(byte[] value, int startIndex)
		{
			return unchecked((int)(CheckedFromBytes(value, startIndex, 4)));
		}

		public long ToInt64(byte[] value, int startIndex)
		{
			return CheckedFromBytes(value, startIndex, 8);
		}

		public ushort ToUInt16(byte[] value, int startIndex)
		{
			return unchecked((ushort)(CheckedFromBytes(value, startIndex, 2)));
		}

		public uint ToUInt32(byte[] value, int startIndex)
		{
			return unchecked((uint)(CheckedFromBytes(value, startIndex, 4)));
		}

		public ulong ToUInt64(byte[] value, int startIndex)
		{
			return unchecked((ulong)(CheckedFromBytes(value, startIndex, 8)));
		}

		private static void CheckByteArgument(byte[] value, int startIndex, int bytesRequired)
		{
			if (value == null)
			{
				throw new ArgumentNullException(nameof(value));
			}
			if (startIndex < 0 || startIndex > value.Length - bytesRequired)
			{
				throw new ArgumentOutOfRangeException(nameof(startIndex));
			}
		}

		private long CheckedFromBytes(byte[] value, int startIndex, int bytesToConvert)
		{
			CheckByteArgument(value, startIndex, bytesToConvert);
			return FromBytes(value, startIndex, bytesToConvert);
		}

		protected abstract long FromBytes(byte[] value, int startIndex, int bytesToConvert);

		#endregion

		#region ToString conversions

		public static string ToString(byte[] value)
		{
			return BitConverter.ToString(value);
		}

		public static string ToString(byte[] value, int startIndex)
		{
			return BitConverter.ToString(value, startIndex);
		}

		public static string ToString(byte[] value, int startIndex, int length)
		{
			return BitConverter.ToString(value, startIndex, length);
		}

		#endregion

		#region	Decimal conversions

		public decimal ToDecimal(byte[] value, int startIndex)
		{
			// HACK: This always assumes four parts, each in their own endianness,
			// starting with the first part at the start of the byte array.
			// On the other hand, there's no real format specified...
			var parts = new int[4];
			for (var i = 0; i < 4; i++)
			{
				parts[i] = ToInt32(value, startIndex + i * 4);
			}
			return new decimal(parts);
		}

		public byte[] GetBytes(decimal value)
		{
			var bytes = new byte[16];
			var parts = decimal.GetBits(value);
			for (var i = 0; i < 4; i++)
			{
				CopyBytesImpl(parts[i], 4, bytes, i * 4);
			}
			return bytes;
		}

		public void CopyBytes(decimal value, byte[] buffer, int index)
		{
			var parts = decimal.GetBits(value);
			for (var i = 0; i < 4; i++)
			{
				CopyBytesImpl(parts[i], 4, buffer, i * 4 + index);
			}
		}

		#endregion

		#region GetBytes conversions

		private byte[] GetBytes(long value, int bytes)
		{
			var buffer = new byte[bytes];
			CopyBytes(value, bytes, buffer, 0);
			return buffer;
		}

		public byte[] GetBytes(bool value)
		{
			return BitConverter.GetBytes(value);
		}

		public byte[] GetBytes(char value)
		{
			return GetBytes(value, 2);
		}

		public byte[] GetBytes(double value)
		{
			return GetBytes(DoubleToInt64Bits(value), 8);
		}

		public byte[] GetBytes(short value)
		{
			return GetBytes(value, 2);
		}

		public byte[] GetBytes(int value)
		{
			return GetBytes(value, 4);
		}

		public byte[] GetBytes(long value)
		{
			return GetBytes(value, 8);
		}

		public byte[] GetBytes(float value)
		{
			return GetBytes(SingleToInt32Bits(value), 4);
		}

		public byte[] GetBytes(ushort value)
		{
			return GetBytes(value, 2);
		}

		public byte[] GetBytes(uint value)
		{
			return GetBytes(value, 4);
		}

		public byte[] GetBytes(ulong value)
		{
			return GetBytes(unchecked((long)value), 8);
		}

		#endregion

		#region CopyBytes conversions

		private void CopyBytes(long value, int bytes, byte[] buffer, int index)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException(nameof(buffer), "Byte array must not be null");
			}
			if (buffer.Length < index + bytes)
			{
				throw new ArgumentOutOfRangeException(nameof(buffer), "Buffer not big enough for value");
			}
			CopyBytesImpl(value, bytes, buffer, index);
		}

		protected abstract void CopyBytesImpl(long value, int bytes, byte[] buffer, int index);

		public void CopyBytes(bool value, byte[] buffer, int index)
		{
			CopyBytes(value ? 1 : 0, 1, buffer, index);
		}

		public void CopyBytes(char value, byte[] buffer, int index)
		{
			CopyBytes(value, 2, buffer, index);
		}

		public void CopyBytes(double value, byte[] buffer, int index)
		{
			CopyBytes(DoubleToInt64Bits(value), 8, buffer, index);
		}

		public void CopyBytes(short value, byte[] buffer, int index)
		{
			CopyBytes(value, 2, buffer, index);
		}

		public void CopyBytes(int value, byte[] buffer, int index)
		{
			CopyBytes(value, 4, buffer, index);
		}

		public void CopyBytes(long value, byte[] buffer, int index)
		{
			CopyBytes(value, 8, buffer, index);
		}

		public void CopyBytes(float value, byte[] buffer, int index)
		{
			CopyBytes(SingleToInt32Bits(value), 4, buffer, index);
		}

		public void CopyBytes(ushort value, byte[] buffer, int index)
		{
			CopyBytes(value, 2, buffer, index);
		}

		public void CopyBytes(uint value, byte[] buffer, int index)
		{
			CopyBytes(value, 4, buffer, index);
		}

		public void CopyBytes(ulong value, byte[] buffer, int index)
		{
			CopyBytes(unchecked((long)value), 8, buffer, index);
		}

		#endregion

		#region Private struct used for Single/Int32 conversions

		[StructLayout(LayoutKind.Explicit)]
		private readonly struct Int32SingleUnion
		{
			[FieldOffset(0)]
			private readonly int i;

			[FieldOffset(0)]
			private readonly float f;

			internal Int32SingleUnion(int i)
			{
				this.f = 0; // Just to keep the compiler happy
				this.i = i;
			}

			internal Int32SingleUnion(float f)
			{
				this.i = 0; // Just to keep the compiler happy
				this.f = f;
			}

			internal int AsInt32 => i;

			internal float AsSingle => f;
		}

		#endregion
	}

	public sealed class BigEndianBitConverter : EndianBitConverter
	{
		public override bool IsLittleEndian()
		{
			return false;
		}

		public override Endianness Endianness => Endianness.BigEndian;

		protected override void CopyBytesImpl(long value, int bytes, byte[] buffer, int index)
		{
			var endOffset = index + bytes - 1;
			for (var i = 0; i < bytes; i++)
			{
				buffer[endOffset - i] = unchecked((byte)(value & 0xff));
				value = value >> 8;
			}
		}

		protected override long FromBytes(byte[] buffer, int startIndex, int bytesToConvert)
		{
			long ret = 0;
			for (var i = 0; i < bytesToConvert; i++)
			{
				ret = unchecked((ret << 8) | buffer[startIndex + i]);
			}
			return ret;
		}
	}

	public sealed class LittleEndianBitConverter : EndianBitConverter
	{
		public override bool IsLittleEndian()
		{
			return true;
		}

		public override Endianness Endianness => Endianness.LittleEndian;

		protected override void CopyBytesImpl(long value, int bytes, byte[] buffer, int index)
		{
			for (var i = 0; i < bytes; i++)
			{
				buffer[i + index] = unchecked((byte)(value & 0xff));
				value = value >> 8;
			}
		}

		protected override long FromBytes(byte[] buffer, int startIndex, int bytesToConvert)
		{
			long ret = 0;
			for (var i = 0; i < bytesToConvert; i++)
			{
				ret = unchecked((ret << 8) | buffer[startIndex + bytesToConvert - 1 - i]);
			}
			return ret;
		}
	}

	/* end of Jon Skeet and Marc Gravell code */
	#endregion


	[Obsolete("Left for backward compatibility. Use GameDataFormat instead.")]
	public static class Format
	{
		public static readonly GameDataFormat Json = GameDataFormat.Json;
		public static readonly GameDataFormat MessagePack = GameDataFormat.MessagePack;
	}


	public enum GameDataFormat
	{
		Json,
		MessagePack
	}


	public class GameDataLoadOptions
	{
		public GameDataFormat Format { get; set; }
		public IReadOnlyList<Stream> Patches { get; set; }
		public Encoding Encoding { get; set; }
		public bool LeaveStreamsOpen { get; set; }

		public GameDataLoadOptions()
		{
			this.Format = GameDataFormat.Json;
			this.Patches = Array.Empty<Stream>();
			this.Encoding = Encoding.UTF8;
			this.LeaveStreamsOpen = false;
		}

		/// <inheritdoc />
		public override string ToString()
		{
			return $"Format: {this.Format}, Patches: {string.Join(", ", this.Patches)}, Encoding: {this.Encoding.WebName}, Leave Open: {this.LeaveStreamsOpen}";
		}
	}


	public class GameDataObjectReader : GameDataReader
	{
		private ReaderFrame[] frames;
		private int topFrameIndex;
		private ReaderNode currentNode;

		/// <inheritdoc />
		public override ReaderNode Node => this.currentNode;
		/// <inheritdoc />
		public override int LineNumber => 0;
		/// <inheritdoc />
		public override int ColumnNumber => 0;

		public GameDataObjectReader(IReadOnlyDictionary<string, object> gameDataPatch)
		{
			this.frames = new ReaderFrame[10];
			this.topFrameIndex = -1;
			this.PushFrame(gameDataPatch);
			this.topFrameIndex = int.MinValue;
		}

		/// <inheritdoc />
		public override bool NextToken()
		{
			if (this.topFrameIndex == int.MinValue)
			{
				this.topFrameIndex = 0;
				this.currentNode = new ReaderNode(this.frames[this.topFrameIndex].ContainerType);
				return true;
			}

			while (this.topFrameIndex >= 0)
			{
				var nextToken = ReaderFrame.GetState(ref this.frames[this.topFrameIndex]);
				switch (nextToken)
				{
					case ReaderToken.Member:
						var memberName = this.frames[this.topFrameIndex].MemberName;
						this.currentNode = new ReaderNode(nextToken, memberName);
						return true;
					case ReaderToken.Value:
						this.currentNode = new ReaderNode(nextToken, this.frames[this.topFrameIndex].Current);
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						return true;
					case ReaderToken.EndOfObject:
					case ReaderToken.EndOfArray:
						this.PopFrame();
						this.currentNode = new ReaderNode(nextToken);
						return true;
					case ReaderToken.BeginObject:
						var dictionary = (IReadOnlyDictionary<string, object>)this.frames[this.topFrameIndex].Current;
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						this.PushFrame(dictionary);
						this.currentNode = new ReaderNode(nextToken);
						return true;
					case ReaderToken.BeginArray:
						var list = (IReadOnlyList<object>)this.frames[this.topFrameIndex].Current;
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						this.PushFrame(list);
						this.currentNode = new ReaderNode(nextToken);
						return true;
					case ReaderToken.Null:
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						this.currentNode = new ReaderNode(nextToken);
						return true;
				}
			}

			return false;
		}

		private void PushFrame(IReadOnlyDictionary<string, object> dictionary)
		{
			if (this.topFrameIndex == this.frames.Length)
			{
				Array.Resize(ref this.frames, (int)(this.frames.Length * 1.5));
			}

			this.frames[++this.topFrameIndex] = new ReaderFrame(dictionary);
		}
		private void PushFrame(IReadOnlyList<object> list)
		{
			if (this.topFrameIndex == this.frames.Length)
			{
				Array.Resize(ref this.frames, (int)(this.frames.Length * 1.5));
			}

			this.frames[++this.topFrameIndex] = new ReaderFrame(list);
		}
		private void PopFrame()
		{
			this.frames[this.topFrameIndex] = default;
			this.topFrameIndex--;
		}

		/// <inheritdoc />
		public override void Dispose()
		{
			Array.Clear(this.frames, 0, this.frames.Length);
			this.topFrameIndex = -1;
		}

		private struct ReaderFrame
		{
			private bool memberNameVisited;
			private int currentIndex;
			private readonly IReadOnlyList<object> list;
			private readonly IndexedDictionary<string, object> dictionary;

			public string MemberName => this.dictionary?.Keys[this.currentIndex];
			public object Current => this.list != null ? this.list[this.currentIndex] : this.dictionary?[this.dictionary.Keys[this.currentIndex]];
			public ReaderToken ContainerType => this.list != null ? ReaderToken.BeginArray : this.dictionary != null ? ReaderToken.BeginObject : ReaderToken.EndOfStream;
			private bool IsInBounds => this.currentIndex < (this.list?.Count ?? (this.dictionary?.Count ?? 0));

			public ReaderFrame(IReadOnlyList<object> list)
			{
				if (list == null) throw new ArgumentNullException(nameof(list));

				this.dictionary = default;
				this.list = list;
				this.currentIndex = 0;
				this.memberNameVisited = false;
			}
			public ReaderFrame(IReadOnlyDictionary<string, object> dictionary)
			{
				if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));

				this.dictionary = dictionary as IndexedDictionary<string, object> ?? new IndexedDictionary<string, object>(dictionary);
				this.list = default;
				this.currentIndex = 0;
				this.memberNameVisited = false;
			}

			public static void Next(ref ReaderFrame readerFrame)
			{
				readerFrame.currentIndex++;
				readerFrame.memberNameVisited = false;
			}
			public static ReaderToken GetState(ref ReaderFrame readerFrame)
			{
				var isObjectIteration = readerFrame.dictionary != null;
				if (!readerFrame.IsInBounds)
				{
					return isObjectIteration ? ReaderToken.EndOfObject : ReaderToken.EndOfArray;
				}

				if (isObjectIteration && !readerFrame.memberNameVisited)
				{
					readerFrame.memberNameVisited = true;
					return ReaderToken.Member;
				}

				readerFrame.memberNameVisited = false;
				var currentObject = readerFrame.Current;
				if (currentObject is IReadOnlyDictionary<string, object>)
				{
					return ReaderToken.BeginObject;
				}
				else if (currentObject is IReadOnlyList<object>)
				{
					return ReaderToken.BeginArray;
				}
				else
				{
					return currentObject == null ? ReaderToken.Null : ReaderToken.Value;
				}
			}
		}
	}


	public abstract partial class GameDataReader : IDisposable
	{
		public static readonly string[] DateTimeFormats = new string[] { "yyyy-MM-ddTHH:mm:ss.fffZ", "o" };

		public abstract ReaderNode Node { get; }

		public abstract int LineNumber { get; }
		public abstract int ColumnNumber { get; }

		public abstract bool NextToken();

		public bool IsEndOfStream()
		{
			return this.Node.Token == ReaderToken.EndOfStream;
		}
		public bool IsNull()
		{
			return this.Node.Token == ReaderToken.Null;
		}
		public void ThrowIfNotValue()
		{
			if (this.Node.Token != ReaderToken.Value)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.Value);
			}
		}
		public void ThrowIfNull(string expected, string propertyName, string schemaName)
		{
			if (this.Node.Token == ReaderToken.Null)
			{
				throw ReaderException.UnexpectedNullValue(expected, propertyName, schemaName, this);
			}
		}

		public object ReadAny(bool nextToken = true)
		{
			// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
			switch(this.Node.Token)
			{
				case ReaderToken.BeginArray: return this.ReadArray(nextToken);
				case ReaderToken.BeginObject: return this.ReadObject(nextToken);
				case ReaderToken.Null: if (nextToken) this.NextToken(); return null;
				case ReaderToken.Value: var value = this.Node.AsObject; if (nextToken) this.NextToken(); return value;
				default: throw ReaderException.UnexpectedToken(this, ReaderToken.BeginArray, ReaderToken.BeginObject, ReaderToken.Null, ReaderToken.Value);
			}
		}
		public List<object> ReadArray(bool nextToken = true)
		{
			var list = new List<object>();
			this.ReadArrayBegin();
			while(this.Node.Token != ReaderToken.EndOfArray)
			{
				var value = this.ReadAny();
				list.Add(value);
			}
			this.ReadArrayEnd( nextToken);
			return list;
		}
		public IndexedDictionary<string, object> ReadObject(bool nextToken = true)
		{
			var dictionary = new IndexedDictionary<string, object>();
			this.ReadObjectBegin();
			while(this.Node.Token != ReaderToken.EndOfObject)
			{
				var key = this.ReadMember();
				var value = this.ReadAny();
				dictionary[key] = value;
			}
			this.ReadObjectEnd(nextToken);
			return dictionary;
		}
		public void SkipAny(bool nextToken = true)
		{
			// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
			switch(this.Node.Token)
			{
				case ReaderToken.BeginArray: this.SkipArray(nextToken); break;
				case ReaderToken.BeginObject: this.SkipObject(nextToken); break;
				case ReaderToken.Member: if (nextToken) this.NextToken(); break;
				case ReaderToken.Null: if (nextToken) this.NextToken(); break;
				case ReaderToken.Value: if (nextToken) this.NextToken(); break;
				default: throw ReaderException.UnexpectedToken(this, ReaderToken.BeginArray, ReaderToken.BeginObject, ReaderToken.Null, ReaderToken.Value);
			}
		}
		public void SkipArray(bool nextToken = true)
		{
			this.ReadArrayBegin();
			while(this.Node.Token != ReaderToken.EndOfArray)
			{
				this.SkipAny();
			}
			this.ReadArrayEnd( nextToken);
		}
		public void SkipObject(bool nextToken = true)
		{
			this.ReadObjectBegin();
			while(this.Node.Token != ReaderToken.EndOfObject)
			{
				this.SkipAny();
				this.SkipAny();
			}
			this.ReadObjectEnd(nextToken);
		}

		public void ReadArrayBegin(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.BeginArray)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.BeginArray);
			}
			if (this.IsEndOfStream())
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfArray);
			}

			if (nextToken)
				this.NextToken();
		}
		public void ReadArrayEnd(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.EndOfArray)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfArray);
			}

			if (!this.IsEndOfStream() && nextToken)
			{
				this.NextToken();
			}
		}
		public void ReadObjectBegin(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.BeginObject)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.BeginObject);
			}

			if (this.IsEndOfStream())
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfObject);
			}

			if (nextToken)
			{
				this.NextToken();
			}
		}
		public void ReadObjectEnd(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.EndOfObject)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfObject);
			}

			if (!this.IsEndOfStream() && nextToken)
			{
				this.NextToken();
			}
		}
		public string ReadMember(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.Member && this.Node.Token != ReaderToken.Value)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.Member, ReaderToken.Value);
			}

			var memberName = this.Node.AsString;

			if (!this.IsEndOfStream() && nextToken)
			{
				this.NextToken();
			}

			return memberName;
		}

		public string DebugPrintTokens()
		{
			var output = new StringBuilder();
			var stack = new Stack<ReaderToken>();
			stack.Push(ReaderToken.None);
			while (this.NextToken())
			{
				var strValue = Convert.ToString(this.Node.Token, CultureInfo.InvariantCulture) +
					(this.Node.HasValue ? "[" + this.Node.AsString + "]" : "");

				if (stack.Peek() != ReaderToken.Member)
				{
					var endingTokenIndent = this.Node.Token == ReaderToken.EndOfObject || this.Node.Token == ReaderToken.EndOfArray ? -1 : 0;
					output.Append(Environment.NewLine);
					for (var i = 0; i < System.Linq.Enumerable.Count(stack, t => t != ReaderToken.Member && t != ReaderToken.None) + endingTokenIndent; i++)
					{
						output.Append("\t");
					}
				}
				else output.Append(" ");

				output.Append(strValue);

				if (this.Node.Token == ReaderToken.EndOfObject || this.Node.Token == ReaderToken.EndOfArray || stack.Peek() == ReaderToken.Member)
				{
					stack.Pop();
				}
				if (this.Node.Token == ReaderToken.BeginObject || this.Node.Token == ReaderToken.BeginArray || this.Node.Token == ReaderToken.Member)
				{
					stack.Push(this.Node.Token);
				}

			}

			return output.ToString();
		}

		/// <inheritdoc />
		public abstract void Dispose();

		public override string ToString()
		{
			return this.Node.ToString();
		}

	}


	[Serializable, DebuggerDisplay("IndexedDictionary, Count: {" + nameof(Count) + "}")]
	public sealed class IndexedDictionary<KeyT, ValueT> : IDictionary<KeyT, ValueT>, IReadOnlyDictionary<KeyT, ValueT>, IDictionary
	{
		public struct Enumerator : IEnumerator<KeyValuePair<KeyT, ValueT>>, IDictionaryEnumerator
		{
			private List<KeyT>.Enumerator innerEnumerator;
			private readonly IndexedDictionary<KeyT, ValueT> dictionary;

			public Enumerator(IndexedDictionary<KeyT, ValueT> dictionary)
			{
				this.dictionary = dictionary;
				this.innerEnumerator = dictionary.keys.GetEnumerator();
				this.Current = new KeyValuePair<KeyT, ValueT>();
			}

			public KeyValuePair<KeyT, ValueT> Current { get; private set; }
			object IEnumerator.Current => this.Current;
			public object Key => this.Current.Key;
			public object Value => this.Current.Value;
			public DictionaryEntry Entry => ToEntry(this.Current);

			public bool MoveNext()
			{
				if (!this.innerEnumerator.MoveNext()) return false;

				var key = this.innerEnumerator.Current;

				Debug.Assert(!ReferenceEquals(key, null), "key is null");

				this.Current = new KeyValuePair<KeyT, ValueT>(key, this.dictionary.dictionary[key]);
				return true;
			}
			public void Reset()
			{
				this.innerEnumerator = this.dictionary.keys.GetEnumerator();
			}
			public void Dispose()
			{
				this.innerEnumerator.Dispose();
			}
		}

		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] private readonly Dictionary<KeyT, ValueT> dictionary;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly List<KeyT> keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never), NonSerialized] private ReadOnlyCollection<KeyT> keysReadOnly;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)] public ReadOnlyCollection<KeyT> Keys => this.keysReadOnly ?? (this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys));
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] public Dictionary<KeyT, ValueT>.ValueCollection Values => this.dictionary.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool ICollection<KeyValuePair<KeyT, ValueT>>.IsReadOnly => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection<KeyT> IDictionary<KeyT, ValueT>.Keys => this.Keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] IEnumerable<ValueT> IReadOnlyDictionary<KeyT, ValueT>.Values => this.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] IEnumerable<KeyT> IReadOnlyDictionary<KeyT, ValueT>.Keys => this.Keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection<ValueT> IDictionary<KeyT, ValueT>.Values => this.dictionary.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection IDictionary.Values => this.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection IDictionary.Keys => this.Keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool IDictionary.IsReadOnly => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool IDictionary.IsFixedSize => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] object ICollection.SyncRoot => this.dictionary;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool ICollection.IsSynchronized => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		object IDictionary.this[object key]
		{
			get => this[CastKey(key)];
			set => this[CastKey(key)] = CastValue(value);
		}

		public int Count => this.dictionary.Count;

		public ValueT this[KeyT key]
		{
			get => this.dictionary[key];
			set
			{
				if (this.dictionary.ContainsKey(key) == false) this.keys.Add(key);
				this.dictionary[key] = value;
			}
		}

		public IndexedDictionary()
		{
			this.dictionary = new Dictionary<KeyT, ValueT>();
			this.keys = new List<KeyT>();
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}
		public IndexedDictionary(int count)
		{
			if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));

			if (count == 0) count = 30;

			this.dictionary = new Dictionary<KeyT, ValueT>(count);
			this.keys = new List<KeyT>(count);
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}
		public IndexedDictionary(IDictionary<KeyT, ValueT> dictionary)
		{
			if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));

			this.dictionary = new Dictionary<KeyT, ValueT>(dictionary);
			this.keys = new List<KeyT>(dictionary.Keys);
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}
		public IndexedDictionary(IEnumerable<KeyValuePair<KeyT, ValueT>> pairs)
		{
			if (pairs == null) throw new ArgumentNullException(nameof(pairs));

			this.dictionary = new Dictionary<KeyT, ValueT>();
			this.keys = new List<KeyT>();
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);

			foreach (var pair in pairs)
			{
				this.Add(pair.Key, pair.Value);
			}
		}
		public IndexedDictionary(IDictionary<KeyT, ValueT> dictionary, ICollection<KeyT> keys)
		{
			if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));
			if (keys == null) throw new ArgumentNullException(nameof(keys));

			this.dictionary = new Dictionary<KeyT, ValueT>(dictionary);
			this.keys = new List<KeyT>(keys);
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}

		public void Add(KeyT key, ValueT value)
		{
			this.dictionary.Add(key, value);
			this.keys.Add(key);
		}
		public void Add(IndexedDictionary<KeyT, ValueT> other)
		{
			if (other == null) throw new ArgumentNullException(nameof(other));

			if (this.Count == 0)
			{
				this.keys.AddRange(other.keys);
				foreach (var kv in other.dictionary)
				{
					this.dictionary.Add(kv.Key, kv.Value);
				}
			}
			else
			{
				foreach (var kv in other.dictionary)
				{
					this.dictionary.Add(kv.Key, kv.Value);
					this.keys.Add(kv.Key);
				}
			}
		}

		public void Insert(int index, KeyT key, ValueT value)
		{
			// Dictionary operation first, so exception thrown if key already exists.
			this.dictionary.Add(key, value);
			this.keys.Insert(index, key);
		}
		public bool ContainsKey(KeyT key)
		{
			return this.dictionary.ContainsKey(key);
		}
		public bool ContainsKey(KeyT key, IEqualityComparer<KeyT> keyComparer)
		{
			if (keyComparer == null) throw new ArgumentNullException(nameof(keyComparer));

			foreach (var k in this.keys)
			{
				if (keyComparer.Equals(k, key))
				{
					return true;
				}
			}

			return false;
		}
		public bool ContainsValue(ValueT value)
		{
			foreach (var kv in this.dictionary)
			{
				if (Equals(value, kv.Value))
				{
					return true;
				}
			}

			return false;
		}
		public bool ContainsValue(ValueT value, IEqualityComparer comparer)
		{
			if (comparer == null) throw new ArgumentNullException(nameof(comparer));

			foreach (var kv in this.dictionary)
			{
				if (comparer.Equals(value, kv.Value))
				{
					return true;
				}
			}

			return false;
		}
		public bool Remove(KeyT key)
		{
			var wasInDictionary = this.dictionary.Remove(key);
			this.keys.Remove(key);

			return wasInDictionary;
		}

		public bool TryGetValue(KeyT key, out ValueT value)
		{
			return this.dictionary.TryGetValue(key, out value);
		}

		public int IndexOf(KeyT key)
		{
			return this.keys.IndexOf(key);
		}
		public void RemoveAt(int index)
		{
			if (index >= this.Count || index < 0) throw new ArgumentOutOfRangeException(nameof(index));

			var key = this.keys[index];
			this.dictionary.Remove(key);
			this.keys.RemoveAt(index);
		}
		public void SortKeys(IComparer<KeyT> comparer)
		{
			if (comparer == null) throw new ArgumentNullException(nameof(comparer));

			this.keys.Sort(comparer);
		}

		public void Clear()
		{
			this.dictionary.Clear();
			this.keys.Clear();
		}

		bool IDictionary.Contains(object key)
		{
			return this.ContainsKey(CastKey(key));
		}
		void IDictionary.Add(object key, object value)
		{
			this.Add(CastKey(key), CastValue(value));
		}
		void IDictionary.Remove(object key)
		{
			this.Remove(CastKey(key));
		}
		void ICollection.CopyTo(Array array, int index)
		{
			foreach (var pair in this)
			{
				array.SetValue(ToEntry(pair), index++);
			}
		}

		void ICollection<KeyValuePair<KeyT, ValueT>>.Add(KeyValuePair<KeyT, ValueT> item)
		{
			this.Add(item.Key, item.Value);
		}
		bool ICollection<KeyValuePair<KeyT, ValueT>>.Contains(KeyValuePair<KeyT, ValueT> item)
		{
			return this.dictionary.TryGetValue(item.Key, out var value) && Equals(value, item.Value);
		}
		void ICollection<KeyValuePair<KeyT, ValueT>>.CopyTo(KeyValuePair<KeyT, ValueT>[] array, int arrayIndex)
		{
			foreach (var pair in this)
			{
				array[arrayIndex++] = pair;
			}
		}
		bool ICollection<KeyValuePair<KeyT, ValueT>>.Remove(KeyValuePair<KeyT, ValueT> item)
		{
			if (((ICollection<KeyValuePair<KeyT, ValueT>>)this).Contains(item) == false)
			{
				return false;
			}

			return this.Remove(item.Key);
		}
		IEnumerator<KeyValuePair<KeyT, ValueT>> IEnumerable<KeyValuePair<KeyT, ValueT>>.GetEnumerator()
		{
			return this.GetEnumerator();
		}

		IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return this.GetEnumerator();
		}
		IEnumerator IEnumerable.GetEnumerator()
		{
			return this.GetEnumerator();
		}
		public Enumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		private static ValueT CastValue(object value)
		{
			if (value == null) return default;

			return (ValueT)value;
		}
		private static KeyT CastKey(object key)
		{
			if (key == null) throw new ArgumentNullException(nameof(key));

			return (KeyT)key;
		}
		private static DictionaryEntry ToEntry(KeyValuePair<KeyT, ValueT> value)
		{
			return new DictionaryEntry(value.Key, value.Value);
		}

		public override string ToString()
		{
			return "Count: " + Convert.ToString(this.Count, CultureInfo.InvariantCulture);
		}
	}


	public class IndexedString : IComparable<IndexedString>
	{
		public readonly string Value;
		public readonly ulong[] Octets;

		public IndexedString(string value)
		{
			this.Value = value;
			this.Octets = new ulong[8];
			for (var i = 0; i < 8; i++)
			{
				this.Octets[i] = GetUInt64(value, 8 * i);
			}
		}

		public int CompareTo(IndexedString otherString)
		{
			if (this.Value.Length != otherString.Value.Length)
			{
				return this.Value.Length.CompareTo(otherString.Value.Length);
			}

			for (var i = 0; i < this.Octets.Length; i++)
			{
				var comp = this.Octets[i].CompareTo(otherString.Octets[i]);
				if (comp != 0)
				{
					return comp;
				}
			}

			return 0;
		}

		private static ulong GetUInt64(string chars, int offset)
		{
			if (offset >= chars.Length)
			{
				return 0;
			}

			var result = 0L;
			var bytesToConvert = Math.Min(chars.Length - offset, 8);
			for (var i = 0; i < bytesToConvert; i++)
			{
				result = unchecked((result << 8) | chars[offset + bytesToConvert - 1 - i]);
			}

			return unchecked((ulong)result);
		}
	}


	public interface IStrongBox
	{
		bool AsBoolean { get; }
		byte AsByte { get; }
		short AsInt16 { get; }
		int AsInt32 { get; }
		long AsInt64 { get; }
		sbyte AsSByte { get; }
		ushort AsUInt16 { get; }
		uint AsUInt32 { get; }
		ulong AsUInt64 { get; }
		float AsSingle { get; }
		double AsDouble { get; }
		decimal AsDecimal { get; }
		DateTimeOffset AsDateTimeOffset { get; }
		DateTime AsDateTime { get; }
		TimeSpan AsTimeSpan { get; }
		Type ValueType { get; }
		object AsObject { get; }

		void Store<T>(T value);
	}


	public sealed class JsonGameDataReader : GameDataReader
	{
		private const int DEFAULT_BUFFER_SIZE = ushort.MaxValue / 2;
		private const int CHAR_SIZE = 2;

		const int LEXER_STATE_COMPLETE = -1;
		const int LEXER_STATE_START = 0;
		const int LEXER_STATE_LEXEME = 1;
		const int LEXER_STATE_QUOTED = 2;
		const int LEXER_STATE_QUOTED_ESCAPE = 3;
		const int LEXER_STATE_COMMENT_BEGINNING = 4;
		const int LEXER_STATE_COMMENT_SINGLE_LINE = 5;
		const int LEXER_STATE_COMMENT_MULTILINE = 6;
		const int LEXER_STATE_COMMENT_MULTILINE_ENDING = 7;

		private const int NUMBER_FLOAT = 2;
		private const int NUMBER_FLOAT_WITH_EXP = 3;
		private const int NUMBER_INTEGER = 0;
		private const int NUMBER_NEGATIVE_INTEGER = 1;
		private const int NUMBER_NOT = -1;

		private static readonly int Int32MaxLength = int.MaxValue.ToString().Length;
		private static readonly int Int64MaxLength = long.MaxValue.ToString().Length;

		private readonly ArraySegment<char> lexemeTrue = new ArraySegment<char>(JsonNotation.True.ToCharArray(), 0, 4);
		private readonly ArraySegment<char> lexemeFalse = new ArraySegment<char>(JsonNotation.False.ToCharArray(), 0, 5);
		private readonly ArraySegment<char> lexemeNull = new ArraySegment<char>(JsonNotation.Null.ToCharArray(), 0, 4);

		private readonly bool leaveOpen;
		private readonly TextReader textReader;
		private readonly Stack<ReaderToken> structure;

		// tokenizing
		private readonly char[] buffer;
		private int bufferOffset;
		private int bufferAvailable;
		private int lineNum = 1;
		private int colNum = 1;

		// parsing
		private ReaderNode node;
		private ArraySegment<char> rawJson;

		private StrongBox<bool> trueBox;
		private StrongBox<bool> falseBox;
		private StrongBox<int> intBox;
		private StrongBox<DateTime> dateBox;
		private JsonValueBox jsonValueBox;

		public override ReaderNode Node { get { if (this.node.Token == ReaderToken.None) this.NextToken(); return this.node; } }

		// statistics
		public override int LineNumber => this.lineNum;
		public override int ColumnNumber => this.colNum;

		public JsonGameDataReader(Stream stream, Encoding encoding, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE)
			: this(new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: true, leaveOpen: leaveOpen, bufferSize: bufferSize), leaveOpen, bufferSize)
		{

		}
		public JsonGameDataReader(TextReader textReader, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE)
		{
			if (textReader == null) throw new ArgumentNullException(nameof(textReader));
			if (bufferSize <= 0) throw new ArgumentOutOfRangeException(nameof(bufferSize));

			this.structure = new Stack<ReaderToken>();
			this.buffer = new char[bufferSize];
			this.textReader = textReader;
			this.leaveOpen = leaveOpen;
		}

		public override bool NextToken()
		{
			this.rawJson = default;
			this.node = default;

			var fragments = default(ArraySegment<char>[]);
			var state = LEXER_STATE_COMPLETE;
			var lexemeSize = 0;
			var memberOrValueToken = ReaderToken.Value;

			if (this.structure.Count > 0)
			{
				// ReSharper disable once SwitchStatementMissingSomeCases
				switch (this.structure.Peek())
				{
					case ReaderToken.Member:
						this.structure.Pop();
						break;
					case ReaderToken.BeginObject:
						this.structure.Push(memberOrValueToken = ReaderToken.Member);
						break;
				}
			}

			var lexeme = this.NextLexeme(ref state);
			if (lexeme.Count == 0)
			{
				this.node = new ReaderNode(ReaderToken.EndOfStream);
				return false;
			}
			if (state != LEXER_STATE_COMPLETE)
			{
				var firstFragment = Copy(ref lexeme);
				var secondFragment = this.NextLexeme(ref state);

				if (state == LEXER_STATE_COMPLETE)
				{
					if (secondFragment.Count == 0)
					{
						lexeme = firstFragment;
						lexemeSize = lexeme.Count;
					}
					else
					{
						fragments = new[] { firstFragment, secondFragment };
						lexemeSize = firstFragment.Count + secondFragment.Count;
					}
				}
				else
				{
					var fragmentIndex = 0;
					fragments = new ArraySegment<char>[8];
					fragments[fragmentIndex++] = firstFragment;
					fragments[fragmentIndex++] = Copy(ref secondFragment);
					lexemeSize = firstFragment.Count + secondFragment.Count;

					do
					{
						lexeme = this.NextLexeme(ref state);

						if (lexeme.Count == 0)
						{
							break;
						}
						if (fragmentIndex == fragments.Length)
						{
							Array.Resize(ref fragments, (int)(fragments.Length * 1.5));
						}

						fragments[fragmentIndex++] = Copy(ref lexeme);
						lexemeSize += lexeme.Count;

					} while (state != LEXER_STATE_COMPLETE);
				}
			}
			else
			{
				lexemeSize = lexeme.Count;
			}

			if (lexemeSize == 1)
			{
				this.rawJson = fragments != null ? fragments[0] : lexeme;
				System.Diagnostics.Debug.Assert(this.rawJson.Array != null, "this.rawJson.Array");
				switch (this.rawJson.Array[this.rawJson.Offset])
				{
					case JsonNotation.Const0: this.node = new ReaderNode(memberOrValueToken, this.Box(0)); return true;
					case JsonNotation.Const1: this.node = new ReaderNode(memberOrValueToken, this.Box(1)); return true;
					case JsonNotation.Const2: this.node = new ReaderNode(memberOrValueToken, this.Box(2)); return true;
					case JsonNotation.Const3: this.node = new ReaderNode(memberOrValueToken, this.Box(3)); return true;
					case JsonNotation.Const4: this.node = new ReaderNode(memberOrValueToken, this.Box(4)); return true;
					case JsonNotation.Const5: this.node = new ReaderNode(memberOrValueToken, this.Box(5)); return true;
					case JsonNotation.Const6: this.node = new ReaderNode(memberOrValueToken, this.Box(6)); return true;
					case JsonNotation.Const7: this.node = new ReaderNode(memberOrValueToken, this.Box(7)); return true;
					case JsonNotation.Const8: this.node = new ReaderNode(memberOrValueToken, this.Box(8)); return true;
					case JsonNotation.Const9: this.node = new ReaderNode(memberOrValueToken, this.Box(9)); return true;
					case JsonNotation.BeginArray:
						this.structure.Push(ReaderToken.BeginArray);
						this.node = new ReaderNode(ReaderToken.BeginArray);
						return true;
					case JsonNotation.BeginObject:
						this.structure.Push(ReaderToken.BeginObject);
						this.node = new ReaderNode(ReaderToken.BeginObject);
						return true;
					case JsonNotation.EndArray:
						this.structure.Pop();
						this.node = new ReaderNode(ReaderToken.EndOfArray);
						return true;
					case JsonNotation.EndObject:
						this.structure.Pop();
						this.structure.Pop();
						this.node = new ReaderNode(ReaderToken.EndOfObject);
						return true;
					default: throw ReaderException.UnknownNotation(this, new string(this.rawJson.Array, this.rawJson.Offset, this.rawJson.Count));
				}
			}
			if (lexemeSize == 4)
			{
				if (Match(ref lexeme, fragments, 0, this.lexemeTrue))
				{
					this.rawJson = this.lexemeTrue;
					this.node = new ReaderNode(memberOrValueToken, this.Box(true));
					return true;
				}
				if (Match(ref lexeme, fragments, 0, this.lexemeNull))
				{
					this.rawJson = this.lexemeNull;
					this.node = new ReaderNode(ReaderToken.Null);
					return true;
				}
			}
			if (lexemeSize == 5 && Match(ref lexeme, fragments, 0, this.lexemeFalse))
			{
				this.rawJson = this.lexemeFalse;
				this.node = new ReaderNode(memberOrValueToken, this.Box(false));
				return true;
			}

			// combine fragments into one lexeme
			if (fragments != null)
			{
				var combined = new char[lexemeSize];
				var offset = 0;
				foreach (var fragment in fragments)
				{
					if (fragment.Array == null) break;
					Buffer.BlockCopy(fragment.Array, fragment.Offset * CHAR_SIZE, combined, offset * CHAR_SIZE, fragment.Count * CHAR_SIZE);
					offset += fragment.Count;
				}
				lexeme = new ArraySegment<char>(combined, 0, offset);
				//fragments = null;
			}

			this.rawJson = lexeme;
			System.Diagnostics.Debug.Assert(lexeme.Array != null, "lexeme.Array");
			if (lexeme.Array[lexeme.Offset] == JsonNotation.Quote) // start with quote
			{
				if (lexeme.Array[lexeme.Offset + lexeme.Count - 1] != JsonNotation.Quote) // not ending with quote
					throw ReaderException.UnterminatedStringLiteral(this);

				if (lexemeSize == 2)
				{
					this.node = new ReaderNode(memberOrValueToken, string.Empty);
					return true;
				}

				this.node = new ReaderNode(memberOrValueToken, this.Box(ref lexeme));
				return true;
			}

			switch (GetNumberType(ref lexeme))
			{
				case NUMBER_INTEGER:
					var integerType = lexeme.Count < Int32MaxLength
						? typeof(int)
						: lexeme.Count < Int64MaxLength ? typeof(long) : typeof(ulong);
					this.node = new ReaderNode(memberOrValueToken, this.Box(ref lexeme, integerType));
					return true;
				case NUMBER_NEGATIVE_INTEGER:
					var signedIntegerType = lexeme.Count < Int32MaxLength + 1 ? typeof(int) : typeof(long);
					this.node = new ReaderNode(memberOrValueToken, this.Box(ref lexeme, signedIntegerType));
					return true;
				case NUMBER_FLOAT:
				case NUMBER_FLOAT_WITH_EXP:
					this.node = new ReaderNode(memberOrValueToken, this.Box(ref lexeme, typeof(double)));
					return true;
				default:
					System.Diagnostics.Debug.Assert(this.rawJson.Array != null, "rawJsonArray");
					throw ReaderException.UnknownNotation(this, new string(this.rawJson.Array, this.rawJson.Offset, this.rawJson.Count));
			}
		}

		private object Box(ref ArraySegment<char> lexeme, Type type = default)
		{
			var jsonValueBox = this.jsonValueBox ?? (this.jsonValueBox = new JsonValueBox());
			jsonValueBox.Store(lexeme, type ?? typeof(string));
			return jsonValueBox;
		}
		private object Box(int value)
		{
			var intBox = this.intBox ?? (this.intBox = new StrongBox<int>(CultureInfo.InvariantCulture));
			intBox.Store(value);
			return intBox;
		}
		private object Box(DateTime value)
		{
			var dateBox = this.dateBox ?? (this.dateBox = new StrongBox<DateTime>(CultureInfo.InvariantCulture));
			dateBox.Store(value);
			return dateBox;
		}
		private object Box(bool value)
		{
			if (value)
			{
				return this.trueBox ?? (this.trueBox = new StrongBox<bool>(true, CultureInfo.InvariantCulture));
			}
			return this.falseBox ?? (this.falseBox = new StrongBox<bool>(false, CultureInfo.InvariantCulture));
		}

		private static bool Match(ref ArraySegment<char> lexeme, ArraySegment<char>[] fragments, int offset, ArraySegment<char> matchTo)
		{
			var lexemeArray = lexeme.Array;
			System.Diagnostics.Debug.Assert(lexemeArray != null, "lexemeArray != null");

			var matchToArray = matchTo.Array;
			System.Diagnostics.Debug.Assert(matchToArray != null, "matchToArray != null");

			var count = matchTo.Count;
			if (fragments == null)
			{
				for (var i = 0; i < count; i++)
				{
					if (lexemeArray[lexeme.Offset + i] != matchToArray[matchTo.Offset + i])
						return false;
				}

				return true;
			}
			var mo = 0;
			foreach (var fg in fragments)
			{
				if (fg.Array == null) break;

				for (var i = 0; i < fg.Count; i++)
				{
					if (fg.Array[fg.Offset + i] != matchToArray[mo])
						return false;

					mo++;
				}
			}

			return true;
		}
		private static int GetNumberType(ref ArraySegment<char> lexeme)
		{
			const int INT_PART = 0;
			const int FRAC_PART = 1;
			const int EXP_PART = 2;
			const char POINT = '.';
			const char EXPONENT = 'E';
			const char EXPONENT_ALT = 'e';
			const char PLUS = '+';
			const char MINUS = '-';
			const char DIGIT_START = '0';
			const char DIGIT_END = '9';

			var isNegative = false;
			var buffer = lexeme.Array;
			var offset = lexeme.Offset;
			var count = lexeme.Offset + lexeme.Count;

			System.Diagnostics.Debug.Assert(buffer != null, "buffer != null");

			var part = INT_PART;

			for (var i = offset; i < count; i++)
			{
				var character = buffer[i];

				switch (part)
				{
					case INT_PART:
						switch (character)
						{
							case MINUS:
								if (i != offset)
								{
									return NUMBER_NOT;
								}
								isNegative = true;
								break;
							case PLUS:
								if (i != offset)
								{
									return NUMBER_NOT;
								}
								break;
							case POINT:
								if (i == offset)
								{
									return NUMBER_NOT; // decimal point as first character
								}
								part = FRAC_PART;
								break;
							default:
								if (character == EXPONENT || character == EXPONENT_ALT)
								{
									if (i == offset)
									{
										return NUMBER_NOT; // exponent at first character
									}
									part = EXP_PART;
								}
								else if (character < DIGIT_START && character > DIGIT_END)
								{
									return NUMBER_NOT; // non digit character in integer part
								}
								break;
						}
						break;
					case FRAC_PART:
						if (character == EXPONENT || character == EXPONENT_ALT)
						{
							if (i == offset)
							{
								return NUMBER_NOT; // exponent at first character
							}
							part = EXP_PART;
						}
						else if (character < DIGIT_START && character > DIGIT_END)
						{
							return NUMBER_NOT; // non digit character in fraction part
						}
						break;
					case EXP_PART:
						if (character == PLUS || character == MINUS)
						{
							if (buffer[i - 1] != EXPONENT && buffer[i - 1] != EXPONENT_ALT)
							{
								return NUMBER_NOT; // sign not at start of exponent part
							}
						}
						else if (character < DIGIT_START && character > DIGIT_END)
						{
							return NUMBER_NOT; // non digit character in integer part
						}
						break;
				}
			}

			switch (part)
			{
				case INT_PART: return isNegative ? NUMBER_NEGATIVE_INTEGER : NUMBER_INTEGER;
				case FRAC_PART: return NUMBER_FLOAT;
				case EXP_PART: return NUMBER_FLOAT_WITH_EXP;
				default: return NUMBER_NOT;
			}
		}
		private static ArraySegment<char> Copy(ref ArraySegment<char> lexeme)
		{
			var lexemeArray = lexeme.Array;

			var newLexemeArray = new char[lexeme.Count];
			var newLexeme = new ArraySegment<char>(newLexemeArray, 0, lexeme.Count);

			System.Diagnostics.Debug.Assert(lexemeArray != null, "lexemeArray != null");

			Buffer.BlockCopy(lexemeArray, lexeme.Offset * CHAR_SIZE, newLexemeArray, 0, lexeme.Count * CHAR_SIZE);
			return newLexeme;
		}
		private static bool IsWhiteSpaceLatin(char character)
		{
			return character == ' ' || character >= '\t' && character <= '\r' || (character == ' ' || character == '\x0085');
		}
		private ArraySegment<char> NextLexeme(ref int state)
		{
			this.ResetBufferIfNeeded();

			var buffer = this.buffer;
			var lexemeStartIndex = this.bufferOffset;
			var lexemeLength = 0;

			start:
			if (this.bufferAvailable == 0 && this.ReadToBuffer() == 0)
			{
				state = LEXER_STATE_COMPLETE;
				return new ArraySegment<char>(this.buffer, lexemeStartIndex, lexemeLength);
			}

			if (state == LEXER_STATE_COMPLETE)
				state = LEXER_STATE_START;

			var bufferEnd = this.bufferOffset + this.bufferAvailable;
			for (var i = this.bufferOffset; i < bufferEnd; i++)
			{
				this.colNum++;
				switch (state)
				{
					case LEXER_STATE_START:
						switch (buffer[i])
						{
							case JsonNotation.Newline: this.lineNum++; this.colNum = 1; goto case JsonNotation.Space;
							case JsonNotation.Space:
							case JsonNotation.Return:
							case JsonNotation.Tab:
							case JsonNotation.IdentifierSeparator:
								continue; // insignificant whitespaces
							case JsonNotation.ValueSeparator:
								if (this.structure.Peek() == ReaderToken.BeginObject) throw ReaderException.ReadingBrokenDocument(this, "A value is expected");

								continue;
							case JsonNotation.Comment:
								state = LEXER_STATE_COMMENT_BEGINNING;
								continue;
							case JsonNotation.EndArray:
							case JsonNotation.EndObject:
							case JsonNotation.BeginObject:
							case JsonNotation.BeginArray:
								state = LEXER_STATE_COMPLETE;
								this.bufferOffset = i + 1;
								this.bufferAvailable = bufferEnd - i - 1;
								return new ArraySegment<char>(buffer, i, 1);
							case JsonNotation.Quote:
								lexemeStartIndex = i;
								state = LEXER_STATE_QUOTED;
								continue;
							default:
								if (IsWhiteSpaceLatin(buffer[i]))
								{
									goto case JsonNotation.Space;
								}
								lexemeStartIndex = i;
								state = LEXER_STATE_LEXEME;
								continue;
						}
					case LEXER_STATE_LEXEME:
						switch (buffer[i])
						{
							// lexeme terminators
							case JsonNotation.Space:
							case JsonNotation.Newline:
							case JsonNotation.Return:
							case JsonNotation.Tab:
							case JsonNotation.IdentifierSeparator:
							case JsonNotation.ValueSeparator:
							case JsonNotation.EndArray:
							case JsonNotation.EndObject:
							case JsonNotation.BeginObject:
							case JsonNotation.BeginArray:
								state = LEXER_STATE_COMPLETE;
								this.bufferOffset = i;
								this.bufferAvailable = bufferEnd - i;
								return new ArraySegment<char>(buffer, lexemeStartIndex, i - lexemeStartIndex);
							default:
								if (IsWhiteSpaceLatin(buffer[i]))
								{
									goto case JsonNotation.Space;
								}
								continue;
						}
					case LEXER_STATE_QUOTED:
					case LEXER_STATE_QUOTED_ESCAPE:
						switch (buffer[i])
						{
							case JsonNotation.Newline:
							case JsonNotation.Return:
								throw ReaderException.UnterminatedStringLiteral(this);
							case JsonNotation.Quote:
								if (state == LEXER_STATE_QUOTED_ESCAPE)
								{
									state = LEXER_STATE_QUOTED;
									continue;
								}

								state = LEXER_STATE_COMPLETE;
								this.bufferOffset = i + 1;
								this.bufferAvailable = bufferEnd - i - 1;
								return new ArraySegment<char>(buffer, lexemeStartIndex, i - lexemeStartIndex + 1);
							case JsonNotation.Escape:
								state = LEXER_STATE_QUOTED_ESCAPE; // skips escaped quotes - \"
								continue;
							default:
								if (state == LEXER_STATE_QUOTED_ESCAPE)
								{
									state = LEXER_STATE_QUOTED;
								}
								continue;
						}
					case LEXER_STATE_COMMENT_BEGINNING:
						switch (buffer[i])
						{
							case JsonNotation.Comment:
								state = LEXER_STATE_COMMENT_SINGLE_LINE;
								continue;
							case JsonNotation.CommentMultiline:
								state = LEXER_STATE_COMMENT_MULTILINE;
								continue;
							default:
								throw ReaderException.UnknownNotation(this, JsonNotation.Comment + buffer[i].ToString());
						}
					case LEXER_STATE_COMMENT_SINGLE_LINE:
						switch (buffer[i])
						{
							case JsonNotation.Newline:
							case JsonNotation.Return:
								state = LEXER_STATE_START;
								continue;
							default: continue;
						}
					case LEXER_STATE_COMMENT_MULTILINE_ENDING:
					case LEXER_STATE_COMMENT_MULTILINE:
						switch (buffer[i])
						{
							case JsonNotation.CommentMultiline:
								state = LEXER_STATE_COMMENT_MULTILINE_ENDING;
								continue;
							case JsonNotation.Comment:
								if (state == LEXER_STATE_COMMENT_MULTILINE_ENDING)
									state = LEXER_STATE_START;
								continue;
							default: continue;
						}

				}
			}

			if (state == LEXER_STATE_START || state == LEXER_STATE_COMMENT_BEGINNING || state == LEXER_STATE_COMMENT_MULTILINE ||
				state == LEXER_STATE_COMMENT_MULTILINE_ENDING || state == LEXER_STATE_COMMENT_SINGLE_LINE)
			{
				// no lexemes found in current buffer
				this.bufferOffset = this.bufferAvailable = lexemeStartIndex = lexemeLength = 0;
				goto start; // restart
			}

			lexemeLength = bufferEnd - lexemeStartIndex;

			// buffer contains only fragment of lexeme
			// lexeme parsing is not complete so there is 2 options:
			// 1) try to fill buffer and retry parsing
			// 2) return fragment to caller

			if (lexemeLength < this.buffer.Length / 2)
			{
				// if fragment is small then move fragment to the start of the buffer and re-start parsing
				if (lexemeStartIndex != 0)
				{
					Buffer.BlockCopy(this.buffer, lexemeStartIndex * CHAR_SIZE, this.buffer, 0, lexemeLength * CHAR_SIZE);
					lexemeStartIndex = 0;
				}

				this.bufferOffset = lexemeLength;
				this.bufferAvailable = 0;

				goto start; // restart
			}
			else
			{
				// if fragment is huge then return it to caller

				// set buffer is consumed
				this.bufferOffset = this.bufferAvailable = 0;

				return new ArraySegment<char>(this.buffer, lexemeStartIndex, lexemeLength);
			}
		}
		private void ResetBufferIfNeeded()
		{
			if (this.bufferAvailable == 0)
			{
				this.bufferOffset = 0;
			}
		}
		private int ReadToBuffer()
		{
			if (this.bufferOffset + this.bufferAvailable >= this.buffer.Length)
			{
				throw new InvalidOperationException("Unable to read to buffer because there is not space available. This will cause zero read and erroneous 'End Of Stream' message.");
			}

			var offset = this.bufferOffset + this.bufferAvailable;
			var count = this.buffer.Length - offset;
			var read = this.textReader.Read(this.buffer, offset, count);
			this.bufferAvailable += read;
			return read;
		}

		public override void Dispose()
		{
			if (!this.leaveOpen)
			{
				this.textReader.Dispose();
			}
		}

		private sealed class JsonValueBox : IStrongBox
		{
			private ArraySegment<char> value;
			private Type valueType;

			public Type ValueType => this.valueType;

			public bool AsBoolean => Convert.ToBoolean(this.LoadString(), CultureInfo.InvariantCulture);
			public byte AsByte => checked((byte)this.LoadUInt32());
			public short AsInt16 => checked((short)this.LoadInt32());
			public int AsInt32 => this.LoadInt32();
			public long AsInt64 => this.LoadInt64();
			public sbyte AsSByte => checked((sbyte)this.LoadInt32());
			public ushort AsUInt16 => checked((ushort)this.LoadUInt32());
			public uint AsUInt32 => this.LoadUInt32();
			public ulong AsUInt64 => this.LoadUInt64();
			public float AsSingle => Convert.ToSingle(this.LoadString(), CultureInfo.InvariantCulture);
			public double AsDouble => Convert.ToDouble(this.LoadString(), CultureInfo.InvariantCulture);
			public decimal AsDecimal => Convert.ToDecimal(this.LoadString(), CultureInfo.InvariantCulture);
			public DateTimeOffset AsDateTimeOffset => DateTimeOffset.ParseExact(this.LoadString(), GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
			public DateTime AsDateTime => DateTime.ParseExact(this.LoadString(), GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
			public TimeSpan AsTimeSpan => TimeSpan.Parse(this.LoadString(), CultureInfo.InvariantCulture);
			public object AsObject => this.LoadString();

			private uint LoadUInt32()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.StringToUInt32(array, offset, count);
			}
			private ulong LoadUInt64()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.StringToUInt64(array, offset, count);
			}
			private int LoadInt32()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.StringToInt32(array, offset, count);
			}
			private long LoadInt64()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.StringToInt64(array, offset, count);
			}
			private string LoadString()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.UnEscapeBuffer(array, offset, count, false);
			}

			public void Store<T>(T value)
			{
				this.value = (ArraySegment<char>)(object)value;
				this.valueType = typeof(string);
			}

			public void Store(ArraySegment<char> value, Type valueType)
			{
				if (valueType == null) throw new ArgumentNullException(nameof(valueType));

				this.value = value;
				this.valueType = valueType;
			}

			public override string ToString()
			{
				return this.LoadString();
			}
		}

		private static class JsonUtils
		{
			public static string UnEscapeBuffer(char[] charsToUnEscape, int offset, int count, bool strict)
			{
				if (charsToUnEscape == null) throw new ArgumentNullException(nameof(charsToUnEscape));
				if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
				if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
				if (offset + count > charsToUnEscape.Length) throw new ArgumentOutOfRangeException(nameof(offset));

				var unEscapedCount = GetUnEscapedCount(charsToUnEscape, offset, count);
				if (unEscapedCount == count)
				{
					return new string(charsToUnEscape, offset, count);
				}

				var resultBuilder = new StringBuilder(unEscapedCount);
				var plainStart = offset;
				var plainLen = 0;
				var end = offset + count;
				for (var i = offset; i < end; i++)
				{
					var ch = charsToUnEscape[i];
					if (ch != '\\')
					{
						plainLen++;
						continue;
					}

					if (i + 1 >= end)
					{
						if (strict)
						{
							throw ReaderException.UnknownEscapeSequence("\\\0", null);
						}
						else
						{
							plainLen++;
							break; // u
						}
					}

					var sequenceLength = 1;
					// append unencoded chunk
					if (plainLen != 0)
					{
						resultBuilder.Append(charsToUnEscape, plainStart, plainLen);
						plainLen = 0;
					}

					var sequenceKind = charsToUnEscape[i + 1];
					switch (sequenceKind)
					{
						case 'n':
							resultBuilder.Append('\n');
							break;
						case 'r':
							resultBuilder.Append('\r');
							break;
						case 'b':
							resultBuilder.Append('\b');
							break;
						case 'f':
							resultBuilder.Append('\f');
							break;
						case 't':
							resultBuilder.Append('\t');
							break;
						case '\\':
							resultBuilder.Append('\\');
							break;
						case '/':
							resultBuilder.Append('/');
							break;
						case '\'':
							resultBuilder.Append('\'');
							break;
						case '\"':
							resultBuilder.Append('\"');
							break;

						// unicode symbol
						case 'u':
							resultBuilder.Append((char)HexStringToUInt32(charsToUnEscape, i + 2, 4));
							sequenceLength = 5;
							break;

						// latin hex encoded symbol
						case 'x':
							resultBuilder.Append((char)HexStringToUInt32(charsToUnEscape, i + 2, 2));
							sequenceLength = 3;
							break;

						// latin dec encoded symbol
						case '1':
						case '2':
						case '3':
						case '4':
						case '5':
						case '6':
						case '7':
						case '8':
						case '9':
						case '0':
							resultBuilder.Append((char)StringToInt32(charsToUnEscape, i + 1, 3));
							sequenceLength = 3;
							break;
						default:
							if (!strict)
							{
								resultBuilder.Append(sequenceKind);
								break;
							}
							else
							{
								throw ReaderException.UnknownEscapeSequence("\\" + sequenceKind, null);
							}
					}

					// set next chunk start right after this escape
					plainStart = i + sequenceLength + 1;
					i += sequenceLength;
				}

				// append last unencoded chunk
				if (plainLen != 0)
				{
					resultBuilder.Append(charsToUnEscape, plainStart, plainLen);
				}

				return resultBuilder.ToString();
			}
			private static int GetUnEscapedCount(char[] charsToUnEscape, int offset, int count)
			{
				if (charsToUnEscape == null) throw new ArgumentNullException(nameof(charsToUnEscape));
				if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
				if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
				if (offset + count > charsToUnEscape.Length) throw new ArgumentOutOfRangeException(nameof(offset));

				var newCount = 0;
				var end = offset + count;
				for (var i = offset; i < end; i++)
				{
					var ch = charsToUnEscape[i];
					newCount++;
					if (ch != '\\')
					{
						continue;
					}

					var toSkip = 1;
					var sequenceKind = charsToUnEscape[i + 1];
					switch (sequenceKind)
					{
						// unicode symbol
						case 'u':
							toSkip = 5;
							break;

						// latin hex encoded symbol
						case 'x':
							toSkip = 3;
							break;
						// latin dec encoded symbol
						case '1':
						case '2':
						case '3':
						case '4':
						case '5':
						case '6':
						case '7':
						case '8':
						case '9':
						case '0':
							toSkip = 3;
							break;
						default:
							toSkip = 1;
							break;
					}
					i += toSkip;
				}
				return newCount;
			}

			public static uint HexStringToUInt32(char[] buffer, int offset, int count)
			{
				const uint ZERO = '0';
				const uint a = 'a';
				const uint A = 'A';

				var result = 0u;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					var d = 0u;
					if (c >= '0' && c <= '9')
						d = (c - ZERO);
					else if (c >= 'a' && c <= 'f')
						d = 10u + (c - a);
					else if (c >= 'A' && c <= 'F')
						d = 10u + (c - A);
					else
						throw new FormatException();

					result = 16u * result + d;
				}

				return result;
			}

			public static long StringToInt64(char[] buffer, int offset, int count)
			{
				const ulong ZERO = '0';

				var result = 0UL;
				var neg = false;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					if (i == 0 && c == '-')
					{
						neg = true;
						continue;
					}
					if (c < '0' || c > '9')
						throw new FormatException();

					result = checked(10UL * result + (c - ZERO));
				}

				if (neg)
					return -(long)(result);
				return (long)result;
			}
			public static int StringToInt32(char[] buffer, int offset, int count)
			{
				const uint ZERO = '0';

				var result = 0u;
				var neg = false;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					if (i == 0 && c == '-')
					{
						neg = true;
						continue;
					}
					if (c < '0' || c > '9')
						throw new FormatException();

					result = checked(10u * result + (c - ZERO));
				}

				if (neg)
					return -(int)(result);
				return (int)result;
			}
			public static ulong StringToUInt64(char[] buffer, int offset, int count)
			{
				const ulong ZERO = '0';

				var result = 0UL;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					if (c < '0' || c > '9')
						throw new FormatException();

					result = checked(10UL * result + (c - ZERO));
				}

				return result;
			}
			public static uint StringToUInt32(char[] buffer, int offset, int count)
			{
				const uint ZERO = '0';

				var result = 0U;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					if (c < '0' || c > '9')
						throw new FormatException();

					result = checked(10 * result + (c - ZERO));
				}

				return result;
			}
		}

		private static class JsonNotation
		{
			public const char Tab = '\t';
			public const char Space = ' ';
			public const char Newline = '\n';
			public const char Return = '\r';
			public const char IdentifierSeparator = ':';
			public const char ValueSeparator = ',';
			public const char BeginArray = '[';
			public const char EndArray = ']';
			public const char BeginObject = '{';
			public const char EndObject = '}';
			public const char Escape = '\\';
			public const char Comment = '/';
			public const char CommentMultiline = '*';
			public const char Quote = '\"';
			public const char Const0 = '0';
			public const char Const1 = '1';
			public const char Const2 = '2';
			public const char Const3 = '3';
			public const char Const4 = '4';
			public const char Const5 = '5';
			public const char Const6 = '6';
			public const char Const7 = '7';
			public const char Const8 = '8';
			public const char Const9 = '9';
			public const string True = "true";
			public const string False = "false";
			public const string Null = "null";
		}
	}


	public sealed class MessagePackGameDataReader : GameDataReader
	{
		private const int DEFAULT_BUFFER_SIZE = ushort.MaxValue;
		private const int MAX_BINARY_LENGTH = 16 * 1024 * 1024;
		private const int MAX_STRING_LENGTH = 16 * 1024 * 1024;

		private struct Map
		{
			public ReaderToken Token;
			public long Counter;
		}

		private readonly Stream inputStream;
		private readonly bool leaveOpen;
		private readonly byte[] buffer;
		private readonly EndianBitConverter bitConverter;
		private readonly Stack<Map> maps;
		private ReaderNode node;
		private int bufferOffset;
		private int bufferRead;
		private int bufferAvailable;
		private int totalBytesRead;

		private StrongBox<int> int32Box;
		private StrongBox<uint> uInt32Box;
		private StrongBox<long> int64Box;
		private StrongBox<ulong> uInt64Box;
		private StrongBox<float> singleBox;
		private StrongBox<double> doubleBox;
		private StrongBox<decimal> decimalBox;
		private StrongBox<DateTime> dateBox;
		private StrongBox<DateTimeOffset> dateOffsetBox;
		private StrongBox<TimeSpan> timeSpanBox;
		private StrongBox<Guid> guidBox;
		private StrongBox<bool> trueBox;
		private StrongBox<bool> falseBox;

		public override int LineNumber => 0;
		public override int ColumnNumber => this.totalBytesRead;
		public override ReaderNode Node { get { if (this.node.Token == ReaderToken.None) this.NextToken(); return this.node; } }

		public MessagePackGameDataReader(Stream stream, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE)
		{
			if (stream == null) throw new ArgumentNullException(nameof(stream));

			if (bufferSize < DEFAULT_BUFFER_SIZE)
				bufferSize = DEFAULT_BUFFER_SIZE;

			this.inputStream = stream;
			this.leaveOpen = leaveOpen;
			this.buffer = new byte[bufferSize];
			this.bufferOffset = 0;
			this.bufferRead = 0;
			this.bufferAvailable = 0;
			this.bitConverter = EndianBitConverter.Big;
			this.maps = new Stack<Map>();
		}

		public override bool NextToken()
		{
			if (this.maps.Count > 0 && this.maps.Peek().Counter == 0)
			{
				var closingToken = this.maps.Pop();
				this.node = new ReaderNode(closingToken.Token);

				this.DecrementClosingTokenCounter();
				return true;
			}

			if (!this.ReadToBuffer(1, throwOnEos: false))
			{
				this.node = new ReaderNode(ReaderToken.EndOfStream);
				return false;
			}

			var formatValue = this.buffer[this.bufferOffset];
			if (formatValue >= (byte)MessagePackType.FixArrayStart && formatValue <= (byte)MessagePackType.FixArrayEnd)
			{
				var arrayCount = formatValue - (byte)MessagePackType.FixArrayStart;

				this.maps.Push(new Map { Token = ReaderToken.EndOfArray, Counter = arrayCount + 1 });
				this.node = new ReaderNode(ReaderToken.BeginArray);
			}
			else if (formatValue >= (byte)MessagePackType.FixStrStart && formatValue <= (byte)MessagePackType.FixStrEnd)
			{
				var strCount = formatValue - (byte)MessagePackType.FixStrStart;
				var strBytes = this.ReadBytes(strCount);

				var token = ReaderToken.Value;
				if (this.maps.Count > 0)
				{
					var closingToken = this.maps.Peek();
					if (closingToken.Token == ReaderToken.EndOfObject && closingToken.Counter > 0 && closingToken.Counter % 2 == 0)
						token = ReaderToken.Member;
				}

				var strValue = default(string);

				System.Diagnostics.Debug.Assert(strBytes.Array != null, "strBytes.Array != null");

				strValue = Encoding.UTF8.GetString(strBytes.Array, strBytes.Offset, strBytes.Count);

				this.node = new ReaderNode(token, strValue);
			}
			else if (formatValue >= (byte)MessagePackType.FixMapStart && formatValue <= (byte)MessagePackType.FixMapEnd)
			{
				var mapCount = formatValue - (byte)MessagePackType.FixMapStart;
				this.maps.Push(new Map { Token = ReaderToken.EndOfObject, Counter = mapCount * 2 + 1 });
				this.node = new ReaderNode(ReaderToken.BeginObject);
			}
			else if (formatValue >= (byte)MessagePackType.NegativeFixIntStart)
			{
				this.node = new ReaderNode(ReaderToken.Value, this.Box(unchecked((sbyte)formatValue)));
			}
			else if (formatValue <= (byte)MessagePackType.PositiveFixIntEnd)
			{
				this.node = new ReaderNode(ReaderToken.Value, this.Box(formatValue));
			}
			else
			{
				switch ((MessagePackType)formatValue)
				{
					case MessagePackType.Nil:
						this.node = new ReaderNode(ReaderToken.Null);
						break;
					case MessagePackType.Array16:
					case MessagePackType.Array32:
						var arrayCount = 0L;
						if (formatValue == (int)MessagePackType.Array16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							arrayCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Array32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							arrayCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						if (arrayCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of array");

						this.maps.Push(new Map { Token = ReaderToken.EndOfArray, Counter = arrayCount + 1 });
						this.node = new ReaderNode(ReaderToken.BeginArray);
						break;
					case MessagePackType.Map16:
					case MessagePackType.Map32:
						var mapCount = 0L;
						if (formatValue == (int)MessagePackType.Map16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							mapCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Map32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							mapCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						if (mapCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of map");

						this.maps.Push(new Map { Token = ReaderToken.EndOfObject, Counter = mapCount * 2 + 1 });
						this.node = new ReaderNode(ReaderToken.BeginObject);
						break;
					case MessagePackType.Str16:
					case MessagePackType.Str32:
					case MessagePackType.Str8:
						var strBytesCount = 0L;
						if (formatValue == (int)MessagePackType.Str8)
						{
							this.ReadToBuffer(1, throwOnEos: true);
							strBytesCount = this.buffer[this.bufferOffset];
						}
						else if (formatValue == (int)MessagePackType.Str16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							strBytesCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Str32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							strBytesCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						var token = ReaderToken.Value;
						if (this.maps.Count > 0)
						{
							var closingToken = this.maps.Peek();
							if (closingToken.Token == ReaderToken.EndOfObject && closingToken.Counter > 0 && closingToken.Counter % 2 == 0)
								token = ReaderToken.Member;
						}

						if (strBytesCount > MAX_STRING_LENGTH) throw ReaderException.StringLiteralIsTooLong(this, (int)strBytesCount, MAX_STRING_LENGTH);

						var strBytes = this.ReadBytes(strBytesCount);
						System.Diagnostics.Debug.Assert(strBytes.Array != null, "strBytes.Array != null");
						var stringValue = Encoding.UTF8.GetString(strBytes.Array, strBytes.Offset, strBytes.Count);
						this.node = new ReaderNode(token, stringValue);
						break;
					case MessagePackType.Bin32:
					case MessagePackType.Bin16:
					case MessagePackType.Bin8:
						var bytesCount = 0L;
						if (formatValue == (int)MessagePackType.Bin8)
						{
							this.ReadToBuffer(1, throwOnEos: true);
							bytesCount = this.buffer[this.bufferOffset];
						}
						else if (formatValue == (int)MessagePackType.Bin16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							bytesCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Bin32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							bytesCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						if (bytesCount > MAX_BINARY_LENGTH) throw ReaderException.BinaryDataIsTooLong(this, (int)bytesCount, MAX_BINARY_LENGTH);
						if (bytesCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of binary data");

						var bytes = this.ReadBytes(bytesCount, forceNewBuffer: true);
						System.Diagnostics.Debug.Assert(bytes.Array != null, "bytes.Array != null");
						this.node = new ReaderNode(ReaderToken.Value, bytes.Array);
						break;
					case MessagePackType.FixExt1:
					case MessagePackType.FixExt16:
					case MessagePackType.FixExt2:
					case MessagePackType.FixExt4:
					case MessagePackType.FixExt8:
					case MessagePackType.Ext32:
					case MessagePackType.Ext16:
					case MessagePackType.Ext8:
						var extLength = 0L;
						if (formatValue == (int)MessagePackType.FixExt1)
							extLength = 1;
						else if (formatValue == (int)MessagePackType.FixExt2)
							extLength = 2;
						else if (formatValue == (int)MessagePackType.FixExt4)
							extLength = 4;
						else if (formatValue == (int)MessagePackType.FixExt8)
							extLength = 8;
						else if (formatValue == (int)MessagePackType.FixExt16)
							extLength = 16;
						if (formatValue == (int)MessagePackType.Ext8)
						{
							this.ReadToBuffer(1, throwOnEos: true);
							extLength = this.buffer[this.bufferOffset];
						}
						else if (formatValue == (int)MessagePackType.Ext16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							extLength = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Ext32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							extLength = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						this.ReadToBuffer(1, throwOnEos: true);
						var extType = this.buffer[this.bufferOffset];

						if (extLength > MAX_BINARY_LENGTH) throw ReaderException.BinaryDataIsTooLong(this, (int)extLength, MAX_BINARY_LENGTH);

						var data = this.ReadBytes(extLength, forceNewBuffer: true);
						System.Diagnostics.Debug.Assert(data.Array != null, "data.Array != null");
						if (!this.TryReadExtType(extType, data, out this.node))
							this.node = new ReaderNode(ReaderToken.Value, data.Array);
						break;
					case MessagePackType.False:
						this.node = new ReaderNode(ReaderToken.Value, this.Box(false));
						break;
					case MessagePackType.True:
						this.node = new ReaderNode(ReaderToken.Value, this.Box(true));
						break;
					case MessagePackType.Float32:
						this.ReadToBuffer(4, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToSingle(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Float64:
						this.ReadToBuffer(8, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToDouble(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Int16:
						this.ReadToBuffer(2, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToInt16(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Int32:
						this.ReadToBuffer(4, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToInt32(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Int64:
						this.ReadToBuffer(8, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToInt64(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Int8:
						this.ReadToBuffer(1, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(unchecked((sbyte)this.buffer[this.bufferOffset])));
						break;
					case MessagePackType.UInt16:
						this.ReadToBuffer(2, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box((uint)this.bitConverter.ToUInt16(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.UInt32:
						this.ReadToBuffer(4, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToUInt32(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.UInt64:
						this.ReadToBuffer(8, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToUInt64(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.UInt8:
						this.ReadToBuffer(1, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box((uint)this.buffer[this.bufferOffset]));
						break;
					case MessagePackType.PositiveFixIntStart:
					case MessagePackType.PositiveFixIntEnd:
					case MessagePackType.FixMapStart:
					case MessagePackType.FixMapEnd:
					case MessagePackType.FixArrayStart:
					case MessagePackType.FixArrayEnd:
					case MessagePackType.FixStrStart:
					case MessagePackType.FixStrEnd:
					case MessagePackType.Unused:
					case MessagePackType.NegativeFixIntStart:
					case MessagePackType.NegativeFixIntEnd:
					default: throw ReaderException.UnknownMessagePackType(((MessagePackType)formatValue).ToString(), this);
				}
			}

			this.DecrementClosingTokenCounter();

			return true;
		}

		private bool ReadToBuffer(int bytesRequired, bool throwOnEos)
		{
			this.bufferAvailable -= this.bufferRead;
			this.bufferOffset += this.bufferRead;
			this.bufferRead = 0;

			if (this.bufferAvailable < bytesRequired)
			{
				if (this.bufferAvailable > 0)
					Buffer.BlockCopy(this.buffer, this.bufferOffset, this.buffer, 0, this.bufferAvailable);

				this.bufferOffset = 0;
				while (this.bufferAvailable < bytesRequired)
				{
					var read = this.inputStream.Read(this.buffer, this.bufferAvailable, this.buffer.Length - this.bufferAvailable);
					this.bufferAvailable += read;

					if (read != 0 || this.bufferAvailable >= bytesRequired)
						continue;

					if (throwOnEos)
						throw ReaderException.UnexpectedEndOfStream(this);

					return false;
				}
			}

			this.bufferRead = bytesRequired;
			this.totalBytesRead += bytesRequired;
			return true;
		}
		private ArraySegment<byte> ReadBytes(long bytesRequired, bool forceNewBuffer = false)
		{
			if (bytesRequired > int.MaxValue) throw new ArgumentOutOfRangeException(nameof(bytesRequired));

			this.bufferAvailable -= this.bufferRead;
			this.bufferOffset += this.bufferRead;
			this.bufferRead = 0;

			if (this.bufferAvailable >= bytesRequired && !forceNewBuffer)
			{
				var bytes = new ArraySegment<byte>(this.buffer, this.bufferOffset, (int)bytesRequired);

				this.bufferAvailable -= (int)bytesRequired;
				this.bufferOffset += (int)bytesRequired;
				this.totalBytesRead += (int)bytesRequired;

				return bytes;
			}
			else
			{
				var bytes = new byte[bytesRequired];
				var bytesOffset = 0;
				if (this.bufferAvailable > 0 && bytesOffset < bytes.Length)
				{
					var bytesToCopy = Math.Min(bytes.Length, this.bufferAvailable);
					Buffer.BlockCopy(this.buffer, this.bufferOffset, bytes, bytesOffset, bytesToCopy);

					bytesOffset += bytesToCopy;
					this.bufferOffset += bytesToCopy;

					this.bufferAvailable -= bytesToCopy;
					this.totalBytesRead += bytesToCopy;
				}

				if (this.bufferAvailable == 0)
					this.bufferOffset = 0;

				while (bytesOffset < bytes.Length)
				{
					var read = this.inputStream.Read(bytes, bytesOffset, bytes.Length - bytesOffset);

					bytesOffset += read;
					this.totalBytesRead += read;

					if (read == 0 && bytesOffset < bytes.Length)
						throw ReaderException.UnexpectedEndOfStream(this);
				}

				return new ArraySegment<byte>(bytes, 0, bytes.Length);
			}
		}
		private bool TryReadExtType(byte extType, ArraySegment<byte> data, out ReaderNode node)
		{
			const byte EXTENSION_TYPE_TIMESTAMP = 255;
			const byte EXTENSION_TYPE_DATE_TIME = 40;
			const byte EXTENSION_TYPE_DATE_TIME_OFFSET = 41;
			const byte EXTENSION_TYPE_DECIMAL = 42;
			const byte EXTENSION_TYPE_GUID = 43;
			const byte GUID_SIZE = 16;
			const byte DECIMAL_SIZE = 16;
			const byte DATE_TIME_SIZE = 16;
			const byte DATE_TIME_OFFSET_SIZE = 16;

			node = default;
			switch (extType)
			{
				case EXTENSION_TYPE_TIMESTAMP:
					unchecked
					{
						var seconds = 0L;
						var nanoSeconds = 0u;
						switch (data.Count)
						{
							case 4:
								seconds = this.bitConverter.ToInt32(data.Array, data.Offset);
								break;
							case 8:
								var data64 = this.bitConverter.ToUInt64(data.Array, data.Offset);
								seconds = (int)(data64 & 0x00000003ffffffffL);
								nanoSeconds = (uint)(data64 >> 34 & uint.MaxValue);
								break;
							case 12:
								nanoSeconds = this.bitConverter.ToUInt32(data.Array, data.Offset);
								seconds = this.bitConverter.ToInt64(data.Array, data.Offset + 4);
								break;
							default:
								return false;
						}
						node = new ReaderNode(ReaderToken.Value, this.Box(TimeSpan.FromSeconds(seconds).Add(TimeSpan.FromTicks(nanoSeconds / 100))));
						return true;
					}
				case EXTENSION_TYPE_DATE_TIME:
					if (data.Count != DATE_TIME_SIZE)
						return false;
					System.Diagnostics.Debug.Assert(data.Array != null, "data.Array != null");
					var dateTime = new DateTime(this.bitConverter.ToInt64(data.Array, data.Offset + 1), (DateTimeKind)data.Array[data.Offset]);
					node = new ReaderNode(ReaderToken.Value, this.Box(dateTime));
					return true;
				case EXTENSION_TYPE_DATE_TIME_OFFSET:
					if (data.Count != DATE_TIME_OFFSET_SIZE)
						return false;
					var offset = new TimeSpan(this.bitConverter.ToInt64(data.Array, data.Offset + 8));
					var ticks = this.bitConverter.ToInt64(data.Array, data.Offset);
					var dateTimeOffset = new DateTimeOffset(ticks, offset);
					node = new ReaderNode(ReaderToken.Value, this.Box(dateTimeOffset));
					return true;
				case EXTENSION_TYPE_DECIMAL:
					if (data.Count != DECIMAL_SIZE)
						return false;
					var decimalValue = this.bitConverter.ToDecimal(data.Array, data.Offset);
					node = new ReaderNode(ReaderToken.Value, this.Box(decimalValue));
					return true;
				case EXTENSION_TYPE_GUID:
					if (data.Count != GUID_SIZE)
						return false;

					var buffer = data.Array;
					System.Diagnostics.Debug.Assert(buffer != null, "buffer != null");
					unchecked
					{
						var guidValue = new Guid
						(
								(uint)(buffer[data.Offset + 3] << 24 | buffer[data.Offset + 2] << 16 | buffer[data.Offset + 1] << 8 | buffer[data.Offset + 0]),
								(ushort)(buffer[data.Offset + 5] << 8 | buffer[data.Offset + 4]),
								(ushort)(buffer[data.Offset + 7] << 8 | buffer[data.Offset + 6]),
								buffer[data.Offset + 8],
								buffer[data.Offset + 9],
								buffer[data.Offset + 10],
								buffer[data.Offset + 11],
								buffer[data.Offset + 12],
								buffer[data.Offset + 13],
								buffer[data.Offset + 14],
								buffer[data.Offset + 15]
						);

						node = new ReaderNode(ReaderToken.Value, this.Box(guidValue));
						return true;
					}
				default:
					return false;
			}
		}

		private object Box(int value)
		{
			var int32Box = this.int32Box ?? (this.int32Box = new StrongBox<int>(CultureInfo.InvariantCulture));
			int32Box.Store(value);
			return int32Box;
		}
		private object Box(uint value)
		{
			var uInt32Box = this.uInt32Box ?? (this.uInt32Box = new StrongBox<uint>(CultureInfo.InvariantCulture));
			uInt32Box.Store(value);
			return uInt32Box;
		}
		private object Box(long value)
		{
			var int64Box = this.int64Box ?? (this.int64Box = new StrongBox<Int64>(CultureInfo.InvariantCulture));
			int64Box.Store(value);
			return int64Box;
		}
		private object Box(ulong value)
		{
			var uInt64Box = this.uInt64Box ?? (this.uInt64Box = new StrongBox<UInt64>(CultureInfo.InvariantCulture));
			uInt64Box.Store(value);
			return uInt64Box;
		}
		private object Box(float value)
		{
			var singleBox = this.singleBox ?? (this.singleBox = new StrongBox<float>(CultureInfo.InvariantCulture));
			singleBox.Store(value);
			return singleBox;
		}
		private object Box(double value)
		{
			var doubleBox = this.doubleBox ?? (this.doubleBox = new StrongBox<double>(CultureInfo.InvariantCulture));
			doubleBox.Store(value);
			return doubleBox;
		}
		private object Box(decimal value)
		{
			var decimalBox = this.decimalBox ?? (this.decimalBox = new StrongBox<decimal>(CultureInfo.InvariantCulture));
			decimalBox.Store(value);
			return decimalBox;
		}
		private object Box(DateTime value)
		{
			var dateBox = this.dateBox ?? (this.dateBox = new StrongBox<DateTime>(CultureInfo.InvariantCulture));
			dateBox.Store(value);
			return dateBox;
		}
		private object Box(DateTimeOffset value)
		{
			var dateOffsetBox = this.dateOffsetBox ?? (this.dateOffsetBox = new StrongBox<DateTimeOffset>(CultureInfo.InvariantCulture));
			dateOffsetBox.Store(value);
			return dateOffsetBox;
		}
		private object Box(TimeSpan value)
		{
			var timeSpanBox = this.timeSpanBox ?? (this.timeSpanBox = new StrongBox<TimeSpan>(CultureInfo.InvariantCulture));
			timeSpanBox.Store(value);
			return timeSpanBox;
		}
		private object Box(Guid value)
		{
			var guidBox = this.guidBox ?? (this.guidBox = new StrongBox<Guid>(CultureInfo.InvariantCulture));
			guidBox.Store(value);
			return guidBox;
		}
		private object Box(bool value)
		{
			if (value)
			{
				return this.trueBox ?? (this.trueBox = new StrongBox<bool>(true, CultureInfo.InvariantCulture));
			}
			return this.falseBox ?? (this.falseBox = new StrongBox<bool>(false, CultureInfo.InvariantCulture));
		}

		private void DecrementClosingTokenCounter()
		{
			if (this.maps.Count > 0)
			{
				var closingToken = this.maps.Pop();
				closingToken.Counter--;
				this.maps.Push(closingToken);
			}
		}

		public override void Dispose()
		{
			if (!this.leaveOpen)
			{
				this.inputStream.Dispose();
			}
		}


		private enum MessagePackType : byte
		{
			PositiveFixIntStart = 0x00,
			PositiveFixIntEnd = 0x7f,
			FixMapStart = 0x80,
			FixMapEnd = 0x8f,
			FixArrayStart = 0x90,
			FixArrayEnd = 0x9f,
			FixStrStart = 0xa0,
			FixStrEnd = 0xbf,
			Nil = 0xc0,
			Unused = 0xc1,
			False = 0xc2,
			True = 0xc3,
			Bin8 = 0xc4,
			Bin16 = 0xc5,
			Bin32 = 0xc6,
			Ext8 = 0xc7,
			Ext16 = 0xc8,
			Ext32 = 0xc9,
			Float32 = 0xca,
			Float64 = 0xcb,
			UInt8 = 0xcc,
			UInt16 = 0xcd,
			UInt32 = 0xce,
			UInt64 = 0xcf,
			Int8 = 0xd0,
			Int16 = 0xd1,
			Int32 = 0xd2,
			Int64 = 0xd3,
			FixExt1 = 0xd4,
			FixExt2 = 0xd5,
			FixExt4 = 0xd6,
			FixExt8 = 0xd7,
			FixExt16 = 0xd8,
			Str8 = 0xd9,
			Str16 = 0xda,
			Str32 = 0xdb,
			Array16 = 0xdc,
			Array32 = 0xdd,
			Map16 = 0xde,
			Map32 = 0xdf,
			NegativeFixIntStart = 0xe0,
			NegativeFixIntEnd = 0xff
		}

		private enum MessagePackExtentionType : byte
		{
			None = 0,
			DateTime = 40,
			DateTimeOffset = 41,
			Decimal = 42
		}
	}


	[Serializable]
	public class ReaderException : SerializationException
	{
		public int Code { get; set; }
		public int LineNumber { get; set; }
		public int ColumnNumber { get; set; }

		private ReaderException(string message, GameDataReader gameDataReader)
			: base(message)
		{
			if (message == null) throw new ArgumentNullException(nameof(message));

			if (gameDataReader != null)
				this.Update(gameDataReader);
		}

		protected ReaderException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			if (info == null) throw new ArgumentNullException(nameof(info));

			this.LineNumber = info.GetInt32("LineNumber");
			this.ColumnNumber = info.GetInt32("ColumnNumber");
		}

		private void Update(GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			this.LineNumber = gameDataReader.LineNumber;
			this.ColumnNumber = gameDataReader.ColumnNumber;
		}

		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			if (info == null) throw new ArgumentNullException(nameof(info));

			info.AddValue("Code", this.Code);
			info.AddValue("LineNumber", this.LineNumber);
			info.AddValue("ColumnNumber", this.ColumnNumber);

			base.GetObjectData(info, context);
		}

		public static Exception UnexpectedEndOfStream(GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException("Unexpected end of stream.", gameDataReader);
		}
		public static Exception UnexpectedToken(GameDataReader gameDataReader, params ReaderToken[] expectedTokens)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));
			if (expectedTokens == null) throw new ArgumentNullException(nameof(expectedTokens));

			var tokensStr = default(string);
			if (expectedTokens.Length == 0)
			{
				tokensStr = "<no tokens>";
			}
			else
			{
				var tokens = Array.ConvertAll(expectedTokens, c => c.ToString());
				tokensStr = String.Join(", ", tokens);
			}

			return new ReaderException($"Expected one of there '{tokensStr}' but found '{gameDataReader.Node.Token}'({gameDataReader.Node.ValueType?.Name ?? "<null>"}).",
				gameDataReader);
		}
		public static Exception UnknownEscapeSequence(string escape, GameDataReader gameDataReader)
		{
			if (escape == null) throw new ArgumentNullException(nameof(escape));
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"An unknown escape sequence '{escape}'.", gameDataReader);
		}
		public static Exception UnterminatedStringLiteral(GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException("An unterminated string literal.", gameDataReader);
		}
		public static Exception UnknownNotation(GameDataReader gameDataReader, string notation)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"An unknown notation '{notation}'.", gameDataReader);
		}
		public static Exception StringLiteralIsTooLong(GameDataReader gameDataReader, int size, int maxSize)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"String literal is too long '{size}'. Maximum size is {maxSize}.", gameDataReader);
		}
		public static Exception BinaryDataIsTooLong(GameDataReader gameDataReader, int size, int maxSize)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"Binary data is too long '{size}'. Maximum size is {maxSize}.", gameDataReader);
		}
		public static Exception ReadingBrokenDocument(GameDataReader gameDataReader, string additionalInformation)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"Failed to continue deserialize because document's structure is invalid. Additional information: {additionalInformation}", gameDataReader);
		}
		public static Exception UnknownMessagePackType(string type, GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"An unknown Message Pack type '{type}'.", gameDataReader);
		}
		public static Exception UnexpectedNullValue(string expected, string propertyName, string schemaName, GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"A null value is deserialized instead of {expected} for required property '{propertyName}' in schema '{schemaName}'.",
				gameDataReader);
		}
	}


	public readonly struct ReaderNode
	{
		private readonly object value;

		public readonly ReaderToken Token;
		public readonly Type ValueType;

		public bool HasValue => this.ValueType != typeof(void);

		public ReaderNode(ReaderToken token)
		{
			this.Token = token;
			this.value = null;
			this.ValueType = typeof(void);
		}
		public ReaderNode(ReaderToken token, object value)
		{
			if (value == null) throw new ArgumentNullException(nameof(value));

			this.Token = token;
			this.value = value;
			this.ValueType = value is IStrongBox box ? box.ValueType : value.GetType();
		}

		public bool AsBoolean
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsBoolean;

				return Convert.ToBoolean(this.value, CultureInfo.InvariantCulture);
			}
		}
		public byte AsByte
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsByte;

				return Convert.ToByte(this.value, CultureInfo.InvariantCulture);
			}
		}
		public short AsInt16
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsInt16;

				return Convert.ToInt16(this.value, CultureInfo.InvariantCulture);
			}
		}
		public int AsInt32
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsInt32;

				return Convert.ToInt32(this.value, CultureInfo.InvariantCulture);
			}
		}
		public long AsInt64
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsInt64;

				return Convert.ToInt64(this.value, CultureInfo.InvariantCulture);
			}
		}
		public sbyte AsSByte
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsSByte;

				return Convert.ToSByte(this.value, CultureInfo.InvariantCulture);
			}
		}
		public ushort AsUInt16
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsUInt16;

				return Convert.ToUInt16(this.value, CultureInfo.InvariantCulture);
			}
		}
		public uint AsUInt32
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsUInt32;

				return Convert.ToUInt32(this.value, CultureInfo.InvariantCulture);
			}
		}
		public ulong AsUInt64
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsUInt64;

				return Convert.ToUInt64(this.value, CultureInfo.InvariantCulture);
			}
		}
		public float AsSingle
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsSingle;

				return Convert.ToSingle(this.value, CultureInfo.InvariantCulture);
			}
		}
		public double AsDouble
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsDouble;

				return Convert.ToDouble(this.value, CultureInfo.InvariantCulture);
			}
		}
		public decimal AsDecimal
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsDecimal;

				return Convert.ToDecimal(this.value, CultureInfo.InvariantCulture);
			}
		}
		public string AsString
		{
			get
			{
				var value = this.value;
				if (this.value is IStrongBox box) value = box.AsObject;
				return Convert.ToString(value, CultureInfo.InvariantCulture);
			}
		}
		public DateTime AsDateTime
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsDateTime;

				var dateTimeStr = this.AsString;
				var date = DateTime.ParseExact(dateTimeStr, GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
				return date;
			}
		}
		public DateTimeOffset AsDateTimeOffset
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsDateTime;

				var dateTimeStr = this.AsString;
				var date = DateTimeOffset.ParseExact(dateTimeStr, GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
				return date;
			}
		}
		public TimeSpan AsTimeSpan
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsTimeSpan;

				var timeSpanStr = this.AsString;
				var timeSpan = TimeSpan.Parse(timeSpanStr);
				return timeSpan;
			}
		}
		public object AsObject
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsObject;

				return this.value;
			}
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "{0}:{1}", this.Token, this.value);
		}
	}


	public enum ReaderToken
	{
		None = 0,
		BeginArray,
		EndOfArray,
		BeginObject,
		EndOfObject,
		Member,
		Null,
		Value,
		Comment,
		EndOfStream
	}


	public sealed class StringLookupTable
	{
		public const int MAX_STRING_SIZE = 8 * 8;

		private readonly StringSet[] table;

		public StringLookupTable(StringSet[] table)
		{
			if (table == null) throw new ArgumentNullException(nameof(table));

			this.table = table;
			Array.Resize(ref this.table, MAX_STRING_SIZE + 1);
		}

		public bool TryGetString(byte[] bytes, int offset, int count, out string value)
		{
			const int LAST_ASCII_CHARACTER = 0x7f;

			if (bytes == null)
			{
				throw new ArgumentNullException(nameof(bytes));
			}

			if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
			if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
			if (offset + count > bytes.Length) throw new ArgumentOutOfRangeException(nameof(offset));

			if (count == 0)
			{
				value = string.Empty;
				return true;
			}

			value = null;
			if (count > MAX_STRING_SIZE || this.table[count] == null)
			{
				return false;
			}

			var end = offset + count;
			var octet = 0UL;
			for (var i = 0; offset + i < end; i++)
			{
				var character = bytes[offset + i];
				if (character > LAST_ASCII_CHARACTER)
				{
					return false;
				}

				if (i < 8)
				{
					octet = unchecked(octet | ((ulong)character << 8 * i));
				}
			}

			var set = this.table[count];
			var narrowOffset = 1;
			for (var i = 0; i < (count - 1) / 8; i++, narrowOffset++)
			{
				if (set == null || !set.TryNarrow(octet, out set))
				{
					return false;
				}

				octet = GetUInt64(bytes, offset + narrowOffset * 8, end);
			}

			return set != null && set.TryGetValue(octet, out value);
		}
		public bool TryGetString(char[] chars, int offset, int count, out string value)
		{
			const int LAST_ASCII_CHARACTER = 0x7f;

			if (chars == null)
			{
				throw new ArgumentNullException(nameof(chars));
			}

			if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
			if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
			if (offset + count > chars.Length) throw new ArgumentOutOfRangeException(nameof(offset));

			if (count == 0)
			{
				value = string.Empty;
				return true;
			}

			value = null;
			if (count > MAX_STRING_SIZE || this.table[count] == null)
			{
				return false;
			}

			var end = offset + count;
			var octet = 0UL;
			for (var i = 0; offset + i < end; i++)
			{
				var character = chars[offset + i];
				if (character > LAST_ASCII_CHARACTER)
				{
					return false;
				}

				if (i < 8)
				{
					octet = unchecked(octet | ((ulong)character << 8 * i));
				}
			}

			var set = this.table[count];
			var narrowOffset = 1;
			for (var i = 0; i < (count - 1) / 8; i++, narrowOffset++)
			{
				if (set == null || !set.TryNarrow(octet, out set))
				{
					return false;
				}

				octet = GetUInt64(chars, offset + narrowOffset * 8, end);
			}

			return set != null && set.TryGetValue(octet, out value);
		}

		private static ulong GetUInt64(byte[] bytes, int offset, int end)
		{
			if (offset >= end)
			{
				return 0;
			}

			switch (end - offset)
			{
				case 1: return (ulong)bytes[offset];
				case 2:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1;
				case 3:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2;
				case 4:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3;
				case 5:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3 |
						(ulong)bytes[offset + 4] << 8 * 4;
				case 6:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3 |
						(ulong)bytes[offset + 4] << 8 * 4 |
						(ulong)bytes[offset + 5] << 8 * 5;
				case 7:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3 |
						(ulong)bytes[offset + 4] << 8 * 4 |
						(ulong)bytes[offset + 5] << 8 * 5 |
						(ulong)bytes[offset + 6] << 8 * 6;
				default:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3 |
						(ulong)bytes[offset + 4] << 8 * 4 |
						(ulong)bytes[offset + 5] << 8 * 5 |
						(ulong)bytes[offset + 6] << 8 * 6 |
						(ulong)bytes[offset + 7] << 8 * 7;
			}
		}
		private static ulong GetUInt64(char[] chars, int offset, int end)
		{
			if (offset >= end)
			{
				return 0;
			}

			switch (end - offset)
			{
				case 1: return (ulong)chars[offset];
				case 2:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1;
				case 3:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2;
				case 4:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3;
				case 5:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3 |
						(ulong)chars[offset + 4] << 8 * 4;
				case 6:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3 |
						(ulong)chars[offset + 4] << 8 * 4 |
						(ulong)chars[offset + 5] << 8 * 5;
				case 7:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3 |
						(ulong)chars[offset + 4] << 8 * 4 |
						(ulong)chars[offset + 5] << 8 * 5 |
						(ulong)chars[offset + 6] << 8 * 6;
				default:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3 |
						(ulong)chars[offset + 4] << 8 * 4 |
						(ulong)chars[offset + 5] << 8 * 5 |
						(ulong)chars[offset + 6] << 8 * 6 |
						(ulong)chars[offset + 7] << 8 * 7;
			}
		}
	}


	public sealed class StringSet
	{
		public static readonly Comparer<ulong> KeyComparer = Comparer<ulong>.Default;

		private readonly ulong[] keys;
		private readonly StringSet[] subSets;
		private readonly string[] values;

		public StringSet(ulong[] keys, StringSet[] subSets)
		{
			if (keys == null) throw new ArgumentNullException(nameof(keys));
			if (subSets == null) throw new ArgumentNullException(nameof(subSets));
			if (subSets.Length != keys.Length) throw new ArgumentException("invalid sets", nameof(keys));

			this.keys = keys;
			this.subSets = subSets;
		}
		public StringSet(ulong[] keys, string[] values)
		{
			if (keys == null) throw new ArgumentNullException(nameof(keys));
			if (values == null) throw new ArgumentNullException(nameof(values));
			if (values.Length != keys.Length) throw new ArgumentException("invalid sets", nameof(keys));

			this.keys = keys;
			this.values = values;
		}

		public bool TryNarrow(ulong octet, out StringSet value)
		{
			var subSetIndex = 0;
			switch (this.keys.Length)
			{
				case 1:
					subSetIndex = this.keys[0] == octet ? 0 : -1;
					break;
				case 2:
					subSetIndex = this.keys[0] == octet ? 0 : this.keys[1] == octet ? 1 : -1;
					break;
				case 3:
				case 4:
				case 5:
					subSetIndex = Array.IndexOf(this.keys, octet, 0, this.keys.Length);
					break;
				default:
					subSetIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, octet, KeyComparer);
					break;
			}

			if (subSetIndex < 0)
			{
				value = null;
				return false;
			}

			value = this.subSets[subSetIndex];
			return true;
		}
		public bool TryGetValue(ulong octet, out string value)
		{
			var valueIndex = 0;
			switch (this.keys.Length)
			{
				case 1:
					valueIndex = this.keys[0] == octet ? 0 : -1;
					break;
				case 2:
					valueIndex = this.keys[0] == octet ? 0 : this.keys[1] == octet ? 1 : -1;
					break;
				case 3:
				case 4:
				case 5:
					valueIndex = Array.IndexOf(this.keys, octet, 0, this.keys.Length);
					break;
				default:
					valueIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, octet, KeyComparer);
					break;
			}

			if (valueIndex < 0)
			{
				value = null;
				return false;
			}

			value = this.values[valueIndex];
			return value != null;
		}
	}


	public sealed class StrongBox<ValueT> : IStrongBox
	{
		private static readonly Type ValueType = typeof(ValueT);

		private readonly IFormatProvider formatProvider;

		public ValueT Value;

		public StrongBox(ValueT value, IFormatProvider formatProvider)
			: this(formatProvider)
		{
			this.Value = value;
		}
		public StrongBox(IFormatProvider formatProvider)
		{
			if (formatProvider == null) throw new ArgumentNullException(nameof(formatProvider));

			this.formatProvider = formatProvider;
		}

		Type IStrongBox.ValueType => ValueType;
		public bool AsBoolean => this.Value is bool asBoolean ? asBoolean : Convert.ToBoolean(this.Value, this.formatProvider);
		public byte AsByte => this.Value is byte asByte ? asByte :  Convert.ToByte(this.Value, this.formatProvider);
		public short AsInt16 => this.Value is short asInt16 ? asInt16 : Convert.ToInt16(this.Value, this.formatProvider);
		public int AsInt32 => this.Value is int asInt32 ? asInt32 : Convert.ToInt32(this.Value, this.formatProvider);
		public long AsInt64 => this.Value is long asInt64 ? asInt64 : Convert.ToInt64(this.Value, this.formatProvider);
		public sbyte AsSByte => this.Value is sbyte asSByte ? asSByte : Convert.ToSByte(this.Value, this.formatProvider);
		public ushort AsUInt16 => this.Value is ushort asUInt16 ? asUInt16 : Convert.ToUInt16(this.Value, this.formatProvider);
		public uint AsUInt32 => this.Value is uint asUInt32 ? asUInt32 : Convert.ToUInt32(this.Value, this.formatProvider);
		public ulong AsUInt64 => this.Value is ulong asUInt64 ? asUInt64 : Convert.ToUInt64(this.Value, this.formatProvider);
		public float AsSingle => this.Value is float asSingle ? asSingle : Convert.ToSingle(this.Value, this.formatProvider);
		public double AsDouble => this.Value is double asDouble ? asDouble : Convert.ToDouble(this.Value, this.formatProvider);
		public decimal AsDecimal => this.Value is decimal asDecimal ? asDecimal : Convert.ToDecimal(this.Value, this.formatProvider);
		public DateTime AsDateTime => this.Value is DateTime asDateTime ? asDateTime : Convert.ToDateTime(this.Value, this.formatProvider);
		public DateTimeOffset AsDateTimeOffset => this.Value is DateTimeOffset asDateTimeOffset ? asDateTimeOffset : new DateTimeOffset(Convert.ToDateTime(this.Value, this.formatProvider));
		public TimeSpan AsTimeSpan => this.Value is TimeSpan asTimeSpan ? asTimeSpan : TimeSpan.Parse(this.AsString ?? string.Empty, this.formatProvider);
		public string AsString => this.Value?.ToString();
		public object AsObject => this.Value;

		public void Store<T>(T value)
		{
			var type = typeof(T);
			if (type != ValueType)
			{
				throw new ArgumentException($"Unable to store value of type '{typeof(ValueT)}' in container of type '{type}'");
			}

			this.Value = (ValueT)(object)value;
		}

		public override string ToString()
		{
			return Convert.ToString(this.Value, this.formatProvider);
		}
	}

<#+ 
	}
#>
