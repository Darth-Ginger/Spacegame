<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#@ import namespace="System.Runtime.Serialization" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.ObjectModel" #>
<#@ import namespace="System.IO.Compression" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Security" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#+ 

	public sealed partial class CodeGenerationContext
	{
		private readonly Dictionary<string, NativeTypeReference> nativeTypes;

		public string ToolsName { get; set; }
		public string ToolsVersion { get; set; }

		public bool EagerReferenceResolution { get; set; }
		public bool RawReferences { get; set; }
		public bool RawLocalizedStrings { get; set; }
		public bool DisablePatching { get; set; }
		public bool DisableStringPooling { get; set; }
		public bool DisableJsonSerialization { get; set; }
		public bool DisableMessagePackSerialization { get; set; }

		public Metadata Metadata { get; }
		public StatisticsVisitor Statistics { get; }
		public GenerationTargetLanguage TargetLanguage { get; }
		public CodeObjectModel ObjectModel { get; }

		public CodeGenerationContext(string gameDataPath, GenerationTargetLanguage targetLanguage)
		{
			if (gameDataPath == null) throw new ArgumentNullException(nameof(gameDataPath));
			if (targetLanguage == null) throw new ArgumentNullException(nameof(targetLanguage));

			this.ToolsVersion = string.Empty;
			this.ToolsName = string.Empty;

			var gameData = this.Load(gameDataPath);
			this.Metadata = new Metadata(gameData);
			this.Statistics = StatisticsVisitor.Visit(gameData, this.Metadata);
			this.TargetLanguage = targetLanguage;

			this.nativeTypes = this.TargetLanguage.GetNativeTypes();
			var types = this.FindTypes();
			var formulas = this.FindFormulas(types.Keys);
			var enums = this.FindEnums(types.Keys);

			this.TargetLanguage.FixClassNames();
			this.ObjectModel = new CodeObjectModel(types, formulas, enums, this.nativeTypes);
			this.ObjectModel.ResolveNameCollisions(this.TargetLanguage);
		}

		private IReadOnlyDictionary<string, object> Load(string gameDataPath)
		{
			if (gameDataPath == null) throw new ArgumentNullException(nameof(gameDataPath));

			var encoding = Encoding.UTF8;
			var isGzipped = gameDataPath.EndsWith(".gz", StringComparison.OrdinalIgnoreCase);
			var extension = isGzipped ? Path.GetExtension(gameDataPath.Substring(0, gameDataPath.Length - 3)) : Path.GetExtension(gameDataPath);

			using (var gameDataFile = new FileStream(gameDataPath, FileMode.Open, FileAccess.Read, FileShare.Read, 4096, FileOptions.SequentialScan))
			using (var unGzipStream = isGzipped ? (Stream)new GZipStream(gameDataFile, CompressionMode.Decompress, leaveOpen: true) : gameDataFile)
			{
				switch (extension.Trim('.'))
				{
					case "gdjs":
					case "json":
						return ReadGameDataJson(unGzipStream, encoding, false);
					case "gdmp":
					case "msgpack":
					case "msgpck":
						return ReadGameDataMessagePack(unGzipStream, encoding, false);
					default:
						throw new InvalidOperationException($"Unknown file extension '{extension}'. Unable to determine file format by extension.");
				}
			}
		}

		private IReadOnlyDictionary<string, object> ReadGameDataMessagePack(Stream gameDataStream, Encoding _, bool leaveOpen)
		{
			using (var messagePackReader = new MessagePackGameDataReader(gameDataStream, leaveOpen))
			{
				return (IReadOnlyDictionary<string, object>)messagePackReader.ReadAny(nextToken: false);
			}
		}
		private IReadOnlyDictionary<string, object> ReadGameDataJson(Stream gameDataStream, Encoding encoding, bool leaveOpen)
		{
			using (var textReader = new StreamReader(gameDataStream, encoding, detectEncodingFromByteOrderMarks: true))
			using (var jsonReader = new JsonGameDataReader(textReader, leaveOpen))
			{
				return (IReadOnlyDictionary<string, object>)jsonReader.ReadAny(nextToken: false);
			}
		}

		private Dictionary<string, FormulaDefinition> FindFormulas(ICollection<string> schemaIds)
		{
			var formulas = new Dictionary<string, FormulaDefinition>();
			foreach (var schema in this.Metadata.GetSchemas())
			{
				foreach (var schemaProperty in schema.Properties)
				{
					if (schemaIds.Contains(schema.Id) == false)
					{
						continue;
					}

					if (schemaProperty.DataType != DataType.Formula)
					{
						continue;
					}

					if (schemaProperty.IsRawFormulaType)
					{
						continue;
					}

					var definition = new FormulaDefinition(schemaProperty, this.TargetLanguage, this.LazyResolve);
					formulas.Add(schemaProperty.Id, definition);
				}
			}

			return formulas;
		}
		private Dictionary<string, EnumDefinition> FindEnums(ICollection<string> schemaIds)
		{
			var mergeEnums = new Dictionary<string, EnumDefinition>();
			var enums = new Dictionary<string, EnumDefinition>();
			foreach (var schema in this.Metadata.GetSchemas())
			{
				if (schemaIds.Contains(schema.Id) == false)
				{
					continue;
				}

				foreach (var schemaProperty in schema.Properties)
				{
					if (schemaProperty.DataType != DataType.PickList && schemaProperty.DataType != DataType.MultiPickList)
					{
						continue;
					}

					var enumDef = new EnumDefinition(schemaProperty, this.TargetLanguage, this.LazyResolve);
					if (enumDef.MergeName != null &&
						mergeEnums.TryGetValue(enumDef.MergeName, out var otherDefinition))
					{
						otherDefinition.MergeWith(enumDef, this.LazyResolve);
						enums.Add(schemaProperty.Id, otherDefinition);
					}
					else
					{
						if (enumDef.MergeName != null)
						{
							mergeEnums.Add(enumDef.MergeName, enumDef);
						}

						enums.Add(schemaProperty.Id, enumDef);
					}
				}
			}

			return enums;
		}
		private Dictionary<string, TypeDefinition> FindTypes()
		{
			// determine all non-skipped schemas
			var referencedSchemaIds = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			var referencedSchemasCount = 0;
			do
			{
				referencedSchemasCount = referencedSchemaIds.Count;

				foreach (var schema in this.Metadata.GetSchemas())
				{
					var isSkipped = schema.GetSpecification().GetValues("classgen").Contains("skip") &&
						schema.Name != GenerationConstants.KNOWN_SCHEMA_PROJECT_SETTINGS;
					if (isSkipped && referencedSchemaIds.Contains(schema.Id) == false)
					{
						continue;
					}

					referencedSchemaIds.Add(schema.Id);

					foreach (var schemaProperty in schema.Properties)
					{
						if (schemaProperty.ReferenceType == null)
						{
							continue;
						}

						referencedSchemaIds.Add(schemaProperty.ReferenceType.Id);
					}
				}
			} while (referencedSchemasCount != referencedSchemaIds.Count);

			var types = new Dictionary<string, TypeDefinition>();
			foreach (var schema in this.Metadata.GetSchemas())
			{
				if (referencedSchemaIds.Contains(schema.Id) == false)
				{
					continue;
				}

				var definition = new TypeDefinition(schema, this.TargetLanguage, this.LazyResolve);
				types.Add(definition.TypeName, definition);
				types.Add(schema.Id, definition);
			}

			return types;
		}

		private ITypeReference LazyResolve(string typeName)
		{
			if (string.IsNullOrEmpty(typeName)) throw new ArgumentException("Type name can't be null or empty string.", nameof(typeName));

			if (this.ObjectModel != null)
			{
				return this.ObjectModel.ResolveType(typeName);
			}
			else if (this.nativeTypes.TryGetValue(typeName, out var nativeTypeRef))
			{
				return nativeTypeRef;
			}

			return new LazyTypeReference(typeName, this.ResolveInObjectModel);
		}
		private ITypeReference ResolveInObjectModel(string typeName)
		{
			if (string.IsNullOrEmpty(typeName)) throw new ArgumentException("Type name can't be null or empty string.", nameof(typeName));

			if (this.ObjectModel == null)
			{
				throw new InvalidOperationException($"Unable to resolve type '{typeName}' while object model is still building.");
			}

			return this.ObjectModel.ResolveType(typeName);
		}
	}


	public class CodeObjectModel
	{
		private readonly Dictionary<string, TypeDefinition> typeById;
		private readonly Dictionary<string, EnumDefinition> enumById;
		private readonly Dictionary<string, FormulaDefinition> formulaById;
		private readonly Dictionary<string, NativeTypeReference> nativeTypes;
		private readonly Dictionary<string, ExternalTypeReference> externalTypes;

		public IEnumerable<EnumDefinition> Enums => this.enumById.Values.Distinct();
		public IEnumerable<TypeDefinition> Types => this.typeById.Values.Distinct();
		public IEnumerable<FormulaDefinition> Formulas => this.formulaById.Values.Distinct();

		public CodeObjectModel
		(
			Dictionary<string, TypeDefinition> types,
			Dictionary<string, FormulaDefinition> formulas,
			Dictionary<string, EnumDefinition> enums,
			Dictionary<string, NativeTypeReference> nativeTypes)
		{
			if (types == null) throw new ArgumentNullException(nameof(types));
			if (formulas == null) throw new ArgumentNullException(nameof(formulas));
			if (enums == null) throw new ArgumentNullException(nameof(enums));

			this.typeById = types;
			this.enumById = enums;
			this.formulaById = formulas;
			this.nativeTypes = nativeTypes;
			this.externalTypes = new Dictionary<string, ExternalTypeReference>();
		}

		public ITypeReference ResolveType(string typeName)
		{
			if (string.IsNullOrEmpty(typeName)) throw new ArgumentException("Type name can't be null or empty string.", nameof(typeName));

			if (this.typeById.TryGetValue(typeName, out var typeDefinition))
			{
				return typeDefinition;
			}
			else if (this.enumById.TryGetValue(typeName, out var enumDefinition))
			{
				return enumDefinition;
			}
			else if (this.formulaById.TryGetValue(typeName, out var formulaDefinition))
			{
				return formulaDefinition;
			}
			else if (this.nativeTypes.TryGetValue(typeName, out var nativeType))
			{
				return nativeType;
			}
			else if (this.externalTypes.TryGetValue(typeName, out var externalType))
			{
				return externalType;
			}
			else
			{
				externalType = new ExternalTypeReference(typeName);
				this.externalTypes.Add(externalType.TypeName, externalType);
				return externalType;
			}
		}

		public IReadOnlyList<ITypeReference> GetAllDefinedTypes()
		{
			var result = new List<ITypeReference>(this.enumById.Count + this.typeById.Count + this.formulaById.Count);
			result.AddRange(this.Enums);
			result.AddRange(this.Types);
			result.AddRange(this.Formulas);
			return result;
		}

		public void ResolveNameCollisions(GenerationTargetLanguage targetLanguage)
		{
			var takenNames = new HashSet<string>(new[] {
				targetLanguage.DocumentClassName, targetLanguage.GameDataClassName, targetLanguage.LocalizedStringClassName,
				targetLanguage.DocumentReferenceClassName,
				targetLanguage.ReadOnlyListClassName, targetLanguage.ReadOnlyDictionaryClassName
			}, StringComparer.Ordinal);

			// check name collisions in types
			foreach (var typeDef in this.Types)
			{
				var typeName = typeDef.TypeName;
				var counter = 0;
				while (takenNames.Contains(typeName))
				{
					counter++;
					typeName = typeDef.TypeName + counter;
				}

				typeDef.TypeName = typeName;
				takenNames.Add(typeName);
			}

			// check name collisions in enums
			foreach (var enumDef in this.Enums)
			{
				var typeName = enumDef.TypeName;
				var counter = 0;
				while (takenNames.Contains(typeName))
				{
					counter++;
					typeName = enumDef.TypeName + counter;
				}

				enumDef.TypeName = typeName;
				takenNames.Add(typeName);
			}

			// check name collisions in formulas
			foreach (var formulaDef in this.Formulas)
			{
				var typeName = formulaDef.TypeName;
				var counter = 0;
				while (takenNames.Contains(typeName))
				{
					counter++;
					typeName = formulaDef.TypeName + counter;
				}

				formulaDef.TypeName = typeName;
				takenNames.Add(typeName);
			};
		}
	}


	public class CSharpLanguage : GenerationTargetLanguage
	{
		private static readonly IReadOnlyDictionary<Type, string> AliasByType = new Dictionary<Type, string> {
			{ typeof(string), "string" },
			{ typeof(char), "char" },
			{ typeof(bool), "bool" },
			{ typeof(void), "void" },
			{ typeof(object), "object" },
			{ typeof(byte), "byte" },
			{ typeof(sbyte), "sbyte" },
			{ typeof(short), "short" },
			{ typeof(ushort), "ushort" },
			{ typeof(int), "int" },
			{ typeof(uint), "uint" },
			{ typeof(long), "long" },
			{ typeof(ulong), "ulong" },
			{ typeof(float), "float" },
			{ typeof(double), "double" },
			{ typeof(decimal), "decimal" },
		};
		private static readonly IReadOnlyDictionary<string, Type> TypeByAlias = AliasByType.ToDictionary(kv => kv.Value, kv => kv.Key);

		private static readonly HashSet<string> NativeValueTypes = new HashSet<string>(new[] {
			typeof(char), typeof(bool), typeof(byte), typeof(sbyte), typeof(short), typeof(ushort),
			typeof(int), typeof(uint), typeof(long), typeof(ulong), typeof(float), typeof(double),
			typeof(decimal), typeof(TimeSpan), typeof(DateTime) }.Select(type => type.FullName));
		private static readonly HashSet<string> Keywords = new HashSet<string>(new string[] {
			"abstract", "as", "base", "bool", "break",
			"byte", "case", "catch", "char", "checked",
			"class", "const", "continue", "decimal", "default",
			"delegate", "do", "double", "else", "enum",
			"event", "explicit", "extern", "false", "finally",
			"fixed", "float", "for", "foreach", "goto",
			"if", "implicit", "in", "int", "interface",
			"internal", "is", "lock", "long", "namespace",
			"new", "null", "object", "operator", "out",
			"override", "params", "private", "protected", "public",
			"readonly", "ref", "return", "sbyte", "sealed",
			"short", "sizeof", "stackalloc", "static", "string",
			"struct", "switch", "this", "throw", "true",
			"try", "typeof", "uint", "ulong", "unchecked",
			"unsafe", "ushort", "using", "virtual", "void",
			"volatile", "while", "add", "alias", "ascending", "async", "await",
			"by", "descending", "dynamic", "equals", "from",
			"get", "global", "group", "into", "join",
			"let", "on", "orderby", "partial", "remove",
			"select", "set", "value", "var", "where"
		});

		public string RawJsonClassName { get; }

		public CSharpLanguage()
		{
			this.Namespace = "GameParameters";
			this.GameDataClassName = "GameData";
			this.DocumentClassName = "Document";
			this.LocalizedStringClassName = "LocalizedString";
			this.DocumentReferenceClassName = "DocumentReference";
			this.DocumentReferenceListClassName = "DocumentReferenceCollection";
			this.DocumentCollectionClassName = "DocumentCollection";
			this.ReadOnlyListClassName = "ReadOnlyCollection";
			this.ReadOnlyDictionaryClassName = "ReadOnlyDictionary";
			this.RawJsonClassName = "IReadOnlyDictionary";
			this.NullableClassName = "Nullable";
		}

		/// <inheritdoc />
		public override void FixClassNames()
		{
			this.Namespace = string.Join(".", (this.Namespace ?? "GameParameters").Split('.').Select(ValidateCSharpIdentifier));
			this.GameDataClassName = ValidateCSharpIdentifier(this.GameDataClassName ?? "GameData");
			this.DocumentClassName = ValidateCSharpIdentifier(this.DocumentClassName ?? "Document");
			this.LocalizedStringClassName = ValidateCSharpIdentifier(this.LocalizedStringClassName ?? "LocalizedString");
			this.DocumentReferenceClassName = ValidateCSharpIdentifier(this.DocumentReferenceClassName ?? "DocumentReference");
			this.DocumentCollectionClassName = ValidateCSharpIdentifier(this.DocumentCollectionClassName ?? "DocumentCollection");
			this.DocumentReferenceListClassName = ValidateCSharpIdentifier(this.DocumentReferenceListClassName ?? "DocumentReferenceCollection");
			this.ReadOnlyListClassName = ValidateCSharpIdentifier(this.ReadOnlyListClassName ?? "ReadOnlyCollection");
			this.ReadOnlyDictionaryClassName = ValidateCSharpIdentifier(this.ReadOnlyDictionaryClassName ?? "ReadOnlyDictionary");
			this.NullableClassName = ValidateCSharpIdentifier(this.NullableClassName?? "Nullable");
		}

		/// <inheritdoc />
		public override string PrepareDescription(string summary)
		{
			{
				if (string.IsNullOrWhiteSpace(summary))
				{
					return null;
				}

				return SecurityElement.Escape(summary)?.Trim('.').Replace("\r", "").Replace("\n", "<para />") ?? "";
			}
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceCollectionTypeRef(ITypeReference idType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentReferenceListClassName, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentCollectionTypeRef(ITypeReference keyType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentCollectionClassName, keyType, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeOptionalTypeRef(ITypeReference valueType)
		{
			if (valueType == null) throw new ArgumentNullException(nameof(valueType));

			if (valueType is NativeTypeReference nativeTypeReference && NativeValueTypes.Contains(nativeTypeReference.TypeName))
			{
				return new GenericTypeReference(this.NullableClassName, valueType);
			}
			return valueType;
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceTypeRef(ITypeReference documentType)
		{
			if (documentType == null) throw new ArgumentNullException(nameof(documentType));

			return new GenericTypeReference(this.DocumentReferenceClassName, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeRawFormulaTypeRef()
		{
			return new GenericTypeReference(this.RawJsonClassName, new NativeTypeReference("string"), new NativeTypeReference("object"));
		}
		/// <inheritdoc />
		public override string MakeTypeName(string typeName)
		{
			if (typeName == null) throw new ArgumentNullException(nameof(typeName));

			return ValidateCSharpIdentifier(MakeDromedaryCaseName(typeName));
		}
		/// <inheritdoc />
		public override string MakeEnumName(string enumName)
		{
			return MakeTypeName(enumName);
		}
		/// <inheritdoc />
		public override string MakeFieldName(string fieldName)
		{
			if (fieldName == null) throw new ArgumentNullException(nameof(fieldName));

			return ValidateCSharpIdentifier("_" + MakePascalCaseIdentifier(fieldName));
		}
		/// <inheritdoc />
		public override string MakePropertyName(string propertyName)
		{
			if (propertyName == null) throw new ArgumentNullException(nameof(propertyName));

			return ValidateCSharpIdentifier(MakeDromedaryCaseName(propertyName));
		}
		/// <inheritdoc />
		public override string MakeFormulaName(string formulaName)
		{
			return MakeTypeName(formulaName);
		}
		/// <inheritdoc />
		public override string MakeMethodParameterName(string parameterName)
		{
			if (parameterName == null) throw new ArgumentNullException(nameof(parameterName));

			return ValidateCSharpIdentifier(MakePascalCaseIdentifier(parameterName));
		}
		/// <inheritdoc />
		public override string MakeEnumLiteralName(string enumLiteralName)
		{
			if (enumLiteralName == null) throw new ArgumentNullException(nameof(enumLiteralName));

			return ValidateCSharpIdentifier(MakeDromedaryCaseName(enumLiteralName));
		}

		/// <inheritdoc />
		public override Dictionary<string, NativeTypeReference> GetNativeTypes()
		{
			var types = new[] {
				typeof(string), typeof(char), typeof(bool), typeof(void), typeof(object), typeof(byte), typeof(sbyte), typeof(short), typeof(ushort),
				typeof(int), typeof(uint), typeof(long), typeof(ulong), typeof(float), typeof(double), typeof(decimal), typeof(TimeSpan), typeof(DateTime)
			};
			var nativeTypes = new Dictionary<string, NativeTypeReference>();
			foreach (var type in types)
			{
				var nativeType = new NativeTypeReference(type.FullName);
				nativeTypes.Add(type.Name, nativeType);
				if (string.IsNullOrEmpty(type.FullName) == false)
				{
					nativeTypes.Add(type.FullName, nativeType);
				}
				if (TryGetAliasFor(type, out var alias))
				{
					nativeTypes.Add(alias, nativeType);
				}
			}

			return nativeTypes;
		}

		private static bool TryGetAliasFor(Type type, out string alias)
		{
			return AliasByType.TryGetValue(type, out alias);
		}
		private static string ValidateCSharpIdentifier(string identifier)
		{
			if (Keywords.Contains(identifier))
			{
				return "@" + identifier;
			}
			else
			{
				return identifier;
			}
		}
	}


	public class DerivedTypeReference : ITypeReference
	{
		private readonly string prefix;
		private readonly string suffix;
		private readonly ITypeReference baseType;

		public string TypeName { get { return this.prefix + this.baseType.TypeName + this.suffix;  } }

		public DerivedTypeReference(string prefix, ITypeReference baseType, string suffix)
		{
			this.prefix = prefix ?? String.Empty;
			this.suffix = suffix ?? String.Empty;
			this.baseType = baseType;
		}

		public override string ToString()
		{
			return this.TypeName;
		}
	}


	public class EnumDefinition : ITypeReference
	{
		public string MergeName { get; }
		public string TypeName { get; set; }
		public string Description { get; set; }
		public string DefaultValueName { get; set; }
		public ITypeReference BaseType { get; set; }
		public bool IsFlags { get; set; }
		public List<KeyValuePair<string, long>> Values { get; }
		public HashSet<SchemaProperty> SchemaProperties { get; }

		public EnumDefinition(SchemaProperty schemaProperty, GenerationTargetLanguage targetLanguage, Func<string, ITypeReference> typeResolver)
		{
			if (targetLanguage == null) throw new ArgumentNullException(nameof(targetLanguage));
			if (typeResolver == null) throw new ArgumentNullException(nameof(typeResolver));
			if (schemaProperty == null) throw new ArgumentNullException(nameof(schemaProperty));

			this.SchemaProperties = new HashSet<SchemaProperty>();
			this.SchemaProperties.Add(schemaProperty);

			var specification = schemaProperty.GetSpecification();

			if (!string.IsNullOrEmpty(specification.CustomTypeName))
			{
				this.TypeName = this.MergeName = specification.CustomTypeName;
			}
			else
			{
				this.TypeName = schemaProperty.DeclaredSchema.Name + schemaProperty.Name;
			}
			this.TypeName = targetLanguage.MakeEnumName(this.TypeName);

			this.IsFlags = schemaProperty.DataType == DataType.MultiPickList;

			this.Values = new List<KeyValuePair<string, long>>();
			var hasDefault = false;
			foreach (var kv in specification.GetPickListValues())
			{
				hasDefault = hasDefault | kv.Value == "0";
				this.DefaultValueName = kv.Key;
			}
			foreach (var kv in specification.GetPickListValues())
			{
				var key = targetLanguage.MakeEnumLiteralName(kv.Key);
				try
				{
					var value = Convert.ToInt64(kv.Value, CultureInfo.InvariantCulture);

					if (this.ContainsKey(key) == false)
					{
						this.Values.Add(new KeyValuePair<string, long>(key, value));
					}
				}
				catch (FormatException fe)
				{
					throw new InvalidOperationException(string.Format("Failed to parse '{1}.{2}' pick list value '{0}' as integer.",
						kv.Value, schemaProperty.DeclaredSchema.Name, schemaProperty.Name), fe);
				}
			}

			if (!hasDefault)
			{
				this.Values.Insert(0, new KeyValuePair<string, long>(targetLanguage.MakeEnumLiteralName("None"),  0L));
				this.DefaultValueName = "None";
			}

			this.Values.Sort(OrderByValue);

			var maxSize = this.SchemaProperties.Max(ea => ea.Size);
			this.BaseType = typeResolver(GetBaseType(maxSize, true));

			this.UpdateDescription();
		}

		public bool ContainsKey(string key)
		{
			if (key == null) throw new ArgumentNullException(nameof(key));

			foreach (var kv in this.Values)
			{
				if (string.Equals(kv.Key, key, StringComparison.Ordinal))
				{
					return true;
				}
			}
			return false;
		}

		public void MergeWith(EnumDefinition otherDefinition, Func<string, ITypeReference> typeResolver)
		{
			if (otherDefinition == null) throw new ArgumentNullException(nameof(otherDefinition));
			if (typeResolver == null) throw new ArgumentNullException(nameof(typeResolver));

			foreach (var schemaProperty in otherDefinition.SchemaProperties)
			{
				this.SchemaProperties.Add(schemaProperty);
			}

			foreach (var kv in otherDefinition.Values)
			{
				if (this.ContainsKey(kv.Key) == false)
				{
					this.Values.Add(kv);
				}
			}

			this.IsFlags = this.IsFlags || otherDefinition.IsFlags;

			if (Equals(this.BaseType, otherDefinition.BaseType) == false)
			{
				// determine new size and change base type accordingly
				var maxSize = this.SchemaProperties.Max(ea => ea.Size);
				this.BaseType = typeResolver(GetBaseType(maxSize, true));

				// convert values to new type
				var valueType = typeof(long);
				for (var index = 0; index < this.Values.Count; index++)
				{
					var key = this.Values[index].Key;
					var value = Convert.ToInt64(this.Values[index].Value, CultureInfo.InvariantCulture);
					this.Values[index] = new KeyValuePair<string, long>(key, value);
				}
			}

			this.Values.Sort(OrderByValue);

			this.UpdateDescription();
		}

		private void UpdateDescription()
		{
			this.Description = $"Enumeration based on {this.BaseType}. " +
				(this.DefaultValueName != "None" ? $"Default Value: {this.DefaultValueName} - 0, " : "") +
				(this.IsFlags ? "Flags, " : "") +
				$"Used in Schemas: {string.Join(", ", this.SchemaProperties.Select(property => property.DeclaredSchema.Name).Distinct())}.";
		}

		private static  int OrderByValue(KeyValuePair<string, long> x, KeyValuePair<string, long> y)
		{
			return x.Value.CompareTo(y.Value);
		}

		private static string GetBaseType(int size, bool signed)
		{
			var newType = string.Empty;
			switch (size)
			{
				case 1: newType = signed ? typeof(sbyte).Name : typeof(byte).Name; break;
				case 2: newType = signed ? typeof(short).Name : typeof(ushort).Name; break;
				case 3:
				case 4: newType = signed ? typeof(int).Name : typeof(uint).Name; break;
				default: newType = signed ? typeof(long).Name : typeof(ulong).Name; break;
			}
			return newType;
		}

		public override string ToString()
		{
			return this.TypeName;
		}
	}


	public class ExternalTypeReference : ITypeReference
	{
		public string TypeName { get; private set; }

		public ExternalTypeReference(string typeName)
		{
			this.TypeName = typeName;
		}

		public override string ToString()
		{
			return this.TypeName;
		}
	}


	public class FormulaDefinition : ITypeReference
	{
		public string Name { get; set; }
		public string TypeName { get; set; }
		public string Description { get; set; }
		public ITypeReference ContextThisType { get; set; }
		public ITypeReference ContextType { get; set; }
		public string[] ParameterNames { get; set; }
		public ITypeReference[] ParameterTypes { get; set; }
		public ITypeReference ReturnType { get; set; }
		public ITypeReference[] KnownTypes { get; set; }
		public SpecificationDictionary Specification { get; }
		public SchemaProperty SchemaProperty { get; }

		public FormulaDefinition(SchemaProperty schemaProperty, GenerationTargetLanguage targetLanguage, Func<string, ITypeReference> typeResolver)
		{
			if (schemaProperty == null) throw new ArgumentNullException(nameof(schemaProperty));
			if (targetLanguage == null) throw new ArgumentNullException(nameof(targetLanguage));
			if (typeResolver == null) throw new ArgumentNullException(nameof(typeResolver));

			this.SchemaProperty = schemaProperty;
			this.Specification = this.SchemaProperty.GetSpecification();
			this.Name = this.Specification.CustomTypeName;

			if (string.IsNullOrEmpty(this.Specification.CustomTypeName))
			{
				this.TypeName = this.SchemaProperty.DeclaredSchema.Name + this.SchemaProperty.Name + GenerationConstants.FORMULA_SUFFIX;
			}
			else
			{
				this.TypeName = this.Specification.CustomTypeName;
			}
			this.TypeName = targetLanguage.MakeFormulaName(this.TypeName);

			var declaredSchemaTypeRef = typeResolver(this.SchemaProperty.DeclaredSchema.Id);
			this.ContextThisType = declaredSchemaTypeRef;
			this.ContextType = new DerivedTypeReference(string.Empty, this, GenerationConstants.FORMULA_SCOPE_SUFFIX);
			this.ReturnType = typeResolver(this.Specification.GetFormulaResultType() ?? "void");
			this.KnownTypes = this.Specification.GetKnownTypes().Select(typeResolver).ToArray();
			var parameters = this.Specification.GetFormulaParameters();
			this.ParameterNames = new string[parameters.Count];
			this.ParameterTypes = new ITypeReference[parameters.Count];;

			for(var index = 0; index < parameters.Count; index++)
			{
				this.ParameterNames[index] = targetLanguage.MakeMethodParameterName(parameters[index].Key);
				this.ParameterTypes[index] = typeResolver(parameters[index].Value);
			}

			this.Description = $"Formula Signature: ({string.Join(", ", parameters.Select(parameter => parameter.Value + " " + parameter.Key))}) -> {(this.Specification.GetFormulaResultType() ?? "void")}";
		}

		public IReadOnlyList<ITypeReference> GetReferenceTypes()
		{
			var result = new List<ITypeReference>();
			result.AddRange(this.ParameterTypes);
			result.AddRange(this.KnownTypes);
			result.Add(this.ReturnType);
			result.Add(this.ContextThisType);

			for (var index = 0; index < result.Count; index++)
			{
				result[index] = TypeReference.Resolve(result[index]); // unwrap lazy types refs
			}

			// remove all native types
			result.RemoveAll(typeRef => !(typeRef is TypeDefinition) &&
				!(typeRef is EnumDefinition) &&
				!(typeRef is FormulaDefinition));

			return result.Distinct(TypeReference.TypeNameEqualityComparer).ToList();
		}
		public IReadOnlyList<ITypeReference> GetReferencedExternalTypes()
		{
			var result = new List<ITypeReference>();
			result.AddRange(this.ParameterTypes);
			result.AddRange(this.KnownTypes);
			result.Add(this.ReturnType);
			result.Add(this.ContextThisType);

			for (var index = 0; index < result.Count; index++)
			{
				result[index] = TypeReference.Resolve(result[index]); // unwrap lazy types refs
			}

			// remove all native types
			result.RemoveAll(typeRef => !(typeRef is ExternalTypeReference));

			return result.Distinct(TypeReference.TypeNameEqualityComparer).ToList();
		}


		public override string ToString()
		{
			return this.TypeName;
		}
	}


	public class GenerationConstants
	{
		public const string FORMULA_SUFFIX = "Formula";
		public const string FORMULA_SCOPE_SUFFIX = "Scope";
		public const string KNOWN_SCHEMA_PROJECT_SETTINGS = "ProjectSettings";
		public const string KNOWN_SCHEMA_PROPERTY_ID = "Id";
	}


	public abstract class GenerationTargetLanguage
	{
		public string Namespace { get; set; }
		public string GameDataClassName { get; set; }
		public string DocumentClassName { get; set; }
		public string LocalizedStringClassName { get; set; }
		public string DocumentReferenceClassName { get; set; }
		public string DocumentReferenceListClassName { get; set; }
		public string DocumentCollectionClassName { get; set; }
		public string ReadOnlyListClassName { get; set; }
		public string ReadOnlyDictionaryClassName { get; set; }
		public string NullableClassName { get; set; }

		protected static string MakePascalCaseIdentifier(string value)
		{
			if (string.IsNullOrEmpty(value)) throw new ArgumentException("Type name can't be null or empty string.", nameof(value));

			var sb = new StringBuilder(value);
			var nextToLower = true;
			var nextToUpper = false;
			for (var i = 0; i < sb.Length; i++)
			{
				if (sb[i] == '_')
				{
					sb.Remove(i, 1);
					i--;
					nextToUpper = !nextToLower;
					continue;
				}

				if (char.IsLetterOrDigit(sb[i]) == false)
				{
					sb[i] = '_';
				}
				else if (char.IsLetter(sb[i]) && nextToLower)
				{
					sb[i] = char.ToLowerInvariant(sb[i]);
					nextToLower = false;
				}
				else if (char.IsLetter(sb[i]) && nextToUpper)
				{
					sb[i] = char.ToUpperInvariant(sb[i]);
					nextToUpper = false;
				}
			}

			if (sb.Length == 0 || char.IsDigit(sb[0]))
			{
				sb.Insert(0, '_');
			}
			return sb.ToString();
		}
		protected static string MakeDromedaryCaseName(string value)
		{
			if (string.IsNullOrEmpty(value)) throw new ArgumentException("Type name can't be null or empty string.", nameof(value));

			var sb = new StringBuilder(value);
			var index = 0;
			var nextToUpper = true;
			while (index < sb.Length && char.IsLetter(sb[index]) == false)
			{
				index++;
			}

			for (; index < sb.Length; index++)
			{
				if (sb[index] == '_')
				{
					sb.Remove(index, 1);
					index--;
					nextToUpper = true;
					continue;
				}

				if (char.IsLetterOrDigit(sb[index]) == false)
				{
					sb[index] = '_';
				}
				else if (char.IsLetter(sb[index]) && nextToUpper)
				{
					sb[index] = char.ToUpperInvariant(sb[index]);
					nextToUpper = false;
				}
			}

			if (sb.Length == 0 || char.IsDigit(sb[0]))
			{
				sb.Insert(0, '_');
			}

			var name = sb.ToString();
			return name;
		}

		public abstract Dictionary<string, NativeTypeReference> GetNativeTypes();

		public abstract ITypeReference MakeDocumentCollectionTypeRef(ITypeReference keyType, ITypeReference documentType);
		public abstract ITypeReference MakeDocumentReferenceCollectionTypeRef(ITypeReference idType, ITypeReference documentType);
		public abstract ITypeReference MakeDocumentReferenceTypeRef(ITypeReference documentType);
		public abstract ITypeReference MakeOptionalTypeRef(ITypeReference valueType);
		public abstract ITypeReference MakeRawFormulaTypeRef();

		public abstract void FixClassNames();
		public abstract string PrepareDescription(string summary);
		public abstract string MakeTypeName(string typeName);
		public abstract string MakeEnumName(string enumName);
		public abstract string MakeFieldName(string fieldName);
		public abstract string MakePropertyName(string propertyName);
		public abstract string MakeFormulaName(string formulaName);
		public abstract string MakeMethodParameterName(string parameterName);
		public abstract string MakeEnumLiteralName(string enumLiteralName);

		public virtual string MakePlural(string name)
		{
			if (name == null) throw new ArgumentNullException(nameof(name));

			return Pluralizer.Pluralize(name);
		}
		public virtual string MakeSingular(string name)
		{
			if (name == null) throw new ArgumentNullException(nameof(name));

			return Pluralizer.Singularize(name);
		}
		public virtual string FormatEnumDisplayString(object enumValue)
		{
			var stringValue = new StringBuilder(enumValue?.ToString() ?? string.Empty);

			var prevWasLowercase = false;
			for (var i = 0; i < stringValue.Length; i++)
			{
				if (prevWasLowercase && char.IsUpper(stringValue[i]))
				{
					stringValue.Insert(i++, ' ');
					prevWasLowercase = false;
				}
				else
				{
					prevWasLowercase = !char.IsUpper(stringValue[i]);
				}
			}
			return stringValue.ToString();
		}
	}


	public sealed class GenericTypeReference : ITypeReference
	{
		public string TypeName
		{
			get
			{
				if (this.GenericArguments.Length > 0)
				{
					return this.Definition.TypeName + "<" + string.Join(",", Array.ConvertAll(this.GenericArguments, a => a.TypeName)) + ">";
				}
				else
				{
					return this.Definition.TypeName;
				}
			}
		}
		public ITypeReference Definition { get; private  set; }
		public ITypeReference[] GenericArguments { get; private  set; }

		public GenericTypeReference(string typeName, params ITypeReference[] genericArguments)
			:this(new NativeTypeReference(typeName), genericArguments)
		{

		}
		public GenericTypeReference(ITypeReference definition, params ITypeReference[] genericArguments)
		{
			this.Definition = definition;
			this.GenericArguments = genericArguments ?? new ITypeReference[0];
		}

		public override string ToString()
		{
			return this.TypeName;
		}
	}


	public interface ITypeReference
	{
		string TypeName { get; }
	}


	[DebuggerDisplay("{typeName}")]
	public class LazyTypeReference : ITypeReference
	{
		private readonly  string typeName;
		private readonly TypeResolveFn resolveActualTypeFunc;

		public string TypeName => this.resolveActualTypeFunc(this.typeName).TypeName;

		public ITypeReference Resolve()
		{
			return this.resolveActualTypeFunc(this.typeName);
		}

		public LazyTypeReference(string typeName, TypeResolveFn resolveActualTypeFunc)
		{
			this.typeName = typeName;
			this.resolveActualTypeFunc = resolveActualTypeFunc;
		}

		public override bool Equals(object otherType)
		{
			if (otherType == null || otherType is LazyTypeReference == false)
			{
				return false;
			}
			return this.typeName.Equals(((LazyTypeReference)otherType).typeName, StringComparison.Ordinal);
		}
		public override int GetHashCode()
		{
			return this.typeName.GetHashCode();
		}

		public override string ToString()
		{
			return this.TypeName;
		}
	}


	public class NativeTypeReference : ITypeReference
	{
		public string TypeName { get; private set; }

		public NativeTypeReference(string typeName)
		{
			this.TypeName = typeName;
		}

		public override string ToString()
		{
			return this.TypeName;
		}
	}


	public class NullTypeReference : ITypeReference
	{
		public static readonly NullTypeReference Instance = new NullTypeReference();

		/// <inheritdoc />
		public string TypeName => "null";
	}


	public class OrTypeReference : ITypeReference
	{
		private readonly List<ITypeReference> types;

		/// <inheritdoc />
		public string TypeName => this.ToString();

		public OrTypeReference(params ITypeReference[] types)
		{
			if (types == null) throw new ArgumentNullException(nameof(types));

			this.types = new List<ITypeReference>();
			foreach (var type in types)
			{
				if (this.types.Contains(type))
				{
					continue;
				}
				else if (type is OrTypeReference orTypeReference)
				{
					foreach (var subType in orTypeReference.types)
					{
						if (this.types.Contains(subType))
						{
							continue;
						}
						this.types.Add(subType);
					}
				}
				this.types.Add(type);
			}
		}

		/// <inheritdoc />
		public override string ToString()
		{
			return string.Join("|", this.types.Select(type => type.TypeName));
		}
	}


	//Copyright (c) 2011, Brendan Erwin and contributors. All rights reserved.

	//	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	//	Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	//	Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	//	The names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

	//THIS SOFTWARE IS PROVIDED BY Brendan Erwin and contributors ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL Brendan Erwin or contributors BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

	public static class Pluralizer
	{
		private static readonly EnglishInflector inflector = new EnglishInflector();

		public static string Pluralize(string value)
		{
			return inflector.Pluralize(value);
		}

		public static string Singularize(string value)
		{
			return inflector.Singularize(value);
		}

		private class NounsRule : IEquatable<NounsRule>
		{
			private readonly int hashCode;
			private readonly string pattern;
			private readonly Regex regex;
			private readonly string replacement;

			public NounsRule(string pattern, string replacement)
			{
				if (string.IsNullOrEmpty(pattern))
					throw new ArgumentNullException(nameof(pattern));
				if (replacement == null)
					throw new ArgumentNullException(nameof(replacement));
				this.pattern = pattern;
				this.replacement = replacement;
				this.hashCode = 397 ^ this.replacement.GetHashCode() ^ this.pattern.GetHashCode();
				this.regex = this.CreateRegex();
			}
			public bool Equals(NounsRule other)
			{
				if (ReferenceEquals(null, other))
					return false;
				if (ReferenceEquals(this, other))
					return true;
				return Equals(other.pattern, this.pattern) && Equals(other.replacement, this.replacement);
			}
			public override bool Equals(object obj)
			{
				return this.Equals(obj as NounsRule);
			}
			public override int GetHashCode()
			{
				return this.hashCode;
			}
			private Regex CreateRegex()
			{
				return new Regex(this.pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
			}
			public string Apply(string word)
			{
				if (!this.regex.IsMatch(word))
					return null;

				return this.regex.Replace(word, this.replacement);
			}
		}
		private sealed class EnglishInflector
		{
			private readonly List<NounsRule> plurals = new List<NounsRule>();
			private readonly List<NounsRule> singulars = new List<NounsRule>();
			private readonly HashSet<string> uncountables = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			public EnglishInflector()
			{
				this.AddPlural("$", "s");
				this.AddPlural("s$", "s");
				this.AddPlural("(ax|test)is$", "$1es");
				this.AddPlural("(octop|vir)us$", "$1i");
				this.AddPlural("(alias|status)$", "$1es");
				this.AddPlural("(bu)s$", "$1ses");
				this.AddPlural("(buffal|tomat)o$", "$1oes");
				this.AddPlural("([ti])um$", "$1a");
				this.AddPlural("sis$", "ses");
				this.AddPlural("(?:([^f])fe|([lr])f)$", "$1$2ves");
				this.AddPlural("(hive)$", "$1s");
				this.AddPlural("([^aeiouy]|qu)y$", "$1ies");
				this.AddPlural("(x|ch|ss|sh)$", "$1es");
				this.AddPlural("(matr|vert|ind)ix|ex$", "$1ices");
				this.AddPlural("([m|l])ouse$", "$1ice");
				this.AddPlural("^(ox)$", "$1en");
				this.AddPlural("(quiz)$", "$1zes");

				this.AddSingular("s$", "");
				this.AddSingular("(n)ews$", "$1ews");
				this.AddSingular("([ti])a$", "$1um");
				this.AddSingular("((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$", "$1$2sis");
				this.AddSingular("(^analy)ses$", "$1sis");
				this.AddSingular("([^f])ves$", "$1fe");
				this.AddSingular("(hive)s$", "$1");
				this.AddSingular("(tive)s$", "$1");
				this.AddSingular("([lr])ves$", "$1f");
				this.AddSingular("([^aeiouy]|qu)ies$", "$1y");
				this.AddSingular("(s)eries$", "$1eries");
				this.AddSingular("(m)ovies$", "$1ovie");
				this.AddSingular("(x|ch|ss|sh)es$", "$1");
				this.AddSingular("([m|l])ice$", "$1ouse");
				this.AddSingular("(bus)es$", "$1");
				this.AddSingular("(o)es$", "$1");
				this.AddSingular("(shoe)s$", "$1");
				this.AddSingular("(cris|ax|test)es$", "$1is");
				this.AddSingular("(octop|vir)i$", "$1us");
				this.AddSingular("(alias|status)es$", "$1");
				this.AddSingular("^(ox)en", "$1");
				this.AddSingular("(vert|ind)ices$", "$1ex");
				this.AddSingular("(matr)ices$", "$1ix");
				this.AddSingular("(quiz)zes$", "$1");

				this.AddIrregular("person", "people");
				this.AddIrregular("man", "men");
				this.AddIrregular("child", "children");
				this.AddIrregular("sex", "sexes");
				this.AddIrregular("move", "moves");

				this.AddUncountable("equipment");
				this.AddUncountable("information");
				this.AddUncountable("rice");
				this.AddUncountable("money");
				this.AddUncountable("species");
				this.AddUncountable("series");
				this.AddUncountable("fish");
				this.AddUncountable("sheep");
			}
			private string ApplyFirstMatchRule(IEnumerable<NounsRule> rules, string word)
			{
				var result = word;
				if (this.uncountables.Contains(word)) return result;
				foreach (var rule in rules.Reverse())
				{
					result = rule.Apply(word);
					if (result != null)
					{
						break;
					}
				}
				return result ?? word;
			}
			private void AddIrregular(string singular, string plural)
			{
				this.AddPlural("(" + singular[0] + ")" + singular.Substring(1) + "$", "$1" + plural.Substring(1));
				this.AddSingular("(" + plural[0] + ")" + plural.Substring(1) + "$", "$1" + singular.Substring(1));
			}
			private void AddUncountable(string word)
			{
				this.uncountables.Add(word);
			}
			private void AddPlural(string rule, string replacement)
			{
				this.plurals.Add(new NounsRule(rule, replacement));
			}
			private void AddSingular(string rule, string replacement)
			{
				this.singulars.Add(new NounsRule(rule, replacement));
			}
			public string Pluralize(string word)
			{
				return this.ApplyFirstMatchRule(this.plurals, word);
			}
			public string Singularize(string word)
			{
				return this.ApplyFirstMatchRule(this.singulars, word);
			}
		}
	}


	public class TypeDefinition : ITypeReference
	{
		public string TypeName { get; set; }
		public ITypeReference CollectionType { get; set; }
		public string CollectionName { get; set; }
		public string CollectionFieldName { get; set; }
		public string SettingsName { get; set; }
		public string DisplayName => this.Schema.DisplayName;
		public string Description { get; set; }

		public List<TypePropertyDefinition> Properties { get; }
		public TypePropertyDefinition IdMember { get; set; }
		public List<TypePropertyDefinition> UniqueMembers { get; }
		public SpecificationDictionary Specification { get; }
		public Schema Schema { get; }
		public bool IsSettings => this.Schema.Type == SchemaType.Settings;

		public TypeDefinition(Schema schema, GenerationTargetLanguage targetLanguage, Func<string, ITypeReference> typeResolver)
		{
			if (schema == null) throw new ArgumentNullException(nameof(schema));
			if (targetLanguage == null) throw new ArgumentNullException(nameof(targetLanguage));
			if (typeResolver == null) throw new ArgumentNullException(nameof(typeResolver));

			this.TypeName = targetLanguage.MakeTypeName(targetLanguage.MakeSingular(schema.Name));
			this.CollectionName = targetLanguage.MakePropertyName(targetLanguage.MakePlural(schema.Name));
			this.SettingsName = targetLanguage.MakePropertyName(targetLanguage.MakeSingular(schema.Name));
			this.CollectionFieldName = targetLanguage.MakePropertyName(this.CollectionName);
			this.Schema = schema;
			this.Description = targetLanguage.PrepareDescription(schema.Description);
			this.Specification = schema.GetSpecification();

			this.Properties = new List<TypePropertyDefinition>();
			this.UniqueMembers = new List<TypePropertyDefinition>();
			foreach (var schemaProperty in this.Schema.Properties)
			{
				var memberDefinition = new TypePropertyDefinition(this, schemaProperty, targetLanguage, typeResolver);
				if (schemaProperty.Name == GenerationConstants.KNOWN_SCHEMA_PROPERTY_ID)
				{
					this.IdMember = memberDefinition;
				}
				if (schemaProperty.Uniqueness != Uniqueness.None)
				{
					this.UniqueMembers.Add(memberDefinition);
				}
				this.Properties.Add(memberDefinition);
			}

			System.Diagnostics.Debug.Assert(this.IdMember != null, "this.IdMember != null");

			this.CollectionType = targetLanguage.MakeDocumentCollectionTypeRef(this.IdMember.Type, this);

			if (string.IsNullOrEmpty(this.Description))
			{
				this.Description = $"{this.DisplayName} with {this.IdMember.SchemaProperty.DataType} id.";
			}
			this.Description = this.Description.Trim();
			if (!this.Description.EndsWith(".")) { this.Description += "."; }

			this.Description +=
				(this.UniqueMembers.Count > 1 ? $" Unique Properties: {string.Join(", ", this.UniqueMembers.Select(member => member.Name))}," : string.Empty) +
				(this.IsSettings ? " Settings," : "");
			this.Description = this.Description.TrimEnd(new[] { ',', '.' }) + ".";
		}

		public IReadOnlyList<ITypeReference> GetReferenceTypes()
		{
			var result = new List<ITypeReference>();
			result.AddRange(this.Properties.Select(property => property.DocumentOrReferenceType ?? property.StorageType));
			for (var index = 0; index < result.Count; index++)
			{
				result[index] = TypeReference.Resolve(result[index]); // unwrap lazy types refs
			}

			// remove all native and external types
			result.RemoveAll(typeRef => !(typeRef is TypeDefinition) &&
				!(typeRef is EnumDefinition) &&
				!(typeRef is FormulaDefinition));

			return result.Distinct(TypeReference.TypeNameEqualityComparer).ToList();
		}

		public override string ToString()
		{
			return this.TypeName;
		}
	}


	public class TypeMemberDefinition
	{
		public string Name { get; set; }
		public ITypeReference Type { get; set; }

		public TypeMemberDefinition(string name, ITypeReference typeReference)
		{
			if (name == null) throw new ArgumentNullException(nameof(name));
			if (typeReference == null) throw new ArgumentNullException(nameof(typeReference));
			if (string.IsNullOrEmpty(name)) throw new ArgumentException("Value cannot be null or empty.", nameof(name));

			this.Name = name;
			this.Type = typeReference;
		}
	}


	public class TypePropertyDefinition : TypeMemberDefinition
	{
		public string DisplayName { get { return this.SchemaProperty.DisplayName; } }
		public string Description { get; set; }
		public int Ordinal { get; set; }
		public DataType DataType { get { return this.SchemaProperty.DataType; } }
		public Requirement Requirement { get { return this.SchemaProperty.Requirement; } }

		public ITypeReference DocumentOrReferenceType { get; set; }
		public ITypeReference TypeAfterDereference { get; set; }
		public ITypeReference DocumentCollectionType { get; set; }
		public ITypeReference StorageType { get; set; }
		public TypeMemberDefinition BackingField { get; set; }
		public TypeMemberDefinition MethodParameter { get; set; }

		public SpecificationDictionary Specification { get; }
		public SchemaProperty SchemaProperty { get; private set; }

		public TypePropertyDefinition
		(
			TypeDefinition typeDef,
			SchemaProperty schemaProperty,
			GenerationTargetLanguage targetLanguage,
			Func<string, ITypeReference> typeResolver)
			: base(targetLanguage.MakePropertyName(schemaProperty.Name),
				GetPropertyType(schemaProperty, targetLanguage, typeResolver))
		{
			if (typeDef == null) throw new ArgumentNullException(nameof(typeDef));
			if (schemaProperty == null) throw new ArgumentNullException(nameof(schemaProperty));
			if (targetLanguage == null) throw new ArgumentNullException(nameof(targetLanguage));
			if (typeResolver == null) throw new ArgumentNullException(nameof(typeResolver));


			this.Ordinal = schemaProperty.DeclaredSchema.Properties.IndexOf(schemaProperty) + 1;
			this.StorageType = this.Type;
			this.SchemaProperty = schemaProperty;
			this.Description = targetLanguage.PrepareDescription(schemaProperty.Description);
			this.Specification = this.SchemaProperty.GetSpecification();
			this.Name = targetLanguage.MakePropertyName(this.SchemaProperty.Name);

			if (schemaProperty.ReferenceType != null)
			{
				this.DocumentOrReferenceType = typeResolver(schemaProperty.ReferenceType.Id);
			}

			if (this.DataType == DataType.Reference)
			{
				this.TypeAfterDereference = this.DocumentOrReferenceType;
			}
			else if (this.DataType == DataType.ReferenceCollection)
			{
				var idTypeRef = GetPropertyType(schemaProperty.ReferenceType?.Schema.GetIdProperty(), targetLanguage, typeResolver);
				this.TypeAfterDereference = targetLanguage.MakeDocumentCollectionTypeRef(idTypeRef, this.DocumentOrReferenceType);
			}

			if (IsOptional(schemaProperty.Requirement, schemaProperty.DataType))
			{
				this.Type = targetLanguage.MakeOptionalTypeRef(this.Type);

				if (this.TypeAfterDereference != null)
				{
					this.TypeAfterDereference = targetLanguage.MakeOptionalTypeRef(this.TypeAfterDereference);
				}
			}

			this.BackingField = new TypeMemberDefinition(targetLanguage.MakeFieldName(this.Name), this.Type);
			this.MethodParameter = new TypeMemberDefinition(targetLanguage.MakeMethodParameterName(this.Name), this.Type);
			this.DocumentCollectionType = targetLanguage.MakeDocumentCollectionTypeRef(this.Type, typeDef);

			if (string.IsNullOrWhiteSpace(this.Description))
			{
				this.Description = $"{this.DisplayName} property of {targetLanguage.FormatEnumDisplayString(this.SchemaProperty.DataType)} type.";
			}
			this.Description = this.Description.Trim();
			if (!this.Description.EndsWith(".")) { this.Description += "."; }
			this.Description +=
				(this.Requirement == Requirement.None ? " Can Be Null," : $" {targetLanguage.FormatEnumDisplayString(this.Requirement)},") +
				(this.SchemaProperty.Uniqueness != Uniqueness.None ? " Unique," : string.Empty);
			this.Description = this.Description.TrimEnd(new[] { ',', '.' }) + ".";
		}

		private static ITypeReference GetPropertyType
		(
			SchemaProperty schemaProperty,
			GenerationTargetLanguage targetLanguage,
			Func<string, ITypeReference> typeResolver)
		{
			if (schemaProperty == null) throw new ArgumentNullException(nameof(schemaProperty));
			if (targetLanguage == null) throw new ArgumentNullException(nameof(targetLanguage));
			if (typeResolver == null) throw new ArgumentNullException(nameof(typeResolver));

			var type = default(ITypeReference);
			switch (schemaProperty.DataType)
			{
				case DataType.Logical:
				case DataType.Text:
				case DataType.Time:
				case DataType.Date:
				case DataType.Number:
				case DataType.Integer:
					type = typeResolver(schemaProperty.GetPropertyValueType().Name);
					break;
				case DataType.MultiPickList:
				case DataType.PickList:
					type = typeResolver(schemaProperty.Id); // will resolve EnumDefinition by this id
					break;
				case DataType.LocalizedText:
					type = new NativeTypeReference(targetLanguage.LocalizedStringClassName);
					break;
				case DataType.Document:
					type = typeResolver(schemaProperty.ReferenceType.Id); // will resolve TypeDefinition by this id
					break;
				case DataType.DocumentCollection:
					var idTypeRef = GetPropertyType(schemaProperty.ReferenceType.Schema.GetIdProperty(), targetLanguage, typeResolver);
					type = targetLanguage.MakeDocumentCollectionTypeRef(idTypeRef, typeResolver(schemaProperty.ReferenceType.Id));
					break;
				case DataType.Reference:
					type = targetLanguage.MakeDocumentReferenceTypeRef(typeResolver(schemaProperty.ReferenceType.Id));
					break;
				case DataType.ReferenceCollection:
					var refIdTypeRef = GetPropertyType(schemaProperty.ReferenceType.Schema.GetIdProperty(), targetLanguage, typeResolver);
					type = targetLanguage.MakeDocumentReferenceCollectionTypeRef(refIdTypeRef, typeResolver(schemaProperty.ReferenceType.Id));
					break;
				case DataType.Formula:
					if (schemaProperty.IsRawFormulaType)
					{
						type = targetLanguage.MakeRawFormulaTypeRef();
					}
					else
					{
						type = typeResolver(schemaProperty.Id); // will resolve FormulaDefinition by this id
					}

					break;
				default:
					throw new InvalidOperationException($"Unknown property data type {schemaProperty.DataType}.");
			}

			return type;
		}

		private static bool IsOptional(Requirement requirement, DataType dataType)
		{
			return requirement == Requirement.None &&
				dataType != DataType.DocumentCollection &&
				dataType != DataType.ReferenceCollection &&
				dataType != DataType.LocalizedText;
		}
	}


	public static class TypeReference
	{
		public static readonly IComparer<ITypeReference> TypeNameComparer = new TypeReferenceComparer();
		public static readonly IEqualityComparer<ITypeReference> TypeNameEqualityComparer = new TypeReferenceEqualityComparer();

		public static ITypeReference Resolve(ITypeReference typeReference)
		{
			while (typeReference is LazyTypeReference lazyTypeReference)
			{
				typeReference = lazyTypeReference.Resolve();
			}
			return typeReference;
		}

		private class TypeReferenceComparer : IComparer<ITypeReference>
		{
			public int Compare(ITypeReference x, ITypeReference y)
			{
				if (ReferenceEquals(x, y)) return 0;
				if (ReferenceEquals(null, y)) return 1;
				if (ReferenceEquals(null, x)) return -1;

				return string.Compare(x.TypeName, y.TypeName, StringComparison.Ordinal);
			}
		}
		private class TypeReferenceEqualityComparer : IEqualityComparer<ITypeReference>
		{
			public bool Equals(ITypeReference x, ITypeReference y)
			{
				if (ReferenceEquals(x, y)) return true;
				if (ReferenceEquals(x, null)) return false;
				if (ReferenceEquals(y, null)) return false;
				if (x.GetType() != y.GetType()) return false;

				return string.Equals(x.TypeName, y.TypeName, StringComparison.Ordinal);
			}
			public int GetHashCode(ITypeReference obj)
			{
				return (obj.TypeName != null ? obj.TypeName.GetHashCode() : 0);
			}
		}
	}


	public delegate ITypeReference TypeResolveFn(string typeName);


	public class TypeScriptLanguage : GenerationTargetLanguage
	{
		private static readonly HashSet<string> Keywords = new HashSet<string>(new string[] {
			"break", "case", "catch", "class", "const", "continue", "debugger", "default",
			"delete", "do", "else", "enum", "export", "extends", "false", "finally", "for",
			"function", "if", "import", "in", "instanceof", "new", "null", "return", "super",
			"switch", "this", "throw", "true", "try", "typeof", "var", "void", "while", "with",
			"as", "implements", "interface", "let", "package", "private", "protected", "public",
			"static", "yield", "any", "boolean", "constructor", "declare", "get", "module", "require",
			"number", "set", "string", "symbol", "type", "from", "of",
		});
		private static readonly HashSet<string> KnownTypes = new HashSet<string>(new string[] {
			"Map", "Set", "Document", "Window", "String", "Number", "Boolean", "Date",
			"TimeSpan", "Math", "Object", "Function", "Bigint", "Symbol", "Array", "RegExp", "Error",
		});
		private static readonly NativeTypeReference AnyType = new NativeTypeReference("any");

		public TypeScriptLanguage()
		{
			this.Namespace = "GameParameters";
			this.GameDataClassName = "GameData";
			this.DocumentClassName = "GameDataDocument";
			this.LocalizedStringClassName = "LocalizedString";
			this.DocumentReferenceClassName = "DocumentReference";
			this.DocumentReferenceListClassName = "DocumentReferenceCollection";
			this.DocumentCollectionClassName = "DocumentCollection";
			this.ReadOnlyListClassName = "ReadOnlyArray";
			this.ReadOnlyDictionaryClassName = "ReadOnlyMap";
			this.NullableClassName = "Nullable";
		}

		/// <inheritdoc />
		public override void FixClassNames()
		{
			this.Namespace = string.Join(".", (this.Namespace ?? "GameParameters").Split('.').Select(ValidateTypeScriptIdentifier));
			this.GameDataClassName = ValidateTypeScriptIdentifier(this.GameDataClassName ?? "GameData");
			this.DocumentClassName = ValidateTypeScriptIdentifier(this.DocumentClassName ?? "GameDataDocument");
			this.LocalizedStringClassName = ValidateTypeScriptIdentifier(this.LocalizedStringClassName ?? "LocalizedString");
			this.DocumentReferenceClassName = ValidateTypeScriptIdentifier(this.DocumentReferenceClassName ?? "DocumentReference");
			this.DocumentCollectionClassName = ValidateTypeScriptIdentifier(this.DocumentCollectionClassName ?? "DocumentCollection");
			this.DocumentReferenceListClassName = ValidateTypeScriptIdentifier(this.DocumentReferenceListClassName ?? "DocumentReferenceCollection");
			this.ReadOnlyListClassName = ValidateTypeScriptIdentifier(this.ReadOnlyListClassName ?? "ReadOnlyArray");
			this.ReadOnlyDictionaryClassName = ValidateTypeScriptIdentifier(this.ReadOnlyDictionaryClassName ?? "ReadOnlyMap");
			this.NullableClassName = ValidateTypeScriptIdentifier(this.NullableClassName?? "Nullable");
		}

		/// <inheritdoc />
		public override string PrepareDescription(string summary)
		{
			{
				if (string.IsNullOrWhiteSpace(summary))
				{
					return null;
				}

				return SecurityElement.Escape(summary)?.Trim('.').Replace("\r", "").Replace("\n", "<br />") ?? "";
			}
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceCollectionTypeRef(ITypeReference idType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentReferenceListClassName, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentCollectionTypeRef(ITypeReference keyType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentCollectionClassName, keyType, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeOptionalTypeRef(ITypeReference valueType)
		{
			if (valueType == null) throw new ArgumentNullException(nameof(valueType));

			return new OrTypeReference(valueType, NullTypeReference.Instance);
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceTypeRef(ITypeReference documentType)
		{
			if (documentType == null) throw new ArgumentNullException(nameof(documentType));

			return new GenericTypeReference(this.DocumentReferenceClassName, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeRawFormulaTypeRef()
		{
			return AnyType;
		}
		/// <inheritdoc />
		public override string MakeTypeName(string typeName)
		{
			if (typeName == null) throw new ArgumentNullException(nameof(typeName));

			return ValidateTypeScriptTypeName(MakeDromedaryCaseName(typeName));
		}
		/// <inheritdoc />
		public override string MakeEnumName(string enumName)
		{
			return MakeTypeName(enumName);
		}
		/// <inheritdoc />
		public override string MakeFieldName(string fieldName)
		{
			if (fieldName == null) throw new ArgumentNullException(nameof(fieldName));

			return ValidateTypeScriptIdentifier("_" + MakePascalCaseIdentifier(fieldName));
		}
		/// <inheritdoc />
		public override string MakePropertyName(string propertyName)
		{
			if (propertyName == null) throw new ArgumentNullException(nameof(propertyName));

			return ValidateTypeScriptIdentifier(MakePascalCaseIdentifier(propertyName));
		}
		/// <inheritdoc />
		public override string MakeFormulaName(string formulaName)
		{
			return MakeTypeName(formulaName);
		}
		/// <inheritdoc />
		public override string MakeMethodParameterName(string parameterName)
		{
			if (parameterName == null) throw new ArgumentNullException(nameof(parameterName));

			return ValidateTypeScriptIdentifier(MakePascalCaseIdentifier(parameterName));
		}
		/// <inheritdoc />
		public override string MakeEnumLiteralName(string enumLiteralName)
		{
			if (enumLiteralName == null) throw new ArgumentNullException(nameof(enumLiteralName));

			return ValidateTypeScriptIdentifier(MakePascalCaseIdentifier(enumLiteralName));
		}
		/// <inheritdoc />
		public override Dictionary<string, NativeTypeReference> GetNativeTypes()
		{
			var types = new Dictionary<Type, string>
			{
				{ typeof(string), "string" },
				{ typeof(char), "string" },
				{ typeof(bool), "boolean" },
				{ typeof(void), "void" },
				{ typeof(object), "object" },
				{ typeof(byte), "number" },
				{ typeof(sbyte), "number" },
				{ typeof(short), "number" },
				{ typeof(ushort), "number" },
				{ typeof(int), "number" },
				{ typeof(uint), "number" },
				{ typeof(long), "bigint" },
				{ typeof(ulong), "bigint" },
				{ typeof(float), "number" },
				{ typeof(double), "number" },
				{ typeof(decimal), "number" },
				{ typeof(TimeSpan), "TimeSpan" },
				{ typeof(DateTime), "Date" },
			};
			var nativeTypes = new Dictionary<string, NativeTypeReference>();
			foreach (var typeWithNativeName in types)
			{
				var nativeType = new NativeTypeReference(typeWithNativeName.Value);
				nativeTypes.Add(typeWithNativeName.Key.Name, nativeType);
				if (string.IsNullOrEmpty(typeWithNativeName.Key.FullName) == false)
				{
					nativeTypes.Add(typeWithNativeName.Key.FullName, nativeType);
				}
			}
			return nativeTypes;
		}

		private static string ValidateTypeScriptTypeName(string typeName)
		{
			typeName = ValidateTypeScriptIdentifier(typeName);
			if (KnownTypes.Contains(typeName))
			{
				return "_" + typeName;
			}
			else
			{
				return typeName;
			}
		}
		private static string ValidateTypeScriptIdentifier(string identifier)
		{
			if (Keywords.Contains(identifier))
			{
				return "_" + identifier;
			}
			else
			{
				return identifier;
			}
		}
	}


	public class UeCppLanguage : GenerationTargetLanguage
	{
		private static readonly HashSet<string> Keywords = new HashSet<string>(new string[] {
			"alignas", "alignof", "and", "and_eq", "asm", "auto", "bitand", "bitor", "bool",
			"break", "case", "catch", "char", "char8_t", "char16_t", "char32_t", "class",
			"compl", "concept", "const", "const_cast", "consteval", "constexpr", "constinit",
			"continue", "co_await", "co_return", "co_yield", "decltype", "default", "delete",
			"do", "double", "dynamic_cast", "else", "enum", "explicit", "export", "extern",
			"false", "float", "for", "friend", "goto", "if", "inline", "int", "long", "mutable",
			"namespace", "new", "noexcept", "not", "not_eq", "nullptr", "operator", "or",
			"or_eq", "private", "protected", "public", "register reinterpret_cast", "requires",
			"return", "short", "signed", "sizeof", "static", "static_assert", "static_cast",
			"struct", "switch", "template", "this", "thread_local", "throw", "true", "try",
			"typedef", "typeid", "typename", "union", "unsigned", "using declaration",
			"using", "directive", "virtual", "void", "volatile", "wchar_t", "while",
			"xor", "xor_eq"
		});

		public string SharedRefTypeName = "TSharedRef";
		public string SharedPtrTypeName = "TSharedPtr";
		public string OptionalTypeName = "TOptional";
		public string FunctionTypeName = "TFunction";

		public string ModuleName { get; set; }
		public string ApiName => this.ModuleName.ToUpperInvariant() + "_API";

		public UeCppLanguage()
		{
			this.Namespace = "GameParameters";
			this.GameDataClassName = "UGameData";
			this.ModuleName = "GameData";
			this.DocumentClassName = "UGameDataDocument";
			this.LocalizedStringClassName = "FLocalizedString";
			this.DocumentReferenceClassName = "FGameDataDocumentReference";
			this.DocumentReferenceListClassName = "TArray";
			this.DocumentCollectionClassName = "TMap";
			this.ReadOnlyListClassName = "TArray";
			this.ReadOnlyDictionaryClassName = "TMap";
			this.NullableClassName = this.OptionalTypeName;
		}

		/// <inheritdoc />
		public override void FixClassNames()
		{
			this.Namespace = string.Empty;
			this.GameDataClassName = ValidateCppIdentifier(this.GameDataClassName ?? "UGameData");
			this.ModuleName = TrimTypePrefix(this.GameDataClassName);
			this.DocumentClassName = ValidateCppIdentifier(this.DocumentClassName ?? "UGameDataDocument");
			this.LocalizedStringClassName = ValidateCppIdentifier(this.LocalizedStringClassName ?? "FLocalizedString");
			this.DocumentReferenceClassName = "FGameDataDocumentReference";
			this.DocumentCollectionClassName = ValidateCppIdentifier(this.DocumentCollectionClassName ?? "TMap");
			this.DocumentReferenceListClassName = ValidateCppIdentifier(this.DocumentReferenceListClassName ?? "TArray");
			this.ReadOnlyListClassName = ValidateCppIdentifier(this.ReadOnlyListClassName ?? "TArray");
			this.ReadOnlyDictionaryClassName = ValidateCppIdentifier(this.ReadOnlyDictionaryClassName ?? "TMap");
			this.NullableClassName = ValidateCppIdentifier(this.NullableClassName ?? this.OptionalTypeName);
		}

		public ITypeReference MakePtrType(ITypeReference elementType)
		{
			if (elementType == null) throw new ArgumentNullException(nameof(elementType));

			return new DerivedTypeReference("", elementType, "*");
		}
		public ITypeReference MakeConstType(ITypeReference elementType)
		{
			if (elementType == null) throw new ArgumentNullException(nameof(elementType));

			return new DerivedTypeReference("const ", elementType, "");
		}
		public ITypeReference MakeSharedPtrType(ITypeReference elementType)
		{
			if (elementType == null) throw new ArgumentNullException(nameof(elementType));

			return new GenericTypeReference(SharedPtrTypeName, elementType);
		}
		public ITypeReference MakeSharedRefType(ITypeReference elementType)
		{
			if (elementType == null) throw new ArgumentNullException(nameof(elementType));

			return new GenericTypeReference(SharedRefTypeName, elementType);
		}
		public ITypeReference MakeOptionalType(ITypeReference elementType)
		{
			if (elementType == null) throw new ArgumentNullException(nameof(elementType));

			return new GenericTypeReference(OptionalTypeName, elementType);
		}

		/// <inheritdoc />
		public override string PrepareDescription(string summary)
		{
			{
				if (string.IsNullOrWhiteSpace(summary))
				{
					return null;
				}

				return SecurityElement.Escape(summary)?.Trim('.').Replace("\r", "").Replace("\n", "<br />") ?? "";
			}
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceCollectionTypeRef(ITypeReference idType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentReferenceListClassName, this.MakeDocumentReferenceTypeRef(documentType));
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentCollectionTypeRef(ITypeReference keyType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentCollectionClassName, keyType, this.MakePtrType(documentType));
		}
		/// <inheritdoc />
		public override ITypeReference MakeOptionalTypeRef(ITypeReference valueType)
		{
			if (valueType == null) throw new ArgumentNullException(nameof(valueType));
			return valueType;
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceTypeRef(ITypeReference documentType)
		{
			if (documentType == null) throw new ArgumentNullException(nameof(documentType));

			return new NativeTypeReference(this.DocumentReferenceClassName);
		}
		/// <inheritdoc />
		public override ITypeReference MakeRawFormulaTypeRef()
		{
			return new NativeTypeReference("FJsonObjectWrapper");
		}
		/// <inheritdoc />
		public override string MakeTypeName(string typeName)
		{
			if (typeName == null) throw new ArgumentNullException(nameof(typeName));

			return ValidateCppIdentifier("U" + MakeDromedaryCaseName(typeName));
		}
		/// <inheritdoc />
		public override string MakeEnumName(string enumName)
		{
			if (enumName.Length > 3 && enumName.StartsWith("E", StringComparison.Ordinal) && char.IsUpper(enumName[1]))
			{
				return enumName;
			}
			return ValidateCppIdentifier("E" + MakeDromedaryCaseName(enumName));
		}
		/// <inheritdoc />
		public override string MakeFieldName(string fieldName)
		{
			if (fieldName == null) throw new ArgumentNullException(nameof(fieldName));

			return ValidateCppIdentifier("_" + MakePascalCaseIdentifier(fieldName));
		}
		/// <inheritdoc />
		public override string MakePropertyName(string propertyName)
		{
			if (propertyName == null) throw new ArgumentNullException(nameof(propertyName));

			return ValidateCppIdentifier(MakeDromedaryCaseName(propertyName));
		}
		/// <inheritdoc />
		public override string MakeFormulaName(string formulaName)
		{
			if (formulaName == null) throw new ArgumentNullException(nameof(formulaName));

			return MakeTypeName(formulaName);
		}
		/// <inheritdoc />
		public override string MakeMethodParameterName(string parameterName)
		{
			if (parameterName == null) throw new ArgumentNullException(nameof(parameterName));

			return ValidateCppIdentifier(MakeDromedaryCaseName(parameterName));
		}
		/// <inheritdoc />
		public override string MakeEnumLiteralName(string enumLiteralName)
		{
			if (enumLiteralName == null) throw new ArgumentNullException(nameof(enumLiteralName));

			return ValidateCppIdentifier(MakeDromedaryCaseName(enumLiteralName));
		}

		public static string TrimTypePrefix(string typeName)
		{
			if (typeName.Length > 2 &&
				char.IsUpper(typeName[0]) &&
				char.IsLetter(typeName[0]) &&
				char.IsUpper(typeName[1]) &&
				char.IsLetter(typeName[1]) &&
				(typeName[0] == 'U' || typeName[0] == 'F' || typeName[0] == 'E'))
			{
				return typeName.Substring(1);
			}

			return typeName;
		}

		/// <inheritdoc />
		public override Dictionary<string, NativeTypeReference> GetNativeTypes()
		{
			var types = new Dictionary<Type, string>
			{
				{ typeof(string), "FString" },
				{ typeof(char), "FString" },
				{ typeof(bool), "bool" },
				{ typeof(void), "void" },
				{ typeof(object), "FVariant" },
				{ typeof(byte), "int32" },
				{ typeof(sbyte), "int32" },
				{ typeof(short), "int32" },
				{ typeof(ushort), "int32" },
				{ typeof(int), "int32" },
				{ typeof(uint), "uint32" },
				{ typeof(long), "int64" },
				{ typeof(ulong), "uint64" },
				{ typeof(float), "float" },
				{ typeof(double), "double" },
				{ typeof(decimal), "double" },
				{ typeof(TimeSpan), "FTimespan" },
				{ typeof(DateTime), "FDateTime" },
			};
			var nativeTypes = new Dictionary<string, NativeTypeReference>();
			foreach (var typeWithNativeName in types)
			{
				var nativeType = new NativeTypeReference(typeWithNativeName.Value);
				nativeTypes.Add(typeWithNativeName.Key.Name, nativeType);
				if (string.IsNullOrEmpty(typeWithNativeName.Key.FullName) == false)
				{
					nativeTypes.Add(typeWithNativeName.Key.FullName, nativeType);
				}
			}
			return nativeTypes;
		}

		private static string ValidateCppIdentifier(string identifier)
		{
			if (Keywords.Contains(identifier))
			{
				return "_" + identifier;
			}
			else
			{
				return identifier;
			}
		}
	}


	public enum DataType
	{
		Text = 0,
		LocalizedText = 1,
		Logical = 5,
		Time = 8,
		Date = 9,
		Number = 12,
		Integer = 13,
		MultiPickList = 19,
		PickList = 18,
		Document = 22,
		DocumentCollection = 23,
		Reference = 28,
		ReferenceCollection = 29,
		Formula = 35
	}


	public enum IdGeneratorType
	{
		Custom = 0,
		ObjectId = 1,
		Guid = 2,
		Sequence = 3,
		GlobalSequence = 4
	}


	public sealed class Metadata
	{
		private readonly Dictionary<object, Schema> schemasById;
		private readonly Dictionary<string, Schema> schemasByName;
		private readonly ProjectSettings projectSettings;

		public readonly Version ToolsVersion;
		public readonly int ChangeNumber;
		public readonly string RevisionHash;

		public ProjectSettings ProjectSettings => this.projectSettings;

		public Metadata(IReadOnlyDictionary<string, object> gameData)
		{
			if (gameData == null) throw new ArgumentNullException(nameof(gameData));

			if (!gameData.ContainsKey("Collections"))
				throw new InvalidOperationException("Invalid gamedata. Missing 'Collections'.");

			var collections = (IReadOnlyDictionary<string, object>)gameData["Collections"];

			if (!collections.ContainsKey("Schema"))
				throw new InvalidOperationException("Invalid gamedata. Missing 'Schema' collection.");

			var schemas = ((IList<object>)collections["Schema"])
				.OfType<IReadOnlyDictionary<string, object>>()
				.Select(document => new Schema(document, id => this.GetSchema(Convert.ToString(id, CultureInfo.InvariantCulture))));

			var projectSettings = Enumerable.Empty<ProjectSettings>();

			if (collections.TryGetValue("ProjectSettings", out var collection))
			{
				projectSettings = ((IList<object>)collection)
					.OfType<IReadOnlyDictionary<string, object>>()
					.Select(document => new ProjectSettings(document));
			}

			this.schemasById = new Dictionary<object, Schema>();
			this.schemasByName = new Dictionary<string, Schema>(StringComparer.Ordinal);

			foreach (var schema in schemas)
			{
				this.schemasById[schema.Id] = schema;
				this.schemasByName[schema.Name] = schema;
			}

			this.projectSettings = projectSettings.FirstOrDefault() ?? new ProjectSettings(new Dictionary<string, object>());

			this.ToolsVersion = gameData.TryGetValue("ToolsVersion", out var toolsVersion) ? new Version((string)toolsVersion) : new Version();
			this.ChangeNumber = GetValueOrDefault(gameData, "ChangeNumber", 0);
			this.RevisionHash = GetValueOrDefault(gameData, "RevisionHash", string.Empty);
		}

		public ICollection<Schema> GetSchemas()
		{
			return this.schemasById.Values;
		}
		public Schema GetSchema(string schemaIdOrName)
		{
			if (schemaIdOrName == null) throw new ArgumentNullException(nameof(schemaIdOrName));

			if (this.TryGetSchema(schemaIdOrName, out var schema) == false)
			{
				throw new ArgumentException($"Unable to find schema with id or name '{schemaIdOrName}'.");
			}
			return schema;
		}
		public bool TryGetSchema(string schemaIdOrName, out Schema schema)
		{
			if (schemaIdOrName == null) throw new ArgumentNullException(nameof(schemaIdOrName));

			if (this.schemasById.TryGetValue(schemaIdOrName, out schema) == false &&
				this.schemasByName.TryGetValue(schemaIdOrName, out schema) == false)
			{
				return false;
			}

			return true;
		}

		public static T GetValueOrDefault<T>(IReadOnlyDictionary<string, object> values, string valueName, T defaultValue, bool isRequired = false, string subject = "Object")
		{
			if (values == null) throw new ArgumentNullException(nameof(values));
			if (valueName == null) throw new ArgumentNullException(nameof(valueName));

			if (values.TryGetValue(valueName, out var valueObj))
			{
				if (valueObj is T typedValue)
				{
					return typedValue;
				}
				else if (valueObj == null)
				{
					return default(T);
				}
				else if (typeof(T).IsEnum)
				{
					var enumSubType = Enum.GetUnderlyingType(typeof(T));
					// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
					switch (Type.GetTypeCode(valueObj.GetType()))
					{
						case TypeCode.Single:
						case TypeCode.Double:
							var doubleValue = Math.Round(Convert.ToDouble(valueObj, CultureInfo.InvariantCulture));
							valueObj = Convert.ChangeType(doubleValue, enumSubType, CultureInfo.InvariantCulture);
							return (T)Enum.ToObject(typeof(T), valueObj);
						case TypeCode.Byte:
						case TypeCode.Int16:
						case TypeCode.Int32:
						case TypeCode.Int64:
						case TypeCode.SByte:
						case TypeCode.UInt16:
						case TypeCode.UInt32:
						case TypeCode.UInt64:
							return (T)Enum.ToObject(typeof(T), valueObj);
						default:
							var enumString = Convert.ToString(valueObj, CultureInfo.InvariantCulture) ?? string.Empty;
							return (T)Enum.Parse(typeof(T), enumString, true);
					}
				}
				else
				{
					return (T)Convert.ChangeType(valueObj, typeof(T), CultureInfo.InvariantCulture);
				}
			}
			else if (isRequired)
			{
				throw new InvalidOperationException($"{subject} is missing required member '{valueName}'.");
			}
			else
			{
				return defaultValue;
			}
		}
	}


	public sealed class ProjectSettings
	{
		public const string DEFAULT_PROJECT_NAME = "Untitled Project";

		public static readonly string DefaultLanguage = "en-US";
		public static readonly char[] LanguageListSeparator = ";,| ".ToCharArray();

		private readonly string[] languageIds;

		public readonly string Id;
		public readonly string Name;
		public readonly string Copyright;
		public readonly string Languages;
		public readonly string PrimaryLanguage;

		public ProjectSettings(IReadOnlyDictionary<string, object> values)
		{
			if (values == null) throw new ArgumentNullException(nameof(values));

			this.Id = Metadata.GetValueOrDefault(values, "Id", string.Empty, false, this.GetType().Name);
			this.Name = Metadata.GetValueOrDefault(values, "Name", string.Empty, false, this.GetType().Name);
			this.Copyright = Metadata.GetValueOrDefault(values, "Copyright", string.Empty, false, this.GetType().Name);
			this.Languages = Metadata.GetValueOrDefault(values, "Languages", string.Empty, false, this.GetType().Name);
			this.PrimaryLanguage = Metadata.GetValueOrDefault(values, "PrimaryLanguage", string.Empty, false, this.GetType().Name);

			if (string.IsNullOrWhiteSpace(this.Name))
			{
				this.Name = DEFAULT_PROJECT_NAME;
			}
			if (string.IsNullOrWhiteSpace(this.Copyright))
			{
				this.Copyright = string.Empty;
			}
			if (string.IsNullOrWhiteSpace(this.PrimaryLanguage))
			{
				this.PrimaryLanguage = DefaultLanguage;
			}

			var allLanguages = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			if (string.IsNullOrWhiteSpace(this.Languages) == false)
			{
				foreach(var lang in this.Languages.Split(LanguageListSeparator, StringSplitOptions.RemoveEmptyEntries))
					allLanguages.Add(lang);
			}

			allLanguages.Add(this.PrimaryLanguage);

			var allLanguageIds = allLanguages.ToArray();
			Array.Sort(allLanguageIds, StringComparer.OrdinalIgnoreCase);
			this.languageIds = allLanguageIds;

			this.Languages = string.Join(LanguageListSeparator[0].ToString(), this.languageIds);
		}

		public string[] GetLanguageIds()
		{
			return this.languageIds;
		}

		public ProjectSettings Clone()
		{
			var clone = (ProjectSettings)this.MemberwiseClone();
			return clone;
		}

		public override string ToString()
		{
			return string.Format(
				"{0}, languages: {2}, primary language: {3}, copyright: {1}",
				this.Name,
				this.Copyright,
				this.Languages,
				this.PrimaryLanguage
			);
		}
	}


	public enum Requirement
	{
		None = 0,
		NotNull = 2,
		NotEmpty = 3,
	}


	public sealed class Schema
	{
		private readonly Dictionary<string, SchemaProperty> propertiesById;
		private readonly Dictionary<string, SchemaProperty> propertiesByName;
		private readonly SpecificationDictionary specification;

		public readonly string Id;
		public readonly string Name;
		public readonly SchemaType Type;
		public readonly string DisplayName;
		public readonly string Description;
		public readonly string Specification;

		public List<SchemaProperty> Properties { get; private set; }

		public Schema(IReadOnlyDictionary<string, object> values, Func<object, Schema> findSchemaFunc)
		{
			if (values == null) throw new ArgumentNullException(nameof(values));
			if (findSchemaFunc == null) throw new ArgumentNullException(nameof(findSchemaFunc));

			this.Id = Metadata.GetValueOrDefault(values, "Id", string.Empty, true, this.GetType().Name);
			this.Name = Metadata.GetValueOrDefault(values, "Name", string.Empty, true, this.GetType().Name);
			this.Type = Metadata.GetValueOrDefault(values, "Type", default(SchemaType), false, this.GetType().Name);
			this.DisplayName = Metadata.GetValueOrDefault(values, "DisplayName", string.Empty, false, this.GetType().Name);
			this.Description = Metadata.GetValueOrDefault(values, "Description", string.Empty, false, this.GetType().Name);
			this.Specification = Metadata.GetValueOrDefault(values, "Specification", string.Empty, false, this.GetType().Name);

			this.Properties = new List<SchemaProperty>();

			if (values.TryGetValue("Properties", out var propertiesObj) && propertiesObj != null)
			{
				foreach (var propertyObj in (IList<object>)propertiesObj)
				{
					this.Properties.Add(new SchemaProperty((IReadOnlyDictionary<string, object>)propertyObj, this, findSchemaFunc));
				}
			}

			if (string.IsNullOrEmpty(this.DisplayName))
			{
				this.DisplayName = this.Name;
			}

			this.propertiesById = new Dictionary<string, SchemaProperty>(StringComparer.Ordinal);
			this.propertiesByName = new Dictionary<string, SchemaProperty>(StringComparer.Ordinal);

			foreach (var attr in this.Properties)
			{
				this.propertiesById.Add(attr.Id, attr);
				this.propertiesByName.Add(attr.Name, attr);
			}
			this.specification = new SpecificationDictionary(this.Specification ?? string.Empty);
		}

		public bool HasProperty(string propertyIdOrName)
		{
			if (propertyIdOrName == null) throw new ArgumentNullException(nameof(propertyIdOrName));

			return this.propertiesById.ContainsKey(propertyIdOrName) || this.propertiesByName.ContainsKey(propertyIdOrName);
		}
		public SchemaProperty GetIdProperty()
		{
			return this.GetProperty("Id");
		}
		public SchemaProperty GetProperty(string propertyIdOrName)
		{
			if (propertyIdOrName == null) throw new ArgumentNullException(nameof(propertyIdOrName));

			if (this.propertiesById.TryGetValue(propertyIdOrName, out var schemaProperty) == false && this.propertiesByName.TryGetValue(propertyIdOrName, out schemaProperty) == false)
				throw new ArgumentException($"Unable to find property with id or name '{propertyIdOrName}' on schema '{this.Name}'.");
			return schemaProperty;
		}
		public SpecificationDictionary GetSpecification()
		{
			return this.specification;
		}

		public override string ToString()
		{
			return $"{this.Name}, id: {this.Id}";
		}
	}


	public sealed class SchemaProperty
	{
		private readonly Type propertyValueType;
		private readonly SpecificationDictionary specification;

		public readonly string Id;
		public readonly string Name;
		public readonly string DisplayName;
		public readonly string Description;

		public readonly DataType DataType;
		public readonly Uniqueness Uniqueness;
		public readonly Requirement Requirement;
		public readonly SchemaReference ReferenceType;
		public readonly int Size;
		public readonly string Specification;
		public bool IsRawFormulaType => string.IsNullOrEmpty(this.GetSpecification().GetFormulaResultType());

		public readonly Schema DeclaredSchema;

		public SchemaProperty(IReadOnlyDictionary<string, object> values, Schema declaredSchema, Func<object, Schema> findSchemaFunc)
		{
			if (values == null) throw new ArgumentNullException(nameof(values));
			if (declaredSchema == null) throw new ArgumentNullException(nameof(declaredSchema));
			if (findSchemaFunc == null) throw new ArgumentNullException(nameof(findSchemaFunc));

			this.DeclaredSchema = declaredSchema;

			this.Id = Metadata.GetValueOrDefault(values, "Id", string.Empty, true, this.GetType().Name);
			this.Name = Metadata.GetValueOrDefault(values, "Name", string.Empty, true, this.GetType().Name);
			this.DisplayName = Metadata.GetValueOrDefault(values, "DisplayName", this.Name, false, this.GetType().Name);
			this.Description = Metadata.GetValueOrDefault(values, "Description", string.Empty, false, this.GetType().Name);
			this.DataType = Metadata.GetValueOrDefault(values, "DataType", default(DataType), true, this.GetType().Name);
			this.Uniqueness = Metadata.GetValueOrDefault(values, "Uniqueness", default(Uniqueness), true, this.GetType().Name);
			this.Requirement = Metadata.GetValueOrDefault(values, "Requirement", default(Requirement), true, this.GetType().Name);
			this.Size = Metadata.GetValueOrDefault(values, "Size", default(int), true, this.GetType().Name);
			this.Specification = Metadata.GetValueOrDefault(values, "Specification", default(string), false, this.GetType().Name);

			if (string.IsNullOrEmpty(this.DisplayName))
			{
				this.DisplayName = this.Name;
			}

			if (values.TryGetValue("ReferenceType", out var referenceTypeObj) && referenceTypeObj != null)
			{
				this.ReferenceType = new SchemaReference(findSchemaFunc) {
					Id = Metadata.GetValueOrDefault((IReadOnlyDictionary<string, object>)referenceTypeObj, "Id", string.Empty, true, "ReferenceType")
				};
			}

			var spec = new SpecificationDictionary(this.Specification ?? string.Empty);
			var type = typeof(string);
			switch (this.DataType)
			{
				case DataType.LocalizedText:
					type = typeof(IReadOnlyDictionary<string, string>);
					break;
				case DataType.Text:
					type = typeof(string);
					break;
				case DataType.Date:
					type = typeof(DateTime);
					break;
				case DataType.Time:
					type = typeof(TimeSpan);
					break;
				case DataType.Logical:
					type = typeof(bool);
					break;
				case DataType.Formula:
				case DataType.Reference:
				case DataType.Document:
					type = typeof(IReadOnlyDictionary<string, object>);
					break;
				case DataType.ReferenceCollection:
				case DataType.DocumentCollection:
					type = typeof(List<IReadOnlyDictionary<string, object>>);
					break;
				case DataType.MultiPickList:
				case DataType.PickList:
				case DataType.Integer:
					switch (this.Size)
					{
						case 1:
							type = typeof(sbyte);
							break;
						case 2:
							type = typeof(short);
							break;
						case 3:
						case 4:
							type = typeof(int);
							break;
						case 5:
						case 6:
						case 7:
						case 8:
							type = typeof(long);
							break;
						default:
							throw new InvalidOperationException(string.Format("Invalid size '{1}' of '{0}' property. Size for integer should be between 1 and 8.",
								this.Name, this.Size));
					}

					break;
				case DataType.Number:
					if (this.Size <= 4)
					{
						type = typeof(float);
					}
					else if (this.Size <= 8)
					{
						type = typeof(double);
					}
					else
					{
						throw new InvalidOperationException(string.Format("Invalid size '{1}' of '{0}' property. Size for number should be between 1 and 8.",
							this.Name, this.Size));
					}

					break;
				default: throw new InvalidOperationException(string.Format("Invalid type '{1}' of '{0}' property.", this.Name, this.DataType));
			}

			this.propertyValueType = type;
			this.specification = spec;
		}

		public Type GetPropertyValueType()
		{
			return this.propertyValueType;
		}
		public SpecificationDictionary GetSpecification()
		{
			return this.specification;
		}
		public override string ToString()
		{
			return $"{this.Name}, id: {this.Id}";
		}
	}


	public sealed class SchemaReference
	{
		private readonly Func<object, Schema> findSchemaFunc;
		private Schema foundSchema;

		public string Id { get; set; }
		public Schema Schema => this.foundSchema ?? (this.foundSchema = this.findSchemaFunc(this.Id));

		public SchemaReference(Func<object, Schema> findSchemaFunc)
		{
			this.findSchemaFunc = findSchemaFunc;
		}

		public override string ToString()
		{
			return $"id: {this.Id}";
		}
	}


	public enum SchemaType
	{
		Normal = 0,
		Component = 1,
		Settings = 2,
	}


	public class SpecificationDictionary
	{
		private static readonly Dictionary<string, string> EmptyPickListValues = new Dictionary<string, string>();
		private static readonly List<KeyValuePair<string, string>> EmptyFormulaParameters = new List<KeyValuePair<string, string>>();

		public const char PairSeparator = '&';
		public const char NameValueSeparator = '=';

		private readonly Dictionary<string, HashSet<string>> values;
		private readonly Dictionary<string, string> pickListValues;
		private readonly List<KeyValuePair<string, string>> formulaParameters;

		public bool IsPickList => this.pickListValues != null;

		public bool HasCustomTypeName => this.values.ContainsKey("typeName") && this.values["typeName"].Count > 0 && string.IsNullOrEmpty(this.values["typeName"].FirstOrDefault()) == false;
		public string CustomTypeName => this.HasCustomTypeName ? this.values["typeName"].FirstOrDefault() : string.Empty;

		public SpecificationDictionary()
		{
			this.values = new Dictionary<string, HashSet<string>>();
		}
		public SpecificationDictionary(string specification)
			: this()
		{
			if (specification == null) throw new ArgumentNullException(nameof(specification));

			foreach (var pair in specification.Split(new char[] { PairSeparator }, StringSplitOptions.RemoveEmptyEntries))
			{
				var sepIdx = pair.IndexOf('=');
				if (sepIdx < 0) continue;

				var key = pair.Substring(0, sepIdx);
				var value = pair.Substring(sepIdx + 1);

				if (key.StartsWith("pick.", StringComparison.Ordinal))
				{
					var pickName = key.Substring(5);
					if (this.pickListValues == null) this.pickListValues = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
					this.pickListValues[pickName] = value;
					continue;
				}
				if (key.StartsWith("param.", StringComparison.Ordinal))
				{
					var paramName = key.Substring(6);
					if (this.formulaParameters == null) this.formulaParameters = new List<KeyValuePair<string, string>>();
					this.formulaParameters.Add(new KeyValuePair<string, string>(paramName, value));
					continue;
				}

				if (this.values.TryGetValue(key, out var list) == false)
					this.values[key] = list = new HashSet<string>();
				list.Add(value);
			}
		}

		public HashSet<string> GetValues(string key)
		{
			if (key == null) throw new ArgumentNullException(nameof(key));

			if (this.values.TryGetValue(key, out var list) == false)
				this.values[key] = list = new HashSet<string>();
			return list;
		}
		public string MapPickList(string pickListName)
		{
			if (this.pickListValues == null || pickListName == null)
				return pickListName;

			pickListName = pickListName.Trim();
			if (this.pickListValues.TryGetValue(pickListName, out var pickListValue) == false)
				pickListValue = pickListName;

			return pickListValue;
		}
		public string MapMultiPickList(string flags)
		{
			if (this.pickListValues == null || flags == null)
				return flags;

			if (flags.IndexOf(',') == -1)
				return this.MapPickList(flags);

			var result = default(long);
			foreach (var flag in flags.Split(','))
			{
				var value = this.MapPickList(flag);
				if (long.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var valueNum) == false)
					throw new FormatException($"Flag with label '{value}' is not found.");

				result |= valueNum;
			}

			return result.ToString();
		}

		public Dictionary<string, string> GetPickListValues()
		{
			return this.pickListValues ?? EmptyPickListValues;
		}
		public List<KeyValuePair<string, string>> GetFormulaParameters()
		{
			return this.formulaParameters ?? EmptyFormulaParameters;
		}
		public string GetFormulaResultType()
		{
			var resultType = default(string);
			if (this.values.TryGetValue("resultType", out var resultTypes) || this.values.TryGetValue("result", out resultTypes))
				resultType = resultTypes.FirstOrDefault();

			if (string.IsNullOrEmpty(resultType))
			{
				return null;
			}
			return resultType;
		}
		public HashSet<string> GetKnownTypes()
		{
			if (this.values.TryGetValue("knownType", out var knownTypes))
				return knownTypes;
			else
				return new HashSet<string>();
		}
	}


	public enum Uniqueness
	{
		None = 0,
		Unique = 1,
		UniqueInContainer = 2,
	}


	public abstract class GameDataVisitor
	{
		protected readonly Metadata metadata;

		protected GameDataVisitor(Metadata metadata)
		{
			if (metadata == null) throw new ArgumentNullException(nameof(metadata));

			this.metadata = metadata;
		}

		public void Visit(IReadOnlyDictionary<string, object> gameData)
		{
			if (gameData == null) throw new ArgumentNullException(nameof(gameData));

			if (!gameData.ContainsKey("Collections"))
			{
				throw new InvalidOperationException("Invalid gamedata. Missing 'Collections'.");
			}

			var collections = (IReadOnlyDictionary<string, object>)gameData["Collections"];
			var documentStack = new Stack<IReadOnlyDictionary<string, object>>();
			var propertyStack = new Stack<SchemaProperty>();
			foreach (var schemaName in collections.Keys)
			{
				if (this.metadata.TryGetSchema(schemaName, out var schema) == false)
				{
					continue;
				}
				if (collections.TryGetValue(schemaName, out var collectionObj) == false)
				{
					continue;
				}
				if (!(collectionObj is IList<object> collection))
				{
					continue;
				}

				foreach (var document in collection.OfType<IReadOnlyDictionary<string, object>>())
				{
					if (document == null) continue;

					documentStack.Clear();
					propertyStack.Clear();

					this.VisitDocument(document, schema, documentStack, propertyStack);
				}
			}
		}

		protected virtual void VisitDocument(
			IReadOnlyDictionary<string, object> document,
			Schema documentSchema,
			Stack<IReadOnlyDictionary<string, object>> parentDocuments,
			Stack<SchemaProperty> path)
		{
			if (document == null) throw new ArgumentNullException(nameof(document));
			if (documentSchema == null) throw new ArgumentNullException(nameof(documentSchema));
			if (parentDocuments == null) throw new ArgumentNullException(nameof(parentDocuments));
			if (path == null) throw new ArgumentNullException(nameof(path));

			foreach (var schemaProperty in documentSchema.Properties)
			{
				if (schemaProperty.DataType != DataType.Document && schemaProperty.DataType != DataType.DocumentCollection)
					continue;

				if (document.TryGetValue(schemaProperty.Name, out var value) == false || value == null)
					continue;

				var subSchema = this.metadata.GetSchema(schemaProperty.ReferenceType.Id);
				parentDocuments.Push(document);
				path.Push(schemaProperty);
				if (value is IList<object> list)
				{
					foreach (var subDocument in list)
					{
						this.VisitDocument((IReadOnlyDictionary<string, object>)subDocument, subSchema, parentDocuments, path);
					}
				}
				else if (value is IReadOnlyDictionary<string, object> objects)
				{
					this.VisitDocument(objects, subSchema, parentDocuments, path);
				}

				parentDocuments.Pop();
				path.Pop();
			}
		}
	}


	public sealed class StatisticsVisitor : GameDataVisitor
	{
		private const int MAX_STRING_SIZE = 64;

		public readonly Dictionary<Schema, int> RootDocumentCount = new Dictionary<Schema, int>(200);
		public readonly Dictionary<Schema, int> DocumentCount = new Dictionary<Schema, int>(200);
		public readonly Dictionary<string, int> StringsCount = new Dictionary<string, int>(40000);

		public StatisticsVisitor(Metadata metadata) : base(metadata)
		{
		}

		protected override void VisitDocument
		(
			IReadOnlyDictionary<string, object> document,
			Schema documentSchema,
			Stack<IReadOnlyDictionary<string, object>> parentDocuments,
			Stack<SchemaProperty> path)
		{
			if (this.DocumentCount.TryGetValue(documentSchema, out var count))
			{
				this.DocumentCount[documentSchema] = count + 1;
			}
			else
			{
				this.DocumentCount[documentSchema] = 1;
			}

			if (parentDocuments.Count == 0)
			{
				if (this.RootDocumentCount.TryGetValue(documentSchema, out count))
				{
					this.RootDocumentCount[documentSchema] = count + 1;
				}
				else
				{
					this.RootDocumentCount[documentSchema] = 1;
				}
			}

			this.FindStrings(document);

			base.VisitDocument(document, documentSchema, parentDocuments, path);
		}

		private void FindStrings(IReadOnlyDictionary<string, object> document)
		{
			if (document == null)
			{
				return;
			}

			foreach (var kv in document)
			{
				this.IncrementStringCount(kv.Key);

				if (kv.Value is string value)
				{
					this.IncrementStringCount(value);
				}
				else if (kv.Value is IReadOnlyDictionary<string, object> objects)
				{
					this.FindStrings(objects);
				}
				else if (kv.Value is IList<object> list)
				{
					this.FindStrings(list);
				}
			}
		}
		private void FindStrings(IList<object> documents)
		{
			if (documents == null)
			{
				return;
			}

			foreach (var item in documents)
			{
				switch (item)
				{
					case string stringValue:
						this.IncrementStringCount(stringValue);
						break;
					case IReadOnlyDictionary<string, object> document:
						this.FindStrings(document);
						break;
					case IList<object> list:
						this.FindStrings(list);
						break;
				}
			}
		}

		private void IncrementStringCount(string value)
		{
			if (value == null || value.Length > MAX_STRING_SIZE)
			{
				return;
			}

			if (this.StringsCount.TryGetValue(value, out var count))
			{
				this.StringsCount[value] = count + 1;
			}
			else
			{
				this.StringsCount[value] = 1;
			}
		}

		public static StatisticsVisitor Visit(IReadOnlyDictionary<string, object> gameData, Metadata metadata)
		{
			if (gameData == null) throw new ArgumentNullException(nameof(gameData));
			if (metadata == null) throw new ArgumentNullException(nameof(metadata));

			var visitor = new StatisticsVisitor(metadata);
			visitor.Visit(gameData);
			return visitor;
		}
	}


	#region EndianBitConverter by Jon Skeet and Marc Gravell
	/* "Miscellaneous Utility Library" Software Licence

	Version 1.0

	Copyright (c) 2004-2008 Jon Skeet and Marc Gravell.
	All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions
	are met:

	1. Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.

	2. Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in the
	documentation and/or other materials provided with the distribution.

	3. The end-user documentation included with the redistribution, if
	any, must include the following acknowledgment:

	"This product includes software developed by Jon Skeet
	and Marc Gravell. Contact skeet@pobox.com, or see
	http://www.pobox.com/~skeet/)."

	Alternately, this acknowledgment may appear in the software itself,
	if and wherever such third-party acknowledgments normally appear.

	4. The name "Miscellaneous Utility Library" must not be used to endorse
	or promote products derived from this software without prior written
	permission. For written permission, please contact skeet@pobox.com.

	5. Products derived from this software may not be called
	"Miscellaneous Utility Library", nor may "Miscellaneous Utility Library"
	appear in their name, without prior written permission of Jon Skeet.

	THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED
	WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
	IN NO EVENT SHALL JON SKEET BE LIABLE FOR ANY DIRECT, INDIRECT,
	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	POSSIBILITY OF SUCH DAMAGE.
	*/
	public enum Endianness
	{
		LittleEndian,
		BigEndian
	}

	public abstract class EndianBitConverter
	{
		#region Endianness of this converter

		public abstract bool IsLittleEndian();

		public abstract Endianness Endianness { get; }

		#endregion

		#region Factory properties

		public static readonly LittleEndianBitConverter Little = new LittleEndianBitConverter();
		public static readonly BigEndianBitConverter Big = new BigEndianBitConverter();

		#endregion

		#region Double/primitive conversions

		public long DoubleToInt64Bits(double value)
		{
			return BitConverter.DoubleToInt64Bits(value);
		}

		public double Int64BitsToDouble(long value)
		{
			return BitConverter.Int64BitsToDouble(value);
		}

		public int SingleToInt32Bits(float value)
		{
			return new Int32SingleUnion(value).AsInt32;
		}

		public float Int32BitsToSingle(int value)
		{
			return new Int32SingleUnion(value).AsSingle;
		}

		#endregion

		#region To(PrimitiveType) conversions

		public bool ToBoolean(byte[] value, int startIndex)
		{
			CheckByteArgument(value, startIndex, 1);
			return BitConverter.ToBoolean(value, startIndex);
		}

		public char ToChar(byte[] value, int startIndex)
		{
			return unchecked((char)(CheckedFromBytes(value, startIndex, 2)));
		}

		public double ToDouble(byte[] value, int startIndex)
		{
			return Int64BitsToDouble(ToInt64(value, startIndex));
		}

		public float ToSingle(byte[] value, int startIndex)
		{
			return Int32BitsToSingle(ToInt32(value, startIndex));
		}

		public short ToInt16(byte[] value, int startIndex)
		{
			return unchecked((short)(CheckedFromBytes(value, startIndex, 2)));
		}

		public int ToInt32(byte[] value, int startIndex)
		{
			return unchecked((int)(CheckedFromBytes(value, startIndex, 4)));
		}

		public long ToInt64(byte[] value, int startIndex)
		{
			return CheckedFromBytes(value, startIndex, 8);
		}

		public ushort ToUInt16(byte[] value, int startIndex)
		{
			return unchecked((ushort)(CheckedFromBytes(value, startIndex, 2)));
		}

		public uint ToUInt32(byte[] value, int startIndex)
		{
			return unchecked((uint)(CheckedFromBytes(value, startIndex, 4)));
		}

		public ulong ToUInt64(byte[] value, int startIndex)
		{
			return unchecked((ulong)(CheckedFromBytes(value, startIndex, 8)));
		}

		private static void CheckByteArgument(byte[] value, int startIndex, int bytesRequired)
		{
			if (value == null)
			{
				throw new ArgumentNullException(nameof(value));
			}
			if (startIndex < 0 || startIndex > value.Length - bytesRequired)
			{
				throw new ArgumentOutOfRangeException(nameof(startIndex));
			}
		}

		private long CheckedFromBytes(byte[] value, int startIndex, int bytesToConvert)
		{
			CheckByteArgument(value, startIndex, bytesToConvert);
			return FromBytes(value, startIndex, bytesToConvert);
		}

		protected abstract long FromBytes(byte[] value, int startIndex, int bytesToConvert);

		#endregion

		#region ToString conversions

		public static string ToString(byte[] value)
		{
			return BitConverter.ToString(value);
		}

		public static string ToString(byte[] value, int startIndex)
		{
			return BitConverter.ToString(value, startIndex);
		}

		public static string ToString(byte[] value, int startIndex, int length)
		{
			return BitConverter.ToString(value, startIndex, length);
		}

		#endregion

		#region	Decimal conversions

		public decimal ToDecimal(byte[] value, int startIndex)
		{
			// HACK: This always assumes four parts, each in their own endianness,
			// starting with the first part at the start of the byte array.
			// On the other hand, there's no real format specified...
			var parts = new int[4];
			for (var i = 0; i < 4; i++)
			{
				parts[i] = ToInt32(value, startIndex + i * 4);
			}
			return new decimal(parts);
		}

		public byte[] GetBytes(decimal value)
		{
			var bytes = new byte[16];
			var parts = decimal.GetBits(value);
			for (var i = 0; i < 4; i++)
			{
				CopyBytesImpl(parts[i], 4, bytes, i * 4);
			}
			return bytes;
		}

		public void CopyBytes(decimal value, byte[] buffer, int index)
		{
			var parts = decimal.GetBits(value);
			for (var i = 0; i < 4; i++)
			{
				CopyBytesImpl(parts[i], 4, buffer, i * 4 + index);
			}
		}

		#endregion

		#region GetBytes conversions

		private byte[] GetBytes(long value, int bytes)
		{
			var buffer = new byte[bytes];
			CopyBytes(value, bytes, buffer, 0);
			return buffer;
		}

		public byte[] GetBytes(bool value)
		{
			return BitConverter.GetBytes(value);
		}

		public byte[] GetBytes(char value)
		{
			return GetBytes(value, 2);
		}

		public byte[] GetBytes(double value)
		{
			return GetBytes(DoubleToInt64Bits(value), 8);
		}

		public byte[] GetBytes(short value)
		{
			return GetBytes(value, 2);
		}

		public byte[] GetBytes(int value)
		{
			return GetBytes(value, 4);
		}

		public byte[] GetBytes(long value)
		{
			return GetBytes(value, 8);
		}

		public byte[] GetBytes(float value)
		{
			return GetBytes(SingleToInt32Bits(value), 4);
		}

		public byte[] GetBytes(ushort value)
		{
			return GetBytes(value, 2);
		}

		public byte[] GetBytes(uint value)
		{
			return GetBytes(value, 4);
		}

		public byte[] GetBytes(ulong value)
		{
			return GetBytes(unchecked((long)value), 8);
		}

		#endregion

		#region CopyBytes conversions

		private void CopyBytes(long value, int bytes, byte[] buffer, int index)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException(nameof(buffer), "Byte array must not be null");
			}
			if (buffer.Length < index + bytes)
			{
				throw new ArgumentOutOfRangeException(nameof(buffer), "Buffer not big enough for value");
			}
			CopyBytesImpl(value, bytes, buffer, index);
		}

		protected abstract void CopyBytesImpl(long value, int bytes, byte[] buffer, int index);

		public void CopyBytes(bool value, byte[] buffer, int index)
		{
			CopyBytes(value ? 1 : 0, 1, buffer, index);
		}

		public void CopyBytes(char value, byte[] buffer, int index)
		{
			CopyBytes(value, 2, buffer, index);
		}

		public void CopyBytes(double value, byte[] buffer, int index)
		{
			CopyBytes(DoubleToInt64Bits(value), 8, buffer, index);
		}

		public void CopyBytes(short value, byte[] buffer, int index)
		{
			CopyBytes(value, 2, buffer, index);
		}

		public void CopyBytes(int value, byte[] buffer, int index)
		{
			CopyBytes(value, 4, buffer, index);
		}

		public void CopyBytes(long value, byte[] buffer, int index)
		{
			CopyBytes(value, 8, buffer, index);
		}

		public void CopyBytes(float value, byte[] buffer, int index)
		{
			CopyBytes(SingleToInt32Bits(value), 4, buffer, index);
		}

		public void CopyBytes(ushort value, byte[] buffer, int index)
		{
			CopyBytes(value, 2, buffer, index);
		}

		public void CopyBytes(uint value, byte[] buffer, int index)
		{
			CopyBytes(value, 4, buffer, index);
		}

		public void CopyBytes(ulong value, byte[] buffer, int index)
		{
			CopyBytes(unchecked((long)value), 8, buffer, index);
		}

		#endregion

		#region Private struct used for Single/Int32 conversions

		[StructLayout(LayoutKind.Explicit)]
		private readonly struct Int32SingleUnion
		{
			[FieldOffset(0)]
			private readonly int i;

			[FieldOffset(0)]
			private readonly float f;

			internal Int32SingleUnion(int i)
			{
				this.f = 0; // Just to keep the compiler happy
				this.i = i;
			}

			internal Int32SingleUnion(float f)
			{
				this.i = 0; // Just to keep the compiler happy
				this.f = f;
			}

			internal int AsInt32 => i;

			internal float AsSingle => f;
		}

		#endregion
	}

	public sealed class BigEndianBitConverter : EndianBitConverter
	{
		public override bool IsLittleEndian()
		{
			return false;
		}

		public override Endianness Endianness => Endianness.BigEndian;

		protected override void CopyBytesImpl(long value, int bytes, byte[] buffer, int index)
		{
			var endOffset = index + bytes - 1;
			for (var i = 0; i < bytes; i++)
			{
				buffer[endOffset - i] = unchecked((byte)(value & 0xff));
				value = value >> 8;
			}
		}

		protected override long FromBytes(byte[] buffer, int startIndex, int bytesToConvert)
		{
			long ret = 0;
			for (var i = 0; i < bytesToConvert; i++)
			{
				ret = unchecked((ret << 8) | buffer[startIndex + i]);
			}
			return ret;
		}
	}

	public sealed class LittleEndianBitConverter : EndianBitConverter
	{
		public override bool IsLittleEndian()
		{
			return true;
		}

		public override Endianness Endianness => Endianness.LittleEndian;

		protected override void CopyBytesImpl(long value, int bytes, byte[] buffer, int index)
		{
			for (var i = 0; i < bytes; i++)
			{
				buffer[i + index] = unchecked((byte)(value & 0xff));
				value = value >> 8;
			}
		}

		protected override long FromBytes(byte[] buffer, int startIndex, int bytesToConvert)
		{
			long ret = 0;
			for (var i = 0; i < bytesToConvert; i++)
			{
				ret = unchecked((ret << 8) | buffer[startIndex + bytesToConvert - 1 - i]);
			}
			return ret;
		}
	}

	/* end of Jon Skeet and Marc Gravell code */
	#endregion


	[Obsolete("Left for backward compatibility. Use GameDataFormat instead.")]
	public static class Format
	{
		public static readonly GameDataFormat Json = GameDataFormat.Json;
		public static readonly GameDataFormat MessagePack = GameDataFormat.MessagePack;
	}


	public enum GameDataFormat
	{
		Json,
		MessagePack
	}


	public class GameDataLoadOptions
	{
		public GameDataFormat Format { get; set; }
		public IReadOnlyList<Stream> Patches { get; set; }
		public Encoding Encoding { get; set; }
		public bool LeaveStreamsOpen { get; set; }

		public GameDataLoadOptions()
		{
			this.Format = GameDataFormat.Json;
			this.Patches = Array.Empty<Stream>();
			this.Encoding = Encoding.UTF8;
			this.LeaveStreamsOpen = false;
		}

		/// <inheritdoc />
		public override string ToString()
		{
			return $"Format: {this.Format}, Patches: {string.Join(", ", this.Patches)}, Encoding: {this.Encoding.WebName}, Leave Open: {this.LeaveStreamsOpen}";
		}
	}


	public class GameDataObjectReader : GameDataReader
	{
		private ReaderFrame[] frames;
		private int topFrameIndex;
		private ReaderNode currentNode;

		/// <inheritdoc />
		public override ReaderNode Node => this.currentNode;
		/// <inheritdoc />
		public override int LineNumber => 0;
		/// <inheritdoc />
		public override int ColumnNumber => 0;

		public GameDataObjectReader(IReadOnlyDictionary<string, object> gameDataPatch)
		{
			this.frames = new ReaderFrame[10];
			this.topFrameIndex = -1;
			this.PushFrame(gameDataPatch);
			this.topFrameIndex = int.MinValue;
		}

		/// <inheritdoc />
		public override bool NextToken()
		{
			if (this.topFrameIndex == int.MinValue)
			{
				this.topFrameIndex = 0;
				this.currentNode = new ReaderNode(this.frames[this.topFrameIndex].ContainerType);
				return true;
			}

			while (this.topFrameIndex >= 0)
			{
				var nextToken = ReaderFrame.GetState(ref this.frames[this.topFrameIndex]);
				switch (nextToken)
				{
					case ReaderToken.Member:
						var memberName = this.frames[this.topFrameIndex].MemberName;
						this.currentNode = new ReaderNode(nextToken, memberName);
						return true;
					case ReaderToken.Value:
						this.currentNode = new ReaderNode(nextToken, this.frames[this.topFrameIndex].Current);
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						return true;
					case ReaderToken.EndOfObject:
					case ReaderToken.EndOfArray:
						this.PopFrame();
						this.currentNode = new ReaderNode(nextToken);
						return true;
					case ReaderToken.BeginObject:
						var dictionary = (IReadOnlyDictionary<string, object>)this.frames[this.topFrameIndex].Current;
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						this.PushFrame(dictionary);
						this.currentNode = new ReaderNode(nextToken);
						return true;
					case ReaderToken.BeginArray:
						var list = (IReadOnlyList<object>)this.frames[this.topFrameIndex].Current;
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						this.PushFrame(list);
						this.currentNode = new ReaderNode(nextToken);
						return true;
					case ReaderToken.Null:
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						this.currentNode = new ReaderNode(nextToken);
						return true;
				}
			}

			return false;
		}

		private void PushFrame(IReadOnlyDictionary<string, object> dictionary)
		{
			if (this.topFrameIndex == this.frames.Length)
			{
				Array.Resize(ref this.frames, (int)(this.frames.Length * 1.5));
			}

			this.frames[++this.topFrameIndex] = new ReaderFrame(dictionary);
		}
		private void PushFrame(IReadOnlyList<object> list)
		{
			if (this.topFrameIndex == this.frames.Length)
			{
				Array.Resize(ref this.frames, (int)(this.frames.Length * 1.5));
			}

			this.frames[++this.topFrameIndex] = new ReaderFrame(list);
		}
		private void PopFrame()
		{
			this.frames[this.topFrameIndex] = default;
			this.topFrameIndex--;
		}

		/// <inheritdoc />
		public override void Dispose()
		{
			Array.Clear(this.frames, 0, this.frames.Length);
			this.topFrameIndex = -1;
		}

		private struct ReaderFrame
		{
			private bool memberNameVisited;
			private int currentIndex;
			private readonly IReadOnlyList<object> list;
			private readonly IndexedDictionary<string, object> dictionary;

			public string MemberName => this.dictionary?.Keys[this.currentIndex];
			public object Current => this.list != null ? this.list[this.currentIndex] : this.dictionary?[this.dictionary.Keys[this.currentIndex]];
			public ReaderToken ContainerType => this.list != null ? ReaderToken.BeginArray : this.dictionary != null ? ReaderToken.BeginObject : ReaderToken.EndOfStream;
			private bool IsInBounds => this.currentIndex < (this.list?.Count ?? (this.dictionary?.Count ?? 0));

			public ReaderFrame(IReadOnlyList<object> list)
			{
				if (list == null) throw new ArgumentNullException(nameof(list));

				this.dictionary = default;
				this.list = list;
				this.currentIndex = 0;
				this.memberNameVisited = false;
			}
			public ReaderFrame(IReadOnlyDictionary<string, object> dictionary)
			{
				if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));

				this.dictionary = dictionary as IndexedDictionary<string, object> ?? new IndexedDictionary<string, object>(dictionary);
				this.list = default;
				this.currentIndex = 0;
				this.memberNameVisited = false;
			}

			public static void Next(ref ReaderFrame readerFrame)
			{
				readerFrame.currentIndex++;
				readerFrame.memberNameVisited = false;
			}
			public static ReaderToken GetState(ref ReaderFrame readerFrame)
			{
				var isObjectIteration = readerFrame.dictionary != null;
				if (!readerFrame.IsInBounds)
				{
					return isObjectIteration ? ReaderToken.EndOfObject : ReaderToken.EndOfArray;
				}

				if (isObjectIteration && !readerFrame.memberNameVisited)
				{
					readerFrame.memberNameVisited = true;
					return ReaderToken.Member;
				}

				readerFrame.memberNameVisited = false;
				var currentObject = readerFrame.Current;
				if (currentObject is IReadOnlyDictionary<string, object>)
				{
					return ReaderToken.BeginObject;
				}
				else if (currentObject is IReadOnlyList<object>)
				{
					return ReaderToken.BeginArray;
				}
				else
				{
					return currentObject == null ? ReaderToken.Null : ReaderToken.Value;
				}
			}
		}
	}


	public abstract partial class GameDataReader : IDisposable
	{
		public static readonly string[] DateTimeFormats = new string[] { "yyyy-MM-ddTHH:mm:ss.fffZ", "o" };

		public abstract ReaderNode Node { get; }

		public abstract int LineNumber { get; }
		public abstract int ColumnNumber { get; }

		public abstract bool NextToken();

		public bool IsEndOfStream()
		{
			return this.Node.Token == ReaderToken.EndOfStream;
		}
		public bool IsNull()
		{
			return this.Node.Token == ReaderToken.Null;
		}
		public void ThrowIfNotValue()
		{
			if (this.Node.Token != ReaderToken.Value)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.Value);
			}
		}
		public void ThrowIfNull(string expected, string propertyName, string schemaName)
		{
			if (this.Node.Token == ReaderToken.Null)
			{
				throw ReaderException.UnexpectedNullValue(expected, propertyName, schemaName, this);
			}
		}

		public object ReadAny(bool nextToken = true)
		{
			// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
			switch(this.Node.Token)
			{
				case ReaderToken.BeginArray: return this.ReadArray(nextToken);
				case ReaderToken.BeginObject: return this.ReadObject(nextToken);
				case ReaderToken.Null: if (nextToken) this.NextToken(); return null;
				case ReaderToken.Value: var value = this.Node.AsObject; if (nextToken) this.NextToken(); return value;
				default: throw ReaderException.UnexpectedToken(this, ReaderToken.BeginArray, ReaderToken.BeginObject, ReaderToken.Null, ReaderToken.Value);
			}
		}
		public List<object> ReadArray(bool nextToken = true)
		{
			var list = new List<object>();
			this.ReadArrayBegin();
			while(this.Node.Token != ReaderToken.EndOfArray)
			{
				var value = this.ReadAny();
				list.Add(value);
			}
			this.ReadArrayEnd( nextToken);
			return list;
		}
		public IndexedDictionary<string, object> ReadObject(bool nextToken = true)
		{
			var dictionary = new IndexedDictionary<string, object>();
			this.ReadObjectBegin();
			while(this.Node.Token != ReaderToken.EndOfObject)
			{
				var key = this.ReadMember();
				var value = this.ReadAny();
				dictionary[key] = value;
			}
			this.ReadObjectEnd(nextToken);
			return dictionary;
		}
		public void SkipAny(bool nextToken = true)
		{
			// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
			switch(this.Node.Token)
			{
				case ReaderToken.BeginArray: this.SkipArray(nextToken); break;
				case ReaderToken.BeginObject: this.SkipObject(nextToken); break;
				case ReaderToken.Member: if (nextToken) this.NextToken(); break;
				case ReaderToken.Null: if (nextToken) this.NextToken(); break;
				case ReaderToken.Value: if (nextToken) this.NextToken(); break;
				default: throw ReaderException.UnexpectedToken(this, ReaderToken.BeginArray, ReaderToken.BeginObject, ReaderToken.Null, ReaderToken.Value);
			}
		}
		public void SkipArray(bool nextToken = true)
		{
			this.ReadArrayBegin();
			while(this.Node.Token != ReaderToken.EndOfArray)
			{
				this.SkipAny();
			}
			this.ReadArrayEnd( nextToken);
		}
		public void SkipObject(bool nextToken = true)
		{
			this.ReadObjectBegin();
			while(this.Node.Token != ReaderToken.EndOfObject)
			{
				this.SkipAny();
				this.SkipAny();
			}
			this.ReadObjectEnd(nextToken);
		}

		public void ReadArrayBegin(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.BeginArray)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.BeginArray);
			}
			if (this.IsEndOfStream())
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfArray);
			}

			if (nextToken)
				this.NextToken();
		}
		public void ReadArrayEnd(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.EndOfArray)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfArray);
			}

			if (!this.IsEndOfStream() && nextToken)
			{
				this.NextToken();
			}
		}
		public void ReadObjectBegin(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.BeginObject)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.BeginObject);
			}

			if (this.IsEndOfStream())
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfObject);
			}

			if (nextToken)
			{
				this.NextToken();
			}
		}
		public void ReadObjectEnd(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.EndOfObject)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfObject);
			}

			if (!this.IsEndOfStream() && nextToken)
			{
				this.NextToken();
			}
		}
		public string ReadMember(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.Member && this.Node.Token != ReaderToken.Value)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.Member, ReaderToken.Value);
			}

			var memberName = this.Node.AsString;

			if (!this.IsEndOfStream() && nextToken)
			{
				this.NextToken();
			}

			return memberName;
		}

		public string DebugPrintTokens()
		{
			var output = new StringBuilder();
			var stack = new Stack<ReaderToken>();
			stack.Push(ReaderToken.None);
			while (this.NextToken())
			{
				var strValue = Convert.ToString(this.Node.Token, CultureInfo.InvariantCulture) +
					(this.Node.HasValue ? "[" + this.Node.AsString + "]" : "");

				if (stack.Peek() != ReaderToken.Member)
				{
					var endingTokenIndent = this.Node.Token == ReaderToken.EndOfObject || this.Node.Token == ReaderToken.EndOfArray ? -1 : 0;
					output.Append(Environment.NewLine);
					for (var i = 0; i < System.Linq.Enumerable.Count(stack, t => t != ReaderToken.Member && t != ReaderToken.None) + endingTokenIndent; i++)
					{
						output.Append("\t");
					}
				}
				else output.Append(" ");

				output.Append(strValue);

				if (this.Node.Token == ReaderToken.EndOfObject || this.Node.Token == ReaderToken.EndOfArray || stack.Peek() == ReaderToken.Member)
				{
					stack.Pop();
				}
				if (this.Node.Token == ReaderToken.BeginObject || this.Node.Token == ReaderToken.BeginArray || this.Node.Token == ReaderToken.Member)
				{
					stack.Push(this.Node.Token);
				}

			}

			return output.ToString();
		}

		/// <inheritdoc />
		public abstract void Dispose();

		public override string ToString()
		{
			return this.Node.ToString();
		}

	}


	[Serializable, DebuggerDisplay("IndexedDictionary, Count: {" + nameof(Count) + "}")]
	public sealed class IndexedDictionary<KeyT, ValueT> : IDictionary<KeyT, ValueT>, IReadOnlyDictionary<KeyT, ValueT>, IDictionary
	{
		public struct Enumerator : IEnumerator<KeyValuePair<KeyT, ValueT>>, IDictionaryEnumerator
		{
			private List<KeyT>.Enumerator innerEnumerator;
			private readonly IndexedDictionary<KeyT, ValueT> dictionary;

			public Enumerator(IndexedDictionary<KeyT, ValueT> dictionary)
			{
				this.dictionary = dictionary;
				this.innerEnumerator = dictionary.keys.GetEnumerator();
				this.Current = new KeyValuePair<KeyT, ValueT>();
			}

			public KeyValuePair<KeyT, ValueT> Current { get; private set; }
			object IEnumerator.Current => this.Current;
			public object Key => this.Current.Key;
			public object Value => this.Current.Value;
			public DictionaryEntry Entry => ToEntry(this.Current);

			public bool MoveNext()
			{
				if (!this.innerEnumerator.MoveNext()) return false;

				var key = this.innerEnumerator.Current;

				Debug.Assert(!ReferenceEquals(key, null), "key is null");

				this.Current = new KeyValuePair<KeyT, ValueT>(key, this.dictionary.dictionary[key]);
				return true;
			}
			public void Reset()
			{
				this.innerEnumerator = this.dictionary.keys.GetEnumerator();
			}
			public void Dispose()
			{
				this.innerEnumerator.Dispose();
			}
		}

		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] private readonly Dictionary<KeyT, ValueT> dictionary;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly List<KeyT> keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never), NonSerialized] private ReadOnlyCollection<KeyT> keysReadOnly;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)] public ReadOnlyCollection<KeyT> Keys => this.keysReadOnly ?? (this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys));
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] public Dictionary<KeyT, ValueT>.ValueCollection Values => this.dictionary.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool ICollection<KeyValuePair<KeyT, ValueT>>.IsReadOnly => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection<KeyT> IDictionary<KeyT, ValueT>.Keys => this.Keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] IEnumerable<ValueT> IReadOnlyDictionary<KeyT, ValueT>.Values => this.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] IEnumerable<KeyT> IReadOnlyDictionary<KeyT, ValueT>.Keys => this.Keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection<ValueT> IDictionary<KeyT, ValueT>.Values => this.dictionary.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection IDictionary.Values => this.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection IDictionary.Keys => this.Keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool IDictionary.IsReadOnly => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool IDictionary.IsFixedSize => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] object ICollection.SyncRoot => this.dictionary;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool ICollection.IsSynchronized => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		object IDictionary.this[object key]
		{
			get => this[CastKey(key)];
			set => this[CastKey(key)] = CastValue(value);
		}

		public int Count => this.dictionary.Count;

		public ValueT this[KeyT key]
		{
			get => this.dictionary[key];
			set
			{
				if (this.dictionary.ContainsKey(key) == false) this.keys.Add(key);
				this.dictionary[key] = value;
			}
		}

		public IndexedDictionary()
		{
			this.dictionary = new Dictionary<KeyT, ValueT>();
			this.keys = new List<KeyT>();
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}
		public IndexedDictionary(int count)
		{
			if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));

			if (count == 0) count = 30;

			this.dictionary = new Dictionary<KeyT, ValueT>(count);
			this.keys = new List<KeyT>(count);
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}
		public IndexedDictionary(IDictionary<KeyT, ValueT> dictionary)
		{
			if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));

			this.dictionary = new Dictionary<KeyT, ValueT>(dictionary);
			this.keys = new List<KeyT>(dictionary.Keys);
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}
		public IndexedDictionary(IEnumerable<KeyValuePair<KeyT, ValueT>> pairs)
		{
			if (pairs == null) throw new ArgumentNullException(nameof(pairs));

			this.dictionary = new Dictionary<KeyT, ValueT>();
			this.keys = new List<KeyT>();
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);

			foreach (var pair in pairs)
			{
				this.Add(pair.Key, pair.Value);
			}
		}
		public IndexedDictionary(IDictionary<KeyT, ValueT> dictionary, ICollection<KeyT> keys)
		{
			if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));
			if (keys == null) throw new ArgumentNullException(nameof(keys));

			this.dictionary = new Dictionary<KeyT, ValueT>(dictionary);
			this.keys = new List<KeyT>(keys);
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}

		public void Add(KeyT key, ValueT value)
		{
			this.dictionary.Add(key, value);
			this.keys.Add(key);
		}
		public void Add(IndexedDictionary<KeyT, ValueT> other)
		{
			if (other == null) throw new ArgumentNullException(nameof(other));

			if (this.Count == 0)
			{
				this.keys.AddRange(other.keys);
				foreach (var kv in other.dictionary)
				{
					this.dictionary.Add(kv.Key, kv.Value);
				}
			}
			else
			{
				foreach (var kv in other.dictionary)
				{
					this.dictionary.Add(kv.Key, kv.Value);
					this.keys.Add(kv.Key);
				}
			}
		}

		public void Insert(int index, KeyT key, ValueT value)
		{
			// Dictionary operation first, so exception thrown if key already exists.
			this.dictionary.Add(key, value);
			this.keys.Insert(index, key);
		}
		public bool ContainsKey(KeyT key)
		{
			return this.dictionary.ContainsKey(key);
		}
		public bool ContainsKey(KeyT key, IEqualityComparer<KeyT> keyComparer)
		{
			if (keyComparer == null) throw new ArgumentNullException(nameof(keyComparer));

			foreach (var k in this.keys)
			{
				if (keyComparer.Equals(k, key))
				{
					return true;
				}
			}

			return false;
		}
		public bool ContainsValue(ValueT value)
		{
			foreach (var kv in this.dictionary)
			{
				if (Equals(value, kv.Value))
				{
					return true;
				}
			}

			return false;
		}
		public bool ContainsValue(ValueT value, IEqualityComparer comparer)
		{
			if (comparer == null) throw new ArgumentNullException(nameof(comparer));

			foreach (var kv in this.dictionary)
			{
				if (comparer.Equals(value, kv.Value))
				{
					return true;
				}
			}

			return false;
		}
		public bool Remove(KeyT key)
		{
			var wasInDictionary = this.dictionary.Remove(key);
			this.keys.Remove(key);

			return wasInDictionary;
		}

		public bool TryGetValue(KeyT key, out ValueT value)
		{
			return this.dictionary.TryGetValue(key, out value);
		}

		public int IndexOf(KeyT key)
		{
			return this.keys.IndexOf(key);
		}
		public void RemoveAt(int index)
		{
			if (index >= this.Count || index < 0) throw new ArgumentOutOfRangeException(nameof(index));

			var key = this.keys[index];
			this.dictionary.Remove(key);
			this.keys.RemoveAt(index);
		}
		public void SortKeys(IComparer<KeyT> comparer)
		{
			if (comparer == null) throw new ArgumentNullException(nameof(comparer));

			this.keys.Sort(comparer);
		}

		public void Clear()
		{
			this.dictionary.Clear();
			this.keys.Clear();
		}

		bool IDictionary.Contains(object key)
		{
			return this.ContainsKey(CastKey(key));
		}
		void IDictionary.Add(object key, object value)
		{
			this.Add(CastKey(key), CastValue(value));
		}
		void IDictionary.Remove(object key)
		{
			this.Remove(CastKey(key));
		}
		void ICollection.CopyTo(Array array, int index)
		{
			foreach (var pair in this)
			{
				array.SetValue(ToEntry(pair), index++);
			}
		}

		void ICollection<KeyValuePair<KeyT, ValueT>>.Add(KeyValuePair<KeyT, ValueT> item)
		{
			this.Add(item.Key, item.Value);
		}
		bool ICollection<KeyValuePair<KeyT, ValueT>>.Contains(KeyValuePair<KeyT, ValueT> item)
		{
			return this.dictionary.TryGetValue(item.Key, out var value) && Equals(value, item.Value);
		}
		void ICollection<KeyValuePair<KeyT, ValueT>>.CopyTo(KeyValuePair<KeyT, ValueT>[] array, int arrayIndex)
		{
			foreach (var pair in this)
			{
				array[arrayIndex++] = pair;
			}
		}
		bool ICollection<KeyValuePair<KeyT, ValueT>>.Remove(KeyValuePair<KeyT, ValueT> item)
		{
			if (((ICollection<KeyValuePair<KeyT, ValueT>>)this).Contains(item) == false)
			{
				return false;
			}

			return this.Remove(item.Key);
		}
		IEnumerator<KeyValuePair<KeyT, ValueT>> IEnumerable<KeyValuePair<KeyT, ValueT>>.GetEnumerator()
		{
			return this.GetEnumerator();
		}

		IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return this.GetEnumerator();
		}
		IEnumerator IEnumerable.GetEnumerator()
		{
			return this.GetEnumerator();
		}
		public Enumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		private static ValueT CastValue(object value)
		{
			if (value == null) return default;

			return (ValueT)value;
		}
		private static KeyT CastKey(object key)
		{
			if (key == null) throw new ArgumentNullException(nameof(key));

			return (KeyT)key;
		}
		private static DictionaryEntry ToEntry(KeyValuePair<KeyT, ValueT> value)
		{
			return new DictionaryEntry(value.Key, value.Value);
		}

		public override string ToString()
		{
			return "Count: " + Convert.ToString(this.Count, CultureInfo.InvariantCulture);
		}
	}


	public class IndexedString : IComparable<IndexedString>
	{
		public readonly string Value;
		public readonly ulong[] Octets;

		public IndexedString(string value)
		{
			this.Value = value;
			this.Octets = new ulong[8];
			for (var i = 0; i < 8; i++)
			{
				this.Octets[i] = GetUInt64(value, 8 * i);
			}
		}

		public int CompareTo(IndexedString otherString)
		{
			if (this.Value.Length != otherString.Value.Length)
			{
				return this.Value.Length.CompareTo(otherString.Value.Length);
			}

			for (var i = 0; i < this.Octets.Length; i++)
			{
				var comp = this.Octets[i].CompareTo(otherString.Octets[i]);
				if (comp != 0)
				{
					return comp;
				}
			}

			return 0;
		}

		private static ulong GetUInt64(string chars, int offset)
		{
			if (offset >= chars.Length)
			{
				return 0;
			}

			var result = 0L;
			var bytesToConvert = Math.Min(chars.Length - offset, 8);
			for (var i = 0; i < bytesToConvert; i++)
			{
				result = unchecked((result << 8) | chars[offset + bytesToConvert - 1 - i]);
			}

			return unchecked((ulong)result);
		}
	}


	public interface IStrongBox
	{
		bool AsBoolean { get; }
		byte AsByte { get; }
		short AsInt16 { get; }
		int AsInt32 { get; }
		long AsInt64 { get; }
		sbyte AsSByte { get; }
		ushort AsUInt16 { get; }
		uint AsUInt32 { get; }
		ulong AsUInt64 { get; }
		float AsSingle { get; }
		double AsDouble { get; }
		decimal AsDecimal { get; }
		DateTimeOffset AsDateTimeOffset { get; }
		DateTime AsDateTime { get; }
		TimeSpan AsTimeSpan { get; }
		Type ValueType { get; }
		object AsObject { get; }

		void Store<T>(T value);
	}


	public sealed class JsonGameDataReader : GameDataReader
	{
		private const int DEFAULT_BUFFER_SIZE = ushort.MaxValue / 2;
		private const int CHAR_SIZE = 2;

		const int LEXER_STATE_COMPLETE = -1;
		const int LEXER_STATE_START = 0;
		const int LEXER_STATE_LEXEME = 1;
		const int LEXER_STATE_QUOTED = 2;
		const int LEXER_STATE_QUOTED_ESCAPE = 3;
		const int LEXER_STATE_COMMENT_BEGINNING = 4;
		const int LEXER_STATE_COMMENT_SINGLE_LINE = 5;
		const int LEXER_STATE_COMMENT_MULTILINE = 6;
		const int LEXER_STATE_COMMENT_MULTILINE_ENDING = 7;

		private const int NUMBER_FLOAT = 2;
		private const int NUMBER_FLOAT_WITH_EXP = 3;
		private const int NUMBER_INTEGER = 0;
		private const int NUMBER_NEGATIVE_INTEGER = 1;
		private const int NUMBER_NOT = -1;

		private static readonly int Int32MaxLength = int.MaxValue.ToString().Length;
		private static readonly int Int64MaxLength = long.MaxValue.ToString().Length;

		private readonly ArraySegment<char> lexemeTrue = new ArraySegment<char>(JsonNotation.True.ToCharArray(), 0, 4);
		private readonly ArraySegment<char> lexemeFalse = new ArraySegment<char>(JsonNotation.False.ToCharArray(), 0, 5);
		private readonly ArraySegment<char> lexemeNull = new ArraySegment<char>(JsonNotation.Null.ToCharArray(), 0, 4);

		private readonly bool leaveOpen;
		private readonly TextReader textReader;
		private readonly Stack<ReaderToken> structure;

		// tokenizing
		private readonly char[] buffer;
		private int bufferOffset;
		private int bufferAvailable;
		private int lineNum = 1;
		private int colNum = 1;

		// parsing
		private ReaderNode node;
		private ArraySegment<char> rawJson;

		private StrongBox<bool> trueBox;
		private StrongBox<bool> falseBox;
		private StrongBox<int> intBox;
		private StrongBox<DateTime> dateBox;
		private JsonValueBox jsonValueBox;

		public override ReaderNode Node { get { if (this.node.Token == ReaderToken.None) this.NextToken(); return this.node; } }

		// statistics
		public override int LineNumber => this.lineNum;
		public override int ColumnNumber => this.colNum;

		public JsonGameDataReader(Stream stream, Encoding encoding, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE)
			: this(new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: true, leaveOpen: leaveOpen, bufferSize: bufferSize), leaveOpen, bufferSize)
		{

		}
		public JsonGameDataReader(TextReader textReader, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE)
		{
			if (textReader == null) throw new ArgumentNullException(nameof(textReader));
			if (bufferSize <= 0) throw new ArgumentOutOfRangeException(nameof(bufferSize));

			this.structure = new Stack<ReaderToken>();
			this.buffer = new char[bufferSize];
			this.textReader = textReader;
			this.leaveOpen = leaveOpen;
		}

		public override bool NextToken()
		{
			this.rawJson = default;
			this.node = default;

			var fragments = default(ArraySegment<char>[]);
			var state = LEXER_STATE_COMPLETE;
			var lexemeSize = 0;
			var memberOrValueToken = ReaderToken.Value;

			if (this.structure.Count > 0)
			{
				// ReSharper disable once SwitchStatementMissingSomeCases
				switch (this.structure.Peek())
				{
					case ReaderToken.Member:
						this.structure.Pop();
						break;
					case ReaderToken.BeginObject:
						this.structure.Push(memberOrValueToken = ReaderToken.Member);
						break;
				}
			}

			var lexeme = this.NextLexeme(ref state);
			if (lexeme.Count == 0)
			{
				this.node = new ReaderNode(ReaderToken.EndOfStream);
				return false;
			}
			if (state != LEXER_STATE_COMPLETE)
			{
				var firstFragment = Copy(ref lexeme);
				var secondFragment = this.NextLexeme(ref state);

				if (state == LEXER_STATE_COMPLETE)
				{
					if (secondFragment.Count == 0)
					{
						lexeme = firstFragment;
						lexemeSize = lexeme.Count;
					}
					else
					{
						fragments = new[] { firstFragment, secondFragment };
						lexemeSize = firstFragment.Count + secondFragment.Count;
					}
				}
				else
				{
					var fragmentIndex = 0;
					fragments = new ArraySegment<char>[8];
					fragments[fragmentIndex++] = firstFragment;
					fragments[fragmentIndex++] = Copy(ref secondFragment);
					lexemeSize = firstFragment.Count + secondFragment.Count;

					do
					{
						lexeme = this.NextLexeme(ref state);

						if (lexeme.Count == 0)
						{
							break;
						}
						if (fragmentIndex == fragments.Length)
						{
							Array.Resize(ref fragments, (int)(fragments.Length * 1.5));
						}

						fragments[fragmentIndex++] = Copy(ref lexeme);
						lexemeSize += lexeme.Count;

					} while (state != LEXER_STATE_COMPLETE);
				}
			}
			else
			{
				lexemeSize = lexeme.Count;
			}

			if (lexemeSize == 1)
			{
				this.rawJson = fragments != null ? fragments[0] : lexeme;
				System.Diagnostics.Debug.Assert(this.rawJson.Array != null, "this.rawJson.Array");
				switch (this.rawJson.Array[this.rawJson.Offset])
				{
					case JsonNotation.Const0: this.node = new ReaderNode(memberOrValueToken, this.Box(0)); return true;
					case JsonNotation.Const1: this.node = new ReaderNode(memberOrValueToken, this.Box(1)); return true;
					case JsonNotation.Const2: this.node = new ReaderNode(memberOrValueToken, this.Box(2)); return true;
					case JsonNotation.Const3: this.node = new ReaderNode(memberOrValueToken, this.Box(3)); return true;
					case JsonNotation.Const4: this.node = new ReaderNode(memberOrValueToken, this.Box(4)); return true;
					case JsonNotation.Const5: this.node = new ReaderNode(memberOrValueToken, this.Box(5)); return true;
					case JsonNotation.Const6: this.node = new ReaderNode(memberOrValueToken, this.Box(6)); return true;
					case JsonNotation.Const7: this.node = new ReaderNode(memberOrValueToken, this.Box(7)); return true;
					case JsonNotation.Const8: this.node = new ReaderNode(memberOrValueToken, this.Box(8)); return true;
					case JsonNotation.Const9: this.node = new ReaderNode(memberOrValueToken, this.Box(9)); return true;
					case JsonNotation.BeginArray:
						this.structure.Push(ReaderToken.BeginArray);
						this.node = new ReaderNode(ReaderToken.BeginArray);
						return true;
					case JsonNotation.BeginObject:
						this.structure.Push(ReaderToken.BeginObject);
						this.node = new ReaderNode(ReaderToken.BeginObject);
						return true;
					case JsonNotation.EndArray:
						this.structure.Pop();
						this.node = new ReaderNode(ReaderToken.EndOfArray);
						return true;
					case JsonNotation.EndObject:
						this.structure.Pop();
						this.structure.Pop();
						this.node = new ReaderNode(ReaderToken.EndOfObject);
						return true;
					default: throw ReaderException.UnknownNotation(this, new string(this.rawJson.Array, this.rawJson.Offset, this.rawJson.Count));
				}
			}
			if (lexemeSize == 4)
			{
				if (Match(ref lexeme, fragments, 0, this.lexemeTrue))
				{
					this.rawJson = this.lexemeTrue;
					this.node = new ReaderNode(memberOrValueToken, this.Box(true));
					return true;
				}
				if (Match(ref lexeme, fragments, 0, this.lexemeNull))
				{
					this.rawJson = this.lexemeNull;
					this.node = new ReaderNode(ReaderToken.Null);
					return true;
				}
			}
			if (lexemeSize == 5 && Match(ref lexeme, fragments, 0, this.lexemeFalse))
			{
				this.rawJson = this.lexemeFalse;
				this.node = new ReaderNode(memberOrValueToken, this.Box(false));
				return true;
			}

			// combine fragments into one lexeme
			if (fragments != null)
			{
				var combined = new char[lexemeSize];
				var offset = 0;
				foreach (var fragment in fragments)
				{
					if (fragment.Array == null) break;
					Buffer.BlockCopy(fragment.Array, fragment.Offset * CHAR_SIZE, combined, offset * CHAR_SIZE, fragment.Count * CHAR_SIZE);
					offset += fragment.Count;
				}
				lexeme = new ArraySegment<char>(combined, 0, offset);
				//fragments = null;
			}

			this.rawJson = lexeme;
			System.Diagnostics.Debug.Assert(lexeme.Array != null, "lexeme.Array");
			if (lexeme.Array[lexeme.Offset] == JsonNotation.Quote) // start with quote
			{
				if (lexeme.Array[lexeme.Offset + lexeme.Count - 1] != JsonNotation.Quote) // not ending with quote
					throw ReaderException.UnterminatedStringLiteral(this);

				if (lexemeSize == 2)
				{
					this.node = new ReaderNode(memberOrValueToken, string.Empty);
					return true;
				}

				this.node = new ReaderNode(memberOrValueToken, this.Box(ref lexeme));
				return true;
			}

			switch (GetNumberType(ref lexeme))
			{
				case NUMBER_INTEGER:
					var integerType = lexeme.Count < Int32MaxLength
						? typeof(int)
						: lexeme.Count < Int64MaxLength ? typeof(long) : typeof(ulong);
					this.node = new ReaderNode(memberOrValueToken, this.Box(ref lexeme, integerType));
					return true;
				case NUMBER_NEGATIVE_INTEGER:
					var signedIntegerType = lexeme.Count < Int32MaxLength + 1 ? typeof(int) : typeof(long);
					this.node = new ReaderNode(memberOrValueToken, this.Box(ref lexeme, signedIntegerType));
					return true;
				case NUMBER_FLOAT:
				case NUMBER_FLOAT_WITH_EXP:
					this.node = new ReaderNode(memberOrValueToken, this.Box(ref lexeme, typeof(double)));
					return true;
				default:
					System.Diagnostics.Debug.Assert(this.rawJson.Array != null, "rawJsonArray");
					throw ReaderException.UnknownNotation(this, new string(this.rawJson.Array, this.rawJson.Offset, this.rawJson.Count));
			}
		}

		private object Box(ref ArraySegment<char> lexeme, Type type = default)
		{
			var jsonValueBox = this.jsonValueBox ?? (this.jsonValueBox = new JsonValueBox());
			jsonValueBox.Store(lexeme, type ?? typeof(string));
			return jsonValueBox;
		}
		private object Box(int value)
		{
			var intBox = this.intBox ?? (this.intBox = new StrongBox<int>(CultureInfo.InvariantCulture));
			intBox.Store(value);
			return intBox;
		}
		private object Box(DateTime value)
		{
			var dateBox = this.dateBox ?? (this.dateBox = new StrongBox<DateTime>(CultureInfo.InvariantCulture));
			dateBox.Store(value);
			return dateBox;
		}
		private object Box(bool value)
		{
			if (value)
			{
				return this.trueBox ?? (this.trueBox = new StrongBox<bool>(true, CultureInfo.InvariantCulture));
			}
			return this.falseBox ?? (this.falseBox = new StrongBox<bool>(false, CultureInfo.InvariantCulture));
		}

		private static bool Match(ref ArraySegment<char> lexeme, ArraySegment<char>[] fragments, int offset, ArraySegment<char> matchTo)
		{
			var lexemeArray = lexeme.Array;
			System.Diagnostics.Debug.Assert(lexemeArray != null, "lexemeArray != null");

			var matchToArray = matchTo.Array;
			System.Diagnostics.Debug.Assert(matchToArray != null, "matchToArray != null");

			var count = matchTo.Count;
			if (fragments == null)
			{
				for (var i = 0; i < count; i++)
				{
					if (lexemeArray[lexeme.Offset + i] != matchToArray[matchTo.Offset + i])
						return false;
				}

				return true;
			}
			var mo = 0;
			foreach (var fg in fragments)
			{
				if (fg.Array == null) break;

				for (var i = 0; i < fg.Count; i++)
				{
					if (fg.Array[fg.Offset + i] != matchToArray[mo])
						return false;

					mo++;
				}
			}

			return true;
		}
		private static int GetNumberType(ref ArraySegment<char> lexeme)
		{
			const int INT_PART = 0;
			const int FRAC_PART = 1;
			const int EXP_PART = 2;
			const char POINT = '.';
			const char EXPONENT = 'E';
			const char EXPONENT_ALT = 'e';
			const char PLUS = '+';
			const char MINUS = '-';
			const char DIGIT_START = '0';
			const char DIGIT_END = '9';

			var isNegative = false;
			var buffer = lexeme.Array;
			var offset = lexeme.Offset;
			var count = lexeme.Offset + lexeme.Count;

			System.Diagnostics.Debug.Assert(buffer != null, "buffer != null");

			var part = INT_PART;

			for (var i = offset; i < count; i++)
			{
				var character = buffer[i];

				switch (part)
				{
					case INT_PART:
						switch (character)
						{
							case MINUS:
								if (i != offset)
								{
									return NUMBER_NOT;
								}
								isNegative = true;
								break;
							case PLUS:
								if (i != offset)
								{
									return NUMBER_NOT;
								}
								break;
							case POINT:
								if (i == offset)
								{
									return NUMBER_NOT; // decimal point as first character
								}
								part = FRAC_PART;
								break;
							default:
								if (character == EXPONENT || character == EXPONENT_ALT)
								{
									if (i == offset)
									{
										return NUMBER_NOT; // exponent at first character
									}
									part = EXP_PART;
								}
								else if (character < DIGIT_START && character > DIGIT_END)
								{
									return NUMBER_NOT; // non digit character in integer part
								}
								break;
						}
						break;
					case FRAC_PART:
						if (character == EXPONENT || character == EXPONENT_ALT)
						{
							if (i == offset)
							{
								return NUMBER_NOT; // exponent at first character
							}
							part = EXP_PART;
						}
						else if (character < DIGIT_START && character > DIGIT_END)
						{
							return NUMBER_NOT; // non digit character in fraction part
						}
						break;
					case EXP_PART:
						if (character == PLUS || character == MINUS)
						{
							if (buffer[i - 1] != EXPONENT && buffer[i - 1] != EXPONENT_ALT)
							{
								return NUMBER_NOT; // sign not at start of exponent part
							}
						}
						else if (character < DIGIT_START && character > DIGIT_END)
						{
							return NUMBER_NOT; // non digit character in integer part
						}
						break;
				}
			}

			switch (part)
			{
				case INT_PART: return isNegative ? NUMBER_NEGATIVE_INTEGER : NUMBER_INTEGER;
				case FRAC_PART: return NUMBER_FLOAT;
				case EXP_PART: return NUMBER_FLOAT_WITH_EXP;
				default: return NUMBER_NOT;
			}
		}
		private static ArraySegment<char> Copy(ref ArraySegment<char> lexeme)
		{
			var lexemeArray = lexeme.Array;

			var newLexemeArray = new char[lexeme.Count];
			var newLexeme = new ArraySegment<char>(newLexemeArray, 0, lexeme.Count);

			System.Diagnostics.Debug.Assert(lexemeArray != null, "lexemeArray != null");

			Buffer.BlockCopy(lexemeArray, lexeme.Offset * CHAR_SIZE, newLexemeArray, 0, lexeme.Count * CHAR_SIZE);
			return newLexeme;
		}
		private static bool IsWhiteSpaceLatin(char character)
		{
			return character == ' ' || character >= '\t' && character <= '\r' || (character == ' ' || character == '\x0085');
		}
		private ArraySegment<char> NextLexeme(ref int state)
		{
			this.ResetBufferIfNeeded();

			var buffer = this.buffer;
			var lexemeStartIndex = this.bufferOffset;
			var lexemeLength = 0;

			start:
			if (this.bufferAvailable == 0 && this.ReadToBuffer() == 0)
			{
				state = LEXER_STATE_COMPLETE;
				return new ArraySegment<char>(this.buffer, lexemeStartIndex, lexemeLength);
			}

			if (state == LEXER_STATE_COMPLETE)
				state = LEXER_STATE_START;

			var bufferEnd = this.bufferOffset + this.bufferAvailable;
			for (var i = this.bufferOffset; i < bufferEnd; i++)
			{
				this.colNum++;
				switch (state)
				{
					case LEXER_STATE_START:
						switch (buffer[i])
						{
							case JsonNotation.Newline: this.lineNum++; this.colNum = 1; goto case JsonNotation.Space;
							case JsonNotation.Space:
							case JsonNotation.Return:
							case JsonNotation.Tab:
							case JsonNotation.IdentifierSeparator:
								continue; // insignificant whitespaces
							case JsonNotation.ValueSeparator:
								if (this.structure.Peek() == ReaderToken.BeginObject) throw ReaderException.ReadingBrokenDocument(this, "A value is expected");

								continue;
							case JsonNotation.Comment:
								state = LEXER_STATE_COMMENT_BEGINNING;
								continue;
							case JsonNotation.EndArray:
							case JsonNotation.EndObject:
							case JsonNotation.BeginObject:
							case JsonNotation.BeginArray:
								state = LEXER_STATE_COMPLETE;
								this.bufferOffset = i + 1;
								this.bufferAvailable = bufferEnd - i - 1;
								return new ArraySegment<char>(buffer, i, 1);
							case JsonNotation.Quote:
								lexemeStartIndex = i;
								state = LEXER_STATE_QUOTED;
								continue;
							default:
								if (IsWhiteSpaceLatin(buffer[i]))
								{
									goto case JsonNotation.Space;
								}
								lexemeStartIndex = i;
								state = LEXER_STATE_LEXEME;
								continue;
						}
					case LEXER_STATE_LEXEME:
						switch (buffer[i])
						{
							// lexeme terminators
							case JsonNotation.Space:
							case JsonNotation.Newline:
							case JsonNotation.Return:
							case JsonNotation.Tab:
							case JsonNotation.IdentifierSeparator:
							case JsonNotation.ValueSeparator:
							case JsonNotation.EndArray:
							case JsonNotation.EndObject:
							case JsonNotation.BeginObject:
							case JsonNotation.BeginArray:
								state = LEXER_STATE_COMPLETE;
								this.bufferOffset = i;
								this.bufferAvailable = bufferEnd - i;
								return new ArraySegment<char>(buffer, lexemeStartIndex, i - lexemeStartIndex);
							default:
								if (IsWhiteSpaceLatin(buffer[i]))
								{
									goto case JsonNotation.Space;
								}
								continue;
						}
					case LEXER_STATE_QUOTED:
					case LEXER_STATE_QUOTED_ESCAPE:
						switch (buffer[i])
						{
							case JsonNotation.Newline:
							case JsonNotation.Return:
								throw ReaderException.UnterminatedStringLiteral(this);
							case JsonNotation.Quote:
								if (state == LEXER_STATE_QUOTED_ESCAPE)
								{
									state = LEXER_STATE_QUOTED;
									continue;
								}

								state = LEXER_STATE_COMPLETE;
								this.bufferOffset = i + 1;
								this.bufferAvailable = bufferEnd - i - 1;
								return new ArraySegment<char>(buffer, lexemeStartIndex, i - lexemeStartIndex + 1);
							case JsonNotation.Escape:
								state = LEXER_STATE_QUOTED_ESCAPE; // skips escaped quotes - \"
								continue;
							default:
								if (state == LEXER_STATE_QUOTED_ESCAPE)
								{
									state = LEXER_STATE_QUOTED;
								}
								continue;
						}
					case LEXER_STATE_COMMENT_BEGINNING:
						switch (buffer[i])
						{
							case JsonNotation.Comment:
								state = LEXER_STATE_COMMENT_SINGLE_LINE;
								continue;
							case JsonNotation.CommentMultiline:
								state = LEXER_STATE_COMMENT_MULTILINE;
								continue;
							default:
								throw ReaderException.UnknownNotation(this, JsonNotation.Comment + buffer[i].ToString());
						}
					case LEXER_STATE_COMMENT_SINGLE_LINE:
						switch (buffer[i])
						{
							case JsonNotation.Newline:
							case JsonNotation.Return:
								state = LEXER_STATE_START;
								continue;
							default: continue;
						}
					case LEXER_STATE_COMMENT_MULTILINE_ENDING:
					case LEXER_STATE_COMMENT_MULTILINE:
						switch (buffer[i])
						{
							case JsonNotation.CommentMultiline:
								state = LEXER_STATE_COMMENT_MULTILINE_ENDING;
								continue;
							case JsonNotation.Comment:
								if (state == LEXER_STATE_COMMENT_MULTILINE_ENDING)
									state = LEXER_STATE_START;
								continue;
							default: continue;
						}

				}
			}

			if (state == LEXER_STATE_START || state == LEXER_STATE_COMMENT_BEGINNING || state == LEXER_STATE_COMMENT_MULTILINE ||
				state == LEXER_STATE_COMMENT_MULTILINE_ENDING || state == LEXER_STATE_COMMENT_SINGLE_LINE)
			{
				// no lexemes found in current buffer
				this.bufferOffset = this.bufferAvailable = lexemeStartIndex = lexemeLength = 0;
				goto start; // restart
			}

			lexemeLength = bufferEnd - lexemeStartIndex;

			// buffer contains only fragment of lexeme
			// lexeme parsing is not complete so there is 2 options:
			// 1) try to fill buffer and retry parsing
			// 2) return fragment to caller

			if (lexemeLength < this.buffer.Length / 2)
			{
				// if fragment is small then move fragment to the start of the buffer and re-start parsing
				if (lexemeStartIndex != 0)
				{
					Buffer.BlockCopy(this.buffer, lexemeStartIndex * CHAR_SIZE, this.buffer, 0, lexemeLength * CHAR_SIZE);
					lexemeStartIndex = 0;
				}

				this.bufferOffset = lexemeLength;
				this.bufferAvailable = 0;

				goto start; // restart
			}
			else
			{
				// if fragment is huge then return it to caller

				// set buffer is consumed
				this.bufferOffset = this.bufferAvailable = 0;

				return new ArraySegment<char>(this.buffer, lexemeStartIndex, lexemeLength);
			}
		}
		private void ResetBufferIfNeeded()
		{
			if (this.bufferAvailable == 0)
			{
				this.bufferOffset = 0;
			}
		}
		private int ReadToBuffer()
		{
			if (this.bufferOffset + this.bufferAvailable >= this.buffer.Length)
			{
				throw new InvalidOperationException("Unable to read to buffer because there is not space available. This will cause zero read and erroneous 'End Of Stream' message.");
			}

			var offset = this.bufferOffset + this.bufferAvailable;
			var count = this.buffer.Length - offset;
			var read = this.textReader.Read(this.buffer, offset, count);
			this.bufferAvailable += read;
			return read;
		}

		public override void Dispose()
		{
			if (!this.leaveOpen)
			{
				this.textReader.Dispose();
			}
		}

		private sealed class JsonValueBox : IStrongBox
		{
			private ArraySegment<char> value;
			private Type valueType;

			public Type ValueType => this.valueType;

			public bool AsBoolean => Convert.ToBoolean(this.LoadString(), CultureInfo.InvariantCulture);
			public byte AsByte => checked((byte)this.LoadUInt32());
			public short AsInt16 => checked((short)this.LoadInt32());
			public int AsInt32 => this.LoadInt32();
			public long AsInt64 => this.LoadInt64();
			public sbyte AsSByte => checked((sbyte)this.LoadInt32());
			public ushort AsUInt16 => checked((ushort)this.LoadUInt32());
			public uint AsUInt32 => this.LoadUInt32();
			public ulong AsUInt64 => this.LoadUInt64();
			public float AsSingle => Convert.ToSingle(this.LoadString(), CultureInfo.InvariantCulture);
			public double AsDouble => Convert.ToDouble(this.LoadString(), CultureInfo.InvariantCulture);
			public decimal AsDecimal => Convert.ToDecimal(this.LoadString(), CultureInfo.InvariantCulture);
			public DateTimeOffset AsDateTimeOffset => DateTimeOffset.ParseExact(this.LoadString(), GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
			public DateTime AsDateTime => DateTime.ParseExact(this.LoadString(), GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
			public TimeSpan AsTimeSpan => TimeSpan.Parse(this.LoadString(), CultureInfo.InvariantCulture);
			public object AsObject => this.LoadString();

			private uint LoadUInt32()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.StringToUInt32(array, offset, count);
			}
			private ulong LoadUInt64()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.StringToUInt64(array, offset, count);
			}
			private int LoadInt32()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.StringToInt32(array, offset, count);
			}
			private long LoadInt64()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.StringToInt64(array, offset, count);
			}
			private string LoadString()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.UnEscapeBuffer(array, offset, count, false);
			}

			public void Store<T>(T value)
			{
				this.value = (ArraySegment<char>)(object)value;
				this.valueType = typeof(string);
			}

			public void Store(ArraySegment<char> value, Type valueType)
			{
				if (valueType == null) throw new ArgumentNullException(nameof(valueType));

				this.value = value;
				this.valueType = valueType;
			}

			public override string ToString()
			{
				return this.LoadString();
			}
		}

		private static class JsonUtils
		{
			public static string UnEscapeBuffer(char[] charsToUnEscape, int offset, int count, bool strict)
			{
				if (charsToUnEscape == null) throw new ArgumentNullException(nameof(charsToUnEscape));
				if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
				if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
				if (offset + count > charsToUnEscape.Length) throw new ArgumentOutOfRangeException(nameof(offset));

				var unEscapedCount = GetUnEscapedCount(charsToUnEscape, offset, count);
				if (unEscapedCount == count)
				{
					return new string(charsToUnEscape, offset, count);
				}

				var resultBuilder = new StringBuilder(unEscapedCount);
				var plainStart = offset;
				var plainLen = 0;
				var end = offset + count;
				for (var i = offset; i < end; i++)
				{
					var ch = charsToUnEscape[i];
					if (ch != '\\')
					{
						plainLen++;
						continue;
					}

					if (i + 1 >= end)
					{
						if (strict)
						{
							throw ReaderException.UnknownEscapeSequence("\\\0", null);
						}
						else
						{
							plainLen++;
							break; // u
						}
					}

					var sequenceLength = 1;
					// append unencoded chunk
					if (plainLen != 0)
					{
						resultBuilder.Append(charsToUnEscape, plainStart, plainLen);
						plainLen = 0;
					}

					var sequenceKind = charsToUnEscape[i + 1];
					switch (sequenceKind)
					{
						case 'n':
							resultBuilder.Append('\n');
							break;
						case 'r':
							resultBuilder.Append('\r');
							break;
						case 'b':
							resultBuilder.Append('\b');
							break;
						case 'f':
							resultBuilder.Append('\f');
							break;
						case 't':
							resultBuilder.Append('\t');
							break;
						case '\\':
							resultBuilder.Append('\\');
							break;
						case '/':
							resultBuilder.Append('/');
							break;
						case '\'':
							resultBuilder.Append('\'');
							break;
						case '\"':
							resultBuilder.Append('\"');
							break;

						// unicode symbol
						case 'u':
							resultBuilder.Append((char)HexStringToUInt32(charsToUnEscape, i + 2, 4));
							sequenceLength = 5;
							break;

						// latin hex encoded symbol
						case 'x':
							resultBuilder.Append((char)HexStringToUInt32(charsToUnEscape, i + 2, 2));
							sequenceLength = 3;
							break;

						// latin dec encoded symbol
						case '1':
						case '2':
						case '3':
						case '4':
						case '5':
						case '6':
						case '7':
						case '8':
						case '9':
						case '0':
							resultBuilder.Append((char)StringToInt32(charsToUnEscape, i + 1, 3));
							sequenceLength = 3;
							break;
						default:
							if (!strict)
							{
								resultBuilder.Append(sequenceKind);
								break;
							}
							else
							{
								throw ReaderException.UnknownEscapeSequence("\\" + sequenceKind, null);
							}
					}

					// set next chunk start right after this escape
					plainStart = i + sequenceLength + 1;
					i += sequenceLength;
				}

				// append last unencoded chunk
				if (plainLen != 0)
				{
					resultBuilder.Append(charsToUnEscape, plainStart, plainLen);
				}

				return resultBuilder.ToString();
			}
			private static int GetUnEscapedCount(char[] charsToUnEscape, int offset, int count)
			{
				if (charsToUnEscape == null) throw new ArgumentNullException(nameof(charsToUnEscape));
				if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
				if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
				if (offset + count > charsToUnEscape.Length) throw new ArgumentOutOfRangeException(nameof(offset));

				var newCount = 0;
				var end = offset + count;
				for (var i = offset; i < end; i++)
				{
					var ch = charsToUnEscape[i];
					newCount++;
					if (ch != '\\')
					{
						continue;
					}

					var toSkip = 1;
					var sequenceKind = charsToUnEscape[i + 1];
					switch (sequenceKind)
					{
						// unicode symbol
						case 'u':
							toSkip = 5;
							break;

						// latin hex encoded symbol
						case 'x':
							toSkip = 3;
							break;
						// latin dec encoded symbol
						case '1':
						case '2':
						case '3':
						case '4':
						case '5':
						case '6':
						case '7':
						case '8':
						case '9':
						case '0':
							toSkip = 3;
							break;
						default:
							toSkip = 1;
							break;
					}
					i += toSkip;
				}
				return newCount;
			}

			public static uint HexStringToUInt32(char[] buffer, int offset, int count)
			{
				const uint ZERO = '0';
				const uint a = 'a';
				const uint A = 'A';

				var result = 0u;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					var d = 0u;
					if (c >= '0' && c <= '9')
						d = (c - ZERO);
					else if (c >= 'a' && c <= 'f')
						d = 10u + (c - a);
					else if (c >= 'A' && c <= 'F')
						d = 10u + (c - A);
					else
						throw new FormatException();

					result = 16u * result + d;
				}

				return result;
			}

			public static long StringToInt64(char[] buffer, int offset, int count)
			{
				const ulong ZERO = '0';

				var result = 0UL;
				var neg = false;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					if (i == 0 && c == '-')
					{
						neg = true;
						continue;
					}
					if (c < '0' || c > '9')
						throw new FormatException();

					result = checked(10UL * result + (c - ZERO));
				}

				if (neg)
					return -(long)(result);
				return (long)result;
			}
			public static int StringToInt32(char[] buffer, int offset, int count)
			{
				const uint ZERO = '0';

				var result = 0u;
				var neg = false;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					if (i == 0 && c == '-')
					{
						neg = true;
						continue;
					}
					if (c < '0' || c > '9')
						throw new FormatException();

					result = checked(10u * result + (c - ZERO));
				}

				if (neg)
					return -(int)(result);
				return (int)result;
			}
			public static ulong StringToUInt64(char[] buffer, int offset, int count)
			{
				const ulong ZERO = '0';

				var result = 0UL;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					if (c < '0' || c > '9')
						throw new FormatException();

					result = checked(10UL * result + (c - ZERO));
				}

				return result;
			}
			public static uint StringToUInt32(char[] buffer, int offset, int count)
			{
				const uint ZERO = '0';

				var result = 0U;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					if (c < '0' || c > '9')
						throw new FormatException();

					result = checked(10 * result + (c - ZERO));
				}

				return result;
			}
		}

		private static class JsonNotation
		{
			public const char Tab = '\t';
			public const char Space = ' ';
			public const char Newline = '\n';
			public const char Return = '\r';
			public const char IdentifierSeparator = ':';
			public const char ValueSeparator = ',';
			public const char BeginArray = '[';
			public const char EndArray = ']';
			public const char BeginObject = '{';
			public const char EndObject = '}';
			public const char Escape = '\\';
			public const char Comment = '/';
			public const char CommentMultiline = '*';
			public const char Quote = '\"';
			public const char Const0 = '0';
			public const char Const1 = '1';
			public const char Const2 = '2';
			public const char Const3 = '3';
			public const char Const4 = '4';
			public const char Const5 = '5';
			public const char Const6 = '6';
			public const char Const7 = '7';
			public const char Const8 = '8';
			public const char Const9 = '9';
			public const string True = "true";
			public const string False = "false";
			public const string Null = "null";
		}
	}


	public sealed class MessagePackGameDataReader : GameDataReader
	{
		private const int DEFAULT_BUFFER_SIZE = ushort.MaxValue;
		private const int MAX_BINARY_LENGTH = 16 * 1024 * 1024;
		private const int MAX_STRING_LENGTH = 16 * 1024 * 1024;

		private struct Map
		{
			public ReaderToken Token;
			public long Counter;
		}

		private readonly Stream inputStream;
		private readonly bool leaveOpen;
		private readonly byte[] buffer;
		private readonly EndianBitConverter bitConverter;
		private readonly Stack<Map> maps;
		private ReaderNode node;
		private int bufferOffset;
		private int bufferRead;
		private int bufferAvailable;
		private int totalBytesRead;

		private StrongBox<int> int32Box;
		private StrongBox<uint> uInt32Box;
		private StrongBox<long> int64Box;
		private StrongBox<ulong> uInt64Box;
		private StrongBox<float> singleBox;
		private StrongBox<double> doubleBox;
		private StrongBox<decimal> decimalBox;
		private StrongBox<DateTime> dateBox;
		private StrongBox<DateTimeOffset> dateOffsetBox;
		private StrongBox<TimeSpan> timeSpanBox;
		private StrongBox<Guid> guidBox;
		private StrongBox<bool> trueBox;
		private StrongBox<bool> falseBox;

		public override int LineNumber => 0;
		public override int ColumnNumber => this.totalBytesRead;
		public override ReaderNode Node { get { if (this.node.Token == ReaderToken.None) this.NextToken(); return this.node; } }

		public MessagePackGameDataReader(Stream stream, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE)
		{
			if (stream == null) throw new ArgumentNullException(nameof(stream));

			if (bufferSize < DEFAULT_BUFFER_SIZE)
				bufferSize = DEFAULT_BUFFER_SIZE;

			this.inputStream = stream;
			this.leaveOpen = leaveOpen;
			this.buffer = new byte[bufferSize];
			this.bufferOffset = 0;
			this.bufferRead = 0;
			this.bufferAvailable = 0;
			this.bitConverter = EndianBitConverter.Big;
			this.maps = new Stack<Map>();
		}

		public override bool NextToken()
		{
			if (this.maps.Count > 0 && this.maps.Peek().Counter == 0)
			{
				var closingToken = this.maps.Pop();
				this.node = new ReaderNode(closingToken.Token);

				this.DecrementClosingTokenCounter();
				return true;
			}

			if (!this.ReadToBuffer(1, throwOnEos: false))
			{
				this.node = new ReaderNode(ReaderToken.EndOfStream);
				return false;
			}

			var formatValue = this.buffer[this.bufferOffset];
			if (formatValue >= (byte)MessagePackType.FixArrayStart && formatValue <= (byte)MessagePackType.FixArrayEnd)
			{
				var arrayCount = formatValue - (byte)MessagePackType.FixArrayStart;

				this.maps.Push(new Map { Token = ReaderToken.EndOfArray, Counter = arrayCount + 1 });
				this.node = new ReaderNode(ReaderToken.BeginArray);
			}
			else if (formatValue >= (byte)MessagePackType.FixStrStart && formatValue <= (byte)MessagePackType.FixStrEnd)
			{
				var strCount = formatValue - (byte)MessagePackType.FixStrStart;
				var strBytes = this.ReadBytes(strCount);

				var token = ReaderToken.Value;
				if (this.maps.Count > 0)
				{
					var closingToken = this.maps.Peek();
					if (closingToken.Token == ReaderToken.EndOfObject && closingToken.Counter > 0 && closingToken.Counter % 2 == 0)
						token = ReaderToken.Member;
				}

				var strValue = default(string);

				System.Diagnostics.Debug.Assert(strBytes.Array != null, "strBytes.Array != null");

				strValue = Encoding.UTF8.GetString(strBytes.Array, strBytes.Offset, strBytes.Count);

				this.node = new ReaderNode(token, strValue);
			}
			else if (formatValue >= (byte)MessagePackType.FixMapStart && formatValue <= (byte)MessagePackType.FixMapEnd)
			{
				var mapCount = formatValue - (byte)MessagePackType.FixMapStart;
				this.maps.Push(new Map { Token = ReaderToken.EndOfObject, Counter = mapCount * 2 + 1 });
				this.node = new ReaderNode(ReaderToken.BeginObject);
			}
			else if (formatValue >= (byte)MessagePackType.NegativeFixIntStart)
			{
				this.node = new ReaderNode(ReaderToken.Value, this.Box(unchecked((sbyte)formatValue)));
			}
			else if (formatValue <= (byte)MessagePackType.PositiveFixIntEnd)
			{
				this.node = new ReaderNode(ReaderToken.Value, this.Box(formatValue));
			}
			else
			{
				switch ((MessagePackType)formatValue)
				{
					case MessagePackType.Nil:
						this.node = new ReaderNode(ReaderToken.Null);
						break;
					case MessagePackType.Array16:
					case MessagePackType.Array32:
						var arrayCount = 0L;
						if (formatValue == (int)MessagePackType.Array16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							arrayCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Array32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							arrayCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						if (arrayCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of array");

						this.maps.Push(new Map { Token = ReaderToken.EndOfArray, Counter = arrayCount + 1 });
						this.node = new ReaderNode(ReaderToken.BeginArray);
						break;
					case MessagePackType.Map16:
					case MessagePackType.Map32:
						var mapCount = 0L;
						if (formatValue == (int)MessagePackType.Map16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							mapCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Map32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							mapCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						if (mapCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of map");

						this.maps.Push(new Map { Token = ReaderToken.EndOfObject, Counter = mapCount * 2 + 1 });
						this.node = new ReaderNode(ReaderToken.BeginObject);
						break;
					case MessagePackType.Str16:
					case MessagePackType.Str32:
					case MessagePackType.Str8:
						var strBytesCount = 0L;
						if (formatValue == (int)MessagePackType.Str8)
						{
							this.ReadToBuffer(1, throwOnEos: true);
							strBytesCount = this.buffer[this.bufferOffset];
						}
						else if (formatValue == (int)MessagePackType.Str16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							strBytesCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Str32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							strBytesCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						var token = ReaderToken.Value;
						if (this.maps.Count > 0)
						{
							var closingToken = this.maps.Peek();
							if (closingToken.Token == ReaderToken.EndOfObject && closingToken.Counter > 0 && closingToken.Counter % 2 == 0)
								token = ReaderToken.Member;
						}

						if (strBytesCount > MAX_STRING_LENGTH) throw ReaderException.StringLiteralIsTooLong(this, (int)strBytesCount, MAX_STRING_LENGTH);

						var strBytes = this.ReadBytes(strBytesCount);
						System.Diagnostics.Debug.Assert(strBytes.Array != null, "strBytes.Array != null");
						var stringValue = Encoding.UTF8.GetString(strBytes.Array, strBytes.Offset, strBytes.Count);
						this.node = new ReaderNode(token, stringValue);
						break;
					case MessagePackType.Bin32:
					case MessagePackType.Bin16:
					case MessagePackType.Bin8:
						var bytesCount = 0L;
						if (formatValue == (int)MessagePackType.Bin8)
						{
							this.ReadToBuffer(1, throwOnEos: true);
							bytesCount = this.buffer[this.bufferOffset];
						}
						else if (formatValue == (int)MessagePackType.Bin16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							bytesCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Bin32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							bytesCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						if (bytesCount > MAX_BINARY_LENGTH) throw ReaderException.BinaryDataIsTooLong(this, (int)bytesCount, MAX_BINARY_LENGTH);
						if (bytesCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of binary data");

						var bytes = this.ReadBytes(bytesCount, forceNewBuffer: true);
						System.Diagnostics.Debug.Assert(bytes.Array != null, "bytes.Array != null");
						this.node = new ReaderNode(ReaderToken.Value, bytes.Array);
						break;
					case MessagePackType.FixExt1:
					case MessagePackType.FixExt16:
					case MessagePackType.FixExt2:
					case MessagePackType.FixExt4:
					case MessagePackType.FixExt8:
					case MessagePackType.Ext32:
					case MessagePackType.Ext16:
					case MessagePackType.Ext8:
						var extLength = 0L;
						if (formatValue == (int)MessagePackType.FixExt1)
							extLength = 1;
						else if (formatValue == (int)MessagePackType.FixExt2)
							extLength = 2;
						else if (formatValue == (int)MessagePackType.FixExt4)
							extLength = 4;
						else if (formatValue == (int)MessagePackType.FixExt8)
							extLength = 8;
						else if (formatValue == (int)MessagePackType.FixExt16)
							extLength = 16;
						if (formatValue == (int)MessagePackType.Ext8)
						{
							this.ReadToBuffer(1, throwOnEos: true);
							extLength = this.buffer[this.bufferOffset];
						}
						else if (formatValue == (int)MessagePackType.Ext16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							extLength = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Ext32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							extLength = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						this.ReadToBuffer(1, throwOnEos: true);
						var extType = this.buffer[this.bufferOffset];

						if (extLength > MAX_BINARY_LENGTH) throw ReaderException.BinaryDataIsTooLong(this, (int)extLength, MAX_BINARY_LENGTH);

						var data = this.ReadBytes(extLength, forceNewBuffer: true);
						System.Diagnostics.Debug.Assert(data.Array != null, "data.Array != null");
						if (!this.TryReadExtType(extType, data, out this.node))
							this.node = new ReaderNode(ReaderToken.Value, data.Array);
						break;
					case MessagePackType.False:
						this.node = new ReaderNode(ReaderToken.Value, this.Box(false));
						break;
					case MessagePackType.True:
						this.node = new ReaderNode(ReaderToken.Value, this.Box(true));
						break;
					case MessagePackType.Float32:
						this.ReadToBuffer(4, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToSingle(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Float64:
						this.ReadToBuffer(8, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToDouble(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Int16:
						this.ReadToBuffer(2, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToInt16(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Int32:
						this.ReadToBuffer(4, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToInt32(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Int64:
						this.ReadToBuffer(8, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToInt64(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Int8:
						this.ReadToBuffer(1, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(unchecked((sbyte)this.buffer[this.bufferOffset])));
						break;
					case MessagePackType.UInt16:
						this.ReadToBuffer(2, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box((uint)this.bitConverter.ToUInt16(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.UInt32:
						this.ReadToBuffer(4, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToUInt32(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.UInt64:
						this.ReadToBuffer(8, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToUInt64(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.UInt8:
						this.ReadToBuffer(1, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box((uint)this.buffer[this.bufferOffset]));
						break;
					case MessagePackType.PositiveFixIntStart:
					case MessagePackType.PositiveFixIntEnd:
					case MessagePackType.FixMapStart:
					case MessagePackType.FixMapEnd:
					case MessagePackType.FixArrayStart:
					case MessagePackType.FixArrayEnd:
					case MessagePackType.FixStrStart:
					case MessagePackType.FixStrEnd:
					case MessagePackType.Unused:
					case MessagePackType.NegativeFixIntStart:
					case MessagePackType.NegativeFixIntEnd:
					default: throw ReaderException.UnknownMessagePackType(((MessagePackType)formatValue).ToString(), this);
				}
			}

			this.DecrementClosingTokenCounter();

			return true;
		}

		private bool ReadToBuffer(int bytesRequired, bool throwOnEos)
		{
			this.bufferAvailable -= this.bufferRead;
			this.bufferOffset += this.bufferRead;
			this.bufferRead = 0;

			if (this.bufferAvailable < bytesRequired)
			{
				if (this.bufferAvailable > 0)
					Buffer.BlockCopy(this.buffer, this.bufferOffset, this.buffer, 0, this.bufferAvailable);

				this.bufferOffset = 0;
				while (this.bufferAvailable < bytesRequired)
				{
					var read = this.inputStream.Read(this.buffer, this.bufferAvailable, this.buffer.Length - this.bufferAvailable);
					this.bufferAvailable += read;

					if (read != 0 || this.bufferAvailable >= bytesRequired)
						continue;

					if (throwOnEos)
						throw ReaderException.UnexpectedEndOfStream(this);

					return false;
				}
			}

			this.bufferRead = bytesRequired;
			this.totalBytesRead += bytesRequired;
			return true;
		}
		private ArraySegment<byte> ReadBytes(long bytesRequired, bool forceNewBuffer = false)
		{
			if (bytesRequired > int.MaxValue) throw new ArgumentOutOfRangeException(nameof(bytesRequired));

			this.bufferAvailable -= this.bufferRead;
			this.bufferOffset += this.bufferRead;
			this.bufferRead = 0;

			if (this.bufferAvailable >= bytesRequired && !forceNewBuffer)
			{
				var bytes = new ArraySegment<byte>(this.buffer, this.bufferOffset, (int)bytesRequired);

				this.bufferAvailable -= (int)bytesRequired;
				this.bufferOffset += (int)bytesRequired;
				this.totalBytesRead += (int)bytesRequired;

				return bytes;
			}
			else
			{
				var bytes = new byte[bytesRequired];
				var bytesOffset = 0;
				if (this.bufferAvailable > 0 && bytesOffset < bytes.Length)
				{
					var bytesToCopy = Math.Min(bytes.Length, this.bufferAvailable);
					Buffer.BlockCopy(this.buffer, this.bufferOffset, bytes, bytesOffset, bytesToCopy);

					bytesOffset += bytesToCopy;
					this.bufferOffset += bytesToCopy;

					this.bufferAvailable -= bytesToCopy;
					this.totalBytesRead += bytesToCopy;
				}

				if (this.bufferAvailable == 0)
					this.bufferOffset = 0;

				while (bytesOffset < bytes.Length)
				{
					var read = this.inputStream.Read(bytes, bytesOffset, bytes.Length - bytesOffset);

					bytesOffset += read;
					this.totalBytesRead += read;

					if (read == 0 && bytesOffset < bytes.Length)
						throw ReaderException.UnexpectedEndOfStream(this);
				}

				return new ArraySegment<byte>(bytes, 0, bytes.Length);
			}
		}
		private bool TryReadExtType(byte extType, ArraySegment<byte> data, out ReaderNode node)
		{
			const byte EXTENSION_TYPE_TIMESTAMP = 255;
			const byte EXTENSION_TYPE_DATE_TIME = 40;
			const byte EXTENSION_TYPE_DATE_TIME_OFFSET = 41;
			const byte EXTENSION_TYPE_DECIMAL = 42;
			const byte EXTENSION_TYPE_GUID = 43;
			const byte GUID_SIZE = 16;
			const byte DECIMAL_SIZE = 16;
			const byte DATE_TIME_SIZE = 16;
			const byte DATE_TIME_OFFSET_SIZE = 16;

			node = default;
			switch (extType)
			{
				case EXTENSION_TYPE_TIMESTAMP:
					unchecked
					{
						var seconds = 0L;
						var nanoSeconds = 0u;
						switch (data.Count)
						{
							case 4:
								seconds = this.bitConverter.ToInt32(data.Array, data.Offset);
								break;
							case 8:
								var data64 = this.bitConverter.ToUInt64(data.Array, data.Offset);
								seconds = (int)(data64 & 0x00000003ffffffffL);
								nanoSeconds = (uint)(data64 >> 34 & uint.MaxValue);
								break;
							case 12:
								nanoSeconds = this.bitConverter.ToUInt32(data.Array, data.Offset);
								seconds = this.bitConverter.ToInt64(data.Array, data.Offset + 4);
								break;
							default:
								return false;
						}
						node = new ReaderNode(ReaderToken.Value, this.Box(TimeSpan.FromSeconds(seconds).Add(TimeSpan.FromTicks(nanoSeconds / 100))));
						return true;
					}
				case EXTENSION_TYPE_DATE_TIME:
					if (data.Count != DATE_TIME_SIZE)
						return false;
					System.Diagnostics.Debug.Assert(data.Array != null, "data.Array != null");
					var dateTime = new DateTime(this.bitConverter.ToInt64(data.Array, data.Offset + 1), (DateTimeKind)data.Array[data.Offset]);
					node = new ReaderNode(ReaderToken.Value, this.Box(dateTime));
					return true;
				case EXTENSION_TYPE_DATE_TIME_OFFSET:
					if (data.Count != DATE_TIME_OFFSET_SIZE)
						return false;
					var offset = new TimeSpan(this.bitConverter.ToInt64(data.Array, data.Offset + 8));
					var ticks = this.bitConverter.ToInt64(data.Array, data.Offset);
					var dateTimeOffset = new DateTimeOffset(ticks, offset);
					node = new ReaderNode(ReaderToken.Value, this.Box(dateTimeOffset));
					return true;
				case EXTENSION_TYPE_DECIMAL:
					if (data.Count != DECIMAL_SIZE)
						return false;
					var decimalValue = this.bitConverter.ToDecimal(data.Array, data.Offset);
					node = new ReaderNode(ReaderToken.Value, this.Box(decimalValue));
					return true;
				case EXTENSION_TYPE_GUID:
					if (data.Count != GUID_SIZE)
						return false;

					var buffer = data.Array;
					System.Diagnostics.Debug.Assert(buffer != null, "buffer != null");
					unchecked
					{
						var guidValue = new Guid
						(
								(uint)(buffer[data.Offset + 3] << 24 | buffer[data.Offset + 2] << 16 | buffer[data.Offset + 1] << 8 | buffer[data.Offset + 0]),
								(ushort)(buffer[data.Offset + 5] << 8 | buffer[data.Offset + 4]),
								(ushort)(buffer[data.Offset + 7] << 8 | buffer[data.Offset + 6]),
								buffer[data.Offset + 8],
								buffer[data.Offset + 9],
								buffer[data.Offset + 10],
								buffer[data.Offset + 11],
								buffer[data.Offset + 12],
								buffer[data.Offset + 13],
								buffer[data.Offset + 14],
								buffer[data.Offset + 15]
						);

						node = new ReaderNode(ReaderToken.Value, this.Box(guidValue));
						return true;
					}
				default:
					return false;
			}
		}

		private object Box(int value)
		{
			var int32Box = this.int32Box ?? (this.int32Box = new StrongBox<int>(CultureInfo.InvariantCulture));
			int32Box.Store(value);
			return int32Box;
		}
		private object Box(uint value)
		{
			var uInt32Box = this.uInt32Box ?? (this.uInt32Box = new StrongBox<uint>(CultureInfo.InvariantCulture));
			uInt32Box.Store(value);
			return uInt32Box;
		}
		private object Box(long value)
		{
			var int64Box = this.int64Box ?? (this.int64Box = new StrongBox<Int64>(CultureInfo.InvariantCulture));
			int64Box.Store(value);
			return int64Box;
		}
		private object Box(ulong value)
		{
			var uInt64Box = this.uInt64Box ?? (this.uInt64Box = new StrongBox<UInt64>(CultureInfo.InvariantCulture));
			uInt64Box.Store(value);
			return uInt64Box;
		}
		private object Box(float value)
		{
			var singleBox = this.singleBox ?? (this.singleBox = new StrongBox<float>(CultureInfo.InvariantCulture));
			singleBox.Store(value);
			return singleBox;
		}
		private object Box(double value)
		{
			var doubleBox = this.doubleBox ?? (this.doubleBox = new StrongBox<double>(CultureInfo.InvariantCulture));
			doubleBox.Store(value);
			return doubleBox;
		}
		private object Box(decimal value)
		{
			var decimalBox = this.decimalBox ?? (this.decimalBox = new StrongBox<decimal>(CultureInfo.InvariantCulture));
			decimalBox.Store(value);
			return decimalBox;
		}
		private object Box(DateTime value)
		{
			var dateBox = this.dateBox ?? (this.dateBox = new StrongBox<DateTime>(CultureInfo.InvariantCulture));
			dateBox.Store(value);
			return dateBox;
		}
		private object Box(DateTimeOffset value)
		{
			var dateOffsetBox = this.dateOffsetBox ?? (this.dateOffsetBox = new StrongBox<DateTimeOffset>(CultureInfo.InvariantCulture));
			dateOffsetBox.Store(value);
			return dateOffsetBox;
		}
		private object Box(TimeSpan value)
		{
			var timeSpanBox = this.timeSpanBox ?? (this.timeSpanBox = new StrongBox<TimeSpan>(CultureInfo.InvariantCulture));
			timeSpanBox.Store(value);
			return timeSpanBox;
		}
		private object Box(Guid value)
		{
			var guidBox = this.guidBox ?? (this.guidBox = new StrongBox<Guid>(CultureInfo.InvariantCulture));
			guidBox.Store(value);
			return guidBox;
		}
		private object Box(bool value)
		{
			if (value)
			{
				return this.trueBox ?? (this.trueBox = new StrongBox<bool>(true, CultureInfo.InvariantCulture));
			}
			return this.falseBox ?? (this.falseBox = new StrongBox<bool>(false, CultureInfo.InvariantCulture));
		}

		private void DecrementClosingTokenCounter()
		{
			if (this.maps.Count > 0)
			{
				var closingToken = this.maps.Pop();
				closingToken.Counter--;
				this.maps.Push(closingToken);
			}
		}

		public override void Dispose()
		{
			if (!this.leaveOpen)
			{
				this.inputStream.Dispose();
			}
		}


		private enum MessagePackType : byte
		{
			PositiveFixIntStart = 0x00,
			PositiveFixIntEnd = 0x7f,
			FixMapStart = 0x80,
			FixMapEnd = 0x8f,
			FixArrayStart = 0x90,
			FixArrayEnd = 0x9f,
			FixStrStart = 0xa0,
			FixStrEnd = 0xbf,
			Nil = 0xc0,
			Unused = 0xc1,
			False = 0xc2,
			True = 0xc3,
			Bin8 = 0xc4,
			Bin16 = 0xc5,
			Bin32 = 0xc6,
			Ext8 = 0xc7,
			Ext16 = 0xc8,
			Ext32 = 0xc9,
			Float32 = 0xca,
			Float64 = 0xcb,
			UInt8 = 0xcc,
			UInt16 = 0xcd,
			UInt32 = 0xce,
			UInt64 = 0xcf,
			Int8 = 0xd0,
			Int16 = 0xd1,
			Int32 = 0xd2,
			Int64 = 0xd3,
			FixExt1 = 0xd4,
			FixExt2 = 0xd5,
			FixExt4 = 0xd6,
			FixExt8 = 0xd7,
			FixExt16 = 0xd8,
			Str8 = 0xd9,
			Str16 = 0xda,
			Str32 = 0xdb,
			Array16 = 0xdc,
			Array32 = 0xdd,
			Map16 = 0xde,
			Map32 = 0xdf,
			NegativeFixIntStart = 0xe0,
			NegativeFixIntEnd = 0xff
		}

		private enum MessagePackExtentionType : byte
		{
			None = 0,
			DateTime = 40,
			DateTimeOffset = 41,
			Decimal = 42
		}
	}


	[Serializable]
	public class ReaderException : SerializationException
	{
		public int Code { get; set; }
		public int LineNumber { get; set; }
		public int ColumnNumber { get; set; }

		private ReaderException(string message, GameDataReader gameDataReader)
			: base(message)
		{
			if (message == null) throw new ArgumentNullException(nameof(message));

			if (gameDataReader != null)
				this.Update(gameDataReader);
		}

		protected ReaderException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			if (info == null) throw new ArgumentNullException(nameof(info));

			this.LineNumber = info.GetInt32("LineNumber");
			this.ColumnNumber = info.GetInt32("ColumnNumber");
		}

		private void Update(GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			this.LineNumber = gameDataReader.LineNumber;
			this.ColumnNumber = gameDataReader.ColumnNumber;
		}

		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			if (info == null) throw new ArgumentNullException(nameof(info));

			info.AddValue("Code", this.Code);
			info.AddValue("LineNumber", this.LineNumber);
			info.AddValue("ColumnNumber", this.ColumnNumber);

			base.GetObjectData(info, context);
		}

		public static Exception UnexpectedEndOfStream(GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException("Unexpected end of stream.", gameDataReader);
		}
		public static Exception UnexpectedToken(GameDataReader gameDataReader, params ReaderToken[] expectedTokens)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));
			if (expectedTokens == null) throw new ArgumentNullException(nameof(expectedTokens));

			var tokensStr = default(string);
			if (expectedTokens.Length == 0)
			{
				tokensStr = "<no tokens>";
			}
			else
			{
				var tokens = Array.ConvertAll(expectedTokens, c => c.ToString());
				tokensStr = String.Join(", ", tokens);
			}

			return new ReaderException($"Expected one of there '{tokensStr}' but found '{gameDataReader.Node.Token}'({gameDataReader.Node.ValueType?.Name ?? "<null>"}).",
				gameDataReader);
		}
		public static Exception UnknownEscapeSequence(string escape, GameDataReader gameDataReader)
		{
			if (escape == null) throw new ArgumentNullException(nameof(escape));
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"An unknown escape sequence '{escape}'.", gameDataReader);
		}
		public static Exception UnterminatedStringLiteral(GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException("An unterminated string literal.", gameDataReader);
		}
		public static Exception UnknownNotation(GameDataReader gameDataReader, string notation)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"An unknown notation '{notation}'.", gameDataReader);
		}
		public static Exception StringLiteralIsTooLong(GameDataReader gameDataReader, int size, int maxSize)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"String literal is too long '{size}'. Maximum size is {maxSize}.", gameDataReader);
		}
		public static Exception BinaryDataIsTooLong(GameDataReader gameDataReader, int size, int maxSize)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"Binary data is too long '{size}'. Maximum size is {maxSize}.", gameDataReader);
		}
		public static Exception ReadingBrokenDocument(GameDataReader gameDataReader, string additionalInformation)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"Failed to continue deserialize because document's structure is invalid. Additional information: {additionalInformation}", gameDataReader);
		}
		public static Exception UnknownMessagePackType(string type, GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"An unknown Message Pack type '{type}'.", gameDataReader);
		}
		public static Exception UnexpectedNullValue(string expected, string propertyName, string schemaName, GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"A null value is deserialized instead of {expected} for required property '{propertyName}' in schema '{schemaName}'.",
				gameDataReader);
		}
	}


	public readonly struct ReaderNode
	{
		private readonly object value;

		public readonly ReaderToken Token;
		public readonly Type ValueType;

		public bool HasValue => this.ValueType != typeof(void);

		public ReaderNode(ReaderToken token)
		{
			this.Token = token;
			this.value = null;
			this.ValueType = typeof(void);
		}
		public ReaderNode(ReaderToken token, object value)
		{
			if (value == null) throw new ArgumentNullException(nameof(value));

			this.Token = token;
			this.value = value;
			this.ValueType = value is IStrongBox box ? box.ValueType : value.GetType();
		}

		public bool AsBoolean
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsBoolean;

				return Convert.ToBoolean(this.value, CultureInfo.InvariantCulture);
			}
		}
		public byte AsByte
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsByte;

				return Convert.ToByte(this.value, CultureInfo.InvariantCulture);
			}
		}
		public short AsInt16
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsInt16;

				return Convert.ToInt16(this.value, CultureInfo.InvariantCulture);
			}
		}
		public int AsInt32
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsInt32;

				return Convert.ToInt32(this.value, CultureInfo.InvariantCulture);
			}
		}
		public long AsInt64
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsInt64;

				return Convert.ToInt64(this.value, CultureInfo.InvariantCulture);
			}
		}
		public sbyte AsSByte
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsSByte;

				return Convert.ToSByte(this.value, CultureInfo.InvariantCulture);
			}
		}
		public ushort AsUInt16
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsUInt16;

				return Convert.ToUInt16(this.value, CultureInfo.InvariantCulture);
			}
		}
		public uint AsUInt32
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsUInt32;

				return Convert.ToUInt32(this.value, CultureInfo.InvariantCulture);
			}
		}
		public ulong AsUInt64
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsUInt64;

				return Convert.ToUInt64(this.value, CultureInfo.InvariantCulture);
			}
		}
		public float AsSingle
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsSingle;

				return Convert.ToSingle(this.value, CultureInfo.InvariantCulture);
			}
		}
		public double AsDouble
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsDouble;

				return Convert.ToDouble(this.value, CultureInfo.InvariantCulture);
			}
		}
		public decimal AsDecimal
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsDecimal;

				return Convert.ToDecimal(this.value, CultureInfo.InvariantCulture);
			}
		}
		public string AsString
		{
			get
			{
				var value = this.value;
				if (this.value is IStrongBox box) value = box.AsObject;
				return Convert.ToString(value, CultureInfo.InvariantCulture);
			}
		}
		public DateTime AsDateTime
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsDateTime;

				var dateTimeStr = this.AsString;
				var date = DateTime.ParseExact(dateTimeStr, GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
				return date;
			}
		}
		public DateTimeOffset AsDateTimeOffset
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsDateTime;

				var dateTimeStr = this.AsString;
				var date = DateTimeOffset.ParseExact(dateTimeStr, GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
				return date;
			}
		}
		public TimeSpan AsTimeSpan
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsTimeSpan;

				var timeSpanStr = this.AsString;
				var timeSpan = TimeSpan.Parse(timeSpanStr);
				return timeSpan;
			}
		}
		public object AsObject
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsObject;

				return this.value;
			}
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "{0}:{1}", this.Token, this.value);
		}
	}


	public enum ReaderToken
	{
		None = 0,
		BeginArray,
		EndOfArray,
		BeginObject,
		EndOfObject,
		Member,
		Null,
		Value,
		Comment,
		EndOfStream
	}


	public sealed class StringLookupTable
	{
		public const int MAX_STRING_SIZE = 8 * 8;

		private readonly StringSet[] table;

		public StringLookupTable(StringSet[] table)
		{
			if (table == null) throw new ArgumentNullException(nameof(table));

			this.table = table;
			Array.Resize(ref this.table, MAX_STRING_SIZE + 1);
		}

		public bool TryGetString(byte[] bytes, int offset, int count, out string value)
		{
			const int LAST_ASCII_CHARACTER = 0x7f;

			if (bytes == null)
			{
				throw new ArgumentNullException(nameof(bytes));
			}

			if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
			if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
			if (offset + count > bytes.Length) throw new ArgumentOutOfRangeException(nameof(offset));

			if (count == 0)
			{
				value = string.Empty;
				return true;
			}

			value = null;
			if (count > MAX_STRING_SIZE || this.table[count] == null)
			{
				return false;
			}

			var end = offset + count;
			var octet = 0UL;
			for (var i = 0; offset + i < end; i++)
			{
				var character = bytes[offset + i];
				if (character > LAST_ASCII_CHARACTER)
				{
					return false;
				}

				if (i < 8)
				{
					octet = unchecked(octet | ((ulong)character << 8 * i));
				}
			}

			var set = this.table[count];
			var narrowOffset = 1;
			for (var i = 0; i < (count - 1) / 8; i++, narrowOffset++)
			{
				if (set == null || !set.TryNarrow(octet, out set))
				{
					return false;
				}

				octet = GetUInt64(bytes, offset + narrowOffset * 8, end);
			}

			return set != null && set.TryGetValue(octet, out value);
		}
		public bool TryGetString(char[] chars, int offset, int count, out string value)
		{
			const int LAST_ASCII_CHARACTER = 0x7f;

			if (chars == null)
			{
				throw new ArgumentNullException(nameof(chars));
			}

			if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
			if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
			if (offset + count > chars.Length) throw new ArgumentOutOfRangeException(nameof(offset));

			if (count == 0)
			{
				value = string.Empty;
				return true;
			}

			value = null;
			if (count > MAX_STRING_SIZE || this.table[count] == null)
			{
				return false;
			}

			var end = offset + count;
			var octet = 0UL;
			for (var i = 0; offset + i < end; i++)
			{
				var character = chars[offset + i];
				if (character > LAST_ASCII_CHARACTER)
				{
					return false;
				}

				if (i < 8)
				{
					octet = unchecked(octet | ((ulong)character << 8 * i));
				}
			}

			var set = this.table[count];
			var narrowOffset = 1;
			for (var i = 0; i < (count - 1) / 8; i++, narrowOffset++)
			{
				if (set == null || !set.TryNarrow(octet, out set))
				{
					return false;
				}

				octet = GetUInt64(chars, offset + narrowOffset * 8, end);
			}

			return set != null && set.TryGetValue(octet, out value);
		}

		private static ulong GetUInt64(byte[] bytes, int offset, int end)
		{
			if (offset >= end)
			{
				return 0;
			}

			switch (end - offset)
			{
				case 1: return (ulong)bytes[offset];
				case 2:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1;
				case 3:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2;
				case 4:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3;
				case 5:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3 |
						(ulong)bytes[offset + 4] << 8 * 4;
				case 6:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3 |
						(ulong)bytes[offset + 4] << 8 * 4 |
						(ulong)bytes[offset + 5] << 8 * 5;
				case 7:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3 |
						(ulong)bytes[offset + 4] << 8 * 4 |
						(ulong)bytes[offset + 5] << 8 * 5 |
						(ulong)bytes[offset + 6] << 8 * 6;
				default:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3 |
						(ulong)bytes[offset + 4] << 8 * 4 |
						(ulong)bytes[offset + 5] << 8 * 5 |
						(ulong)bytes[offset + 6] << 8 * 6 |
						(ulong)bytes[offset + 7] << 8 * 7;
			}
		}
		private static ulong GetUInt64(char[] chars, int offset, int end)
		{
			if (offset >= end)
			{
				return 0;
			}

			switch (end - offset)
			{
				case 1: return (ulong)chars[offset];
				case 2:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1;
				case 3:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2;
				case 4:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3;
				case 5:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3 |
						(ulong)chars[offset + 4] << 8 * 4;
				case 6:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3 |
						(ulong)chars[offset + 4] << 8 * 4 |
						(ulong)chars[offset + 5] << 8 * 5;
				case 7:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3 |
						(ulong)chars[offset + 4] << 8 * 4 |
						(ulong)chars[offset + 5] << 8 * 5 |
						(ulong)chars[offset + 6] << 8 * 6;
				default:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3 |
						(ulong)chars[offset + 4] << 8 * 4 |
						(ulong)chars[offset + 5] << 8 * 5 |
						(ulong)chars[offset + 6] << 8 * 6 |
						(ulong)chars[offset + 7] << 8 * 7;
			}
		}
	}


	public sealed class StringSet
	{
		public static readonly Comparer<ulong> KeyComparer = Comparer<ulong>.Default;

		private readonly ulong[] keys;
		private readonly StringSet[] subSets;
		private readonly string[] values;

		public StringSet(ulong[] keys, StringSet[] subSets)
		{
			if (keys == null) throw new ArgumentNullException(nameof(keys));
			if (subSets == null) throw new ArgumentNullException(nameof(subSets));
			if (subSets.Length != keys.Length) throw new ArgumentException("invalid sets", nameof(keys));

			this.keys = keys;
			this.subSets = subSets;
		}
		public StringSet(ulong[] keys, string[] values)
		{
			if (keys == null) throw new ArgumentNullException(nameof(keys));
			if (values == null) throw new ArgumentNullException(nameof(values));
			if (values.Length != keys.Length) throw new ArgumentException("invalid sets", nameof(keys));

			this.keys = keys;
			this.values = values;
		}

		public bool TryNarrow(ulong octet, out StringSet value)
		{
			var subSetIndex = 0;
			switch (this.keys.Length)
			{
				case 1:
					subSetIndex = this.keys[0] == octet ? 0 : -1;
					break;
				case 2:
					subSetIndex = this.keys[0] == octet ? 0 : this.keys[1] == octet ? 1 : -1;
					break;
				case 3:
				case 4:
				case 5:
					subSetIndex = Array.IndexOf(this.keys, octet, 0, this.keys.Length);
					break;
				default:
					subSetIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, octet, KeyComparer);
					break;
			}

			if (subSetIndex < 0)
			{
				value = null;
				return false;
			}

			value = this.subSets[subSetIndex];
			return true;
		}
		public bool TryGetValue(ulong octet, out string value)
		{
			var valueIndex = 0;
			switch (this.keys.Length)
			{
				case 1:
					valueIndex = this.keys[0] == octet ? 0 : -1;
					break;
				case 2:
					valueIndex = this.keys[0] == octet ? 0 : this.keys[1] == octet ? 1 : -1;
					break;
				case 3:
				case 4:
				case 5:
					valueIndex = Array.IndexOf(this.keys, octet, 0, this.keys.Length);
					break;
				default:
					valueIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, octet, KeyComparer);
					break;
			}

			if (valueIndex < 0)
			{
				value = null;
				return false;
			}

			value = this.values[valueIndex];
			return value != null;
		}
	}


	public sealed class StrongBox<ValueT> : IStrongBox
	{
		private static readonly Type ValueType = typeof(ValueT);

		private readonly IFormatProvider formatProvider;

		public ValueT Value;

		public StrongBox(ValueT value, IFormatProvider formatProvider)
			: this(formatProvider)
		{
			this.Value = value;
		}
		public StrongBox(IFormatProvider formatProvider)
		{
			if (formatProvider == null) throw new ArgumentNullException(nameof(formatProvider));

			this.formatProvider = formatProvider;
		}

		Type IStrongBox.ValueType => ValueType;
		public bool AsBoolean => this.Value is bool asBoolean ? asBoolean : Convert.ToBoolean(this.Value, this.formatProvider);
		public byte AsByte => this.Value is byte asByte ? asByte :  Convert.ToByte(this.Value, this.formatProvider);
		public short AsInt16 => this.Value is short asInt16 ? asInt16 : Convert.ToInt16(this.Value, this.formatProvider);
		public int AsInt32 => this.Value is int asInt32 ? asInt32 : Convert.ToInt32(this.Value, this.formatProvider);
		public long AsInt64 => this.Value is long asInt64 ? asInt64 : Convert.ToInt64(this.Value, this.formatProvider);
		public sbyte AsSByte => this.Value is sbyte asSByte ? asSByte : Convert.ToSByte(this.Value, this.formatProvider);
		public ushort AsUInt16 => this.Value is ushort asUInt16 ? asUInt16 : Convert.ToUInt16(this.Value, this.formatProvider);
		public uint AsUInt32 => this.Value is uint asUInt32 ? asUInt32 : Convert.ToUInt32(this.Value, this.formatProvider);
		public ulong AsUInt64 => this.Value is ulong asUInt64 ? asUInt64 : Convert.ToUInt64(this.Value, this.formatProvider);
		public float AsSingle => this.Value is float asSingle ? asSingle : Convert.ToSingle(this.Value, this.formatProvider);
		public double AsDouble => this.Value is double asDouble ? asDouble : Convert.ToDouble(this.Value, this.formatProvider);
		public decimal AsDecimal => this.Value is decimal asDecimal ? asDecimal : Convert.ToDecimal(this.Value, this.formatProvider);
		public DateTime AsDateTime => this.Value is DateTime asDateTime ? asDateTime : Convert.ToDateTime(this.Value, this.formatProvider);
		public DateTimeOffset AsDateTimeOffset => this.Value is DateTimeOffset asDateTimeOffset ? asDateTimeOffset : new DateTimeOffset(Convert.ToDateTime(this.Value, this.formatProvider));
		public TimeSpan AsTimeSpan => this.Value is TimeSpan asTimeSpan ? asTimeSpan : TimeSpan.Parse(this.AsString ?? string.Empty, this.formatProvider);
		public string AsString => this.Value?.ToString();
		public object AsObject => this.Value;

		public void Store<T>(T value)
		{
			var type = typeof(T);
			if (type != ValueType)
			{
				throw new ArgumentException($"Unable to store value of type '{typeof(ValueT)}' in container of type '{type}'");
			}

			this.Value = (ValueT)(object)value;
		}

		public override string ToString()
		{
			return Convert.ToString(this.Value, this.formatProvider);
		}
	}

#>
